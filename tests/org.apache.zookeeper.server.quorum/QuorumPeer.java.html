<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuorumPeer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">parent$MyZookeeperRemoveWatchesTest.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server.quorum</a> &gt; <span class="el_source">QuorumPeer.java</span></div><h1>QuorumPeer.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.zookeeper.server.quorum;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

import javax.security.sasl.SaslException;

import org.apache.zookeeper.KeeperException.BadArgumentsException;
import org.apache.zookeeper.common.AtomicFileWritingIdiom;
import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;
import org.apache.zookeeper.common.QuorumX509Util;
import org.apache.zookeeper.common.Time;
import org.apache.zookeeper.common.X509Exception;
import org.apache.zookeeper.jmx.MBeanRegistry;
import org.apache.zookeeper.jmx.ZKMBeanInfo;
import org.apache.zookeeper.server.ServerCnxnFactory;
import org.apache.zookeeper.server.ZKDatabase;
import org.apache.zookeeper.server.ZooKeeperServer;
import org.apache.zookeeper.server.ZooKeeperThread;
import org.apache.zookeeper.server.quorum.auth.QuorumAuth;
import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;
import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;
import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthLearner;
import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthServer;
import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthLearner;
import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthServer;
import org.apache.zookeeper.server.admin.AdminServer;
import org.apache.zookeeper.server.admin.AdminServer.AdminServerException;
import org.apache.zookeeper.server.admin.AdminServerFactory;
import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
import org.apache.zookeeper.server.util.ConfigUtils;
import org.apache.zookeeper.server.util.ZxidUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.apache.zookeeper.common.NetUtils.formatInetAddr;

/**
 * This class manages the quorum protocol. There are three states this server
 * can be in:
 * &lt;ol&gt;
 * &lt;li&gt;Leader election - each server will elect a leader (proposing itself as a
 * leader initially).&lt;/li&gt;
 * &lt;li&gt;Follower - the server will synchronize with the leader and replicate any
 * transactions.&lt;/li&gt;
 * &lt;li&gt;Leader - the server will process requests and forward them to followers.
 * A majority of followers must log the request before it can be accepted.
 * &lt;/ol&gt;
 *
 * This class will setup a datagram socket that will always respond with its
 * view of the current leader. The response will take the form of:
 *
 * &lt;pre&gt;
 * int xid;
 *
 * long myid;
 *
 * long leader_id;
 *
 * long leader_zxid;
 * &lt;/pre&gt;
 *
 * The request for the current leader will consist solely of an xid: int xid;
 */
<span class="nc bnc" id="L109" title="All 2 branches missed.">public class QuorumPeer extends ZooKeeperThread implements QuorumStats.Provider {</span>
<span class="nc" id="L110">    private static final Logger LOG = LoggerFactory.getLogger(QuorumPeer.class);</span>

    private QuorumBean jmxQuorumBean;
    LocalPeerBean jmxLocalPeerBean;
    private Map&lt;Long, RemotePeerBean&gt; jmxRemotePeerBean;
    LeaderElectionBean jmxLeaderElectionBean;

    // The QuorumCnxManager is held through an AtomicReference to ensure cross-thread visibility
    // of updates; see the implementation comment at setLastSeenQuorumVerifier().
<span class="nc" id="L119">    private AtomicReference&lt;QuorumCnxManager&gt; qcmRef = new AtomicReference&lt;&gt;();</span>

    QuorumAuthServer authServer;
    QuorumAuthLearner authLearner;

    /**
     * ZKDatabase is a top level member of quorumpeer
     * which will be used in all the zookeeperservers
     * instantiated later. Also, it is created once on
     * bootup and only thrown away in case of a truncate
     * message from the leader
     */
    private ZKDatabase zkDb;

    public static final class AddressTuple {
        public final InetSocketAddress quorumAddr;
        public final InetSocketAddress electionAddr;
        public final InetSocketAddress clientAddr;

<span class="nc" id="L138">        public AddressTuple(InetSocketAddress quorumAddr, InetSocketAddress electionAddr, InetSocketAddress clientAddr) {</span>
<span class="nc" id="L139">            this.quorumAddr = quorumAddr;</span>
<span class="nc" id="L140">            this.electionAddr = electionAddr;</span>
<span class="nc" id="L141">            this.clientAddr = clientAddr;</span>
<span class="nc" id="L142">        }</span>
    }

<span class="nc bnc" id="L145" title="All 2 branches missed.">    public static class QuorumServer {</span>
<span class="nc" id="L146">        public InetSocketAddress addr = null;</span>

<span class="nc" id="L148">        public InetSocketAddress electionAddr = null;</span>
        
<span class="nc" id="L150">        public InetSocketAddress clientAddr = null;</span>
        
        public long id;

        public String hostname;
        
<span class="nc" id="L156">        public LearnerType type = LearnerType.PARTICIPANT;</span>
        
        private List&lt;InetSocketAddress&gt; myAddrs;

        public QuorumServer(long id, InetSocketAddress addr,
                InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
<span class="nc" id="L162">            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);</span>
<span class="nc" id="L163">        }</span>

        public QuorumServer(long id, InetSocketAddress addr,
                InetSocketAddress electionAddr) {
<span class="nc" id="L167">            this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);</span>
<span class="nc" id="L168">        }</span>

        // VisibleForTesting
        public QuorumServer(long id, InetSocketAddress addr) {
<span class="nc" id="L172">            this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);</span>
<span class="nc" id="L173">        }</span>
 
        public long getId() {
<span class="nc" id="L176">            return id;</span>
        }

        /**
         * Performs a DNS lookup for server address and election address.
         *
         * If the DNS lookup fails, this.addr and electionAddr remain
         * unmodified.
         */
        public void recreateSocketAddresses() {
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (this.addr == null) {</span>
<span class="nc" id="L187">                LOG.warn(&quot;Server address has not been initialized&quot;);</span>
<span class="nc" id="L188">                return;</span>
            }
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if (this.electionAddr == null) {</span>
<span class="nc" id="L191">                LOG.warn(&quot;Election address has not been initialized&quot;);</span>
<span class="nc" id="L192">                return;</span>
            }
<span class="nc" id="L194">            String host = this.addr.getHostString();</span>
<span class="nc" id="L195">            InetAddress address = null;</span>
            try {
<span class="nc" id="L197">                address = InetAddress.getByName(host);</span>
<span class="nc" id="L198">            } catch (UnknownHostException ex) {</span>
<span class="nc" id="L199">                LOG.warn(&quot;Failed to resolve address: {}&quot;, host, ex);</span>
<span class="nc" id="L200">                return;</span>
<span class="nc" id="L201">            }</span>
<span class="nc" id="L202">            LOG.debug(&quot;Resolved address for {}: {}&quot;, host, address);</span>
<span class="nc" id="L203">            int port = this.addr.getPort();</span>
<span class="nc" id="L204">            this.addr = new InetSocketAddress(address, port);</span>
<span class="nc" id="L205">            port = this.electionAddr.getPort();</span>
<span class="nc" id="L206">            this.electionAddr = new InetSocketAddress(address, port);</span>
<span class="nc" id="L207">        }</span>

        private void setType(String s) throws ConfigException {
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (s.toLowerCase().equals(&quot;observer&quot;)) {</span>
<span class="nc" id="L211">               type = LearnerType.OBSERVER;</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">           } else if (s.toLowerCase().equals(&quot;participant&quot;)) {</span>
<span class="nc" id="L213">               type = LearnerType.PARTICIPANT;</span>
            } else {
<span class="nc" id="L215">               throw new ConfigException(&quot;Unrecognised peertype: &quot; + s);</span>
            }
<span class="nc" id="L217">        }</span>

        private static final String wrongFormat = &quot; does not have the form server_config or server_config;client_config&quot;+
        &quot; where server_config is host:port:port or host:port:port:type and client_config is port or host:port&quot;;

<span class="nc" id="L222">        public QuorumServer(long sid, String addressStr) throws ConfigException {</span>
            // LOG.warn(&quot;sid = &quot; + sid + &quot; addressStr = &quot; + addressStr);
<span class="nc" id="L224">            this.id = sid;</span>
<span class="nc" id="L225">            String serverClientParts[] = addressStr.split(&quot;;&quot;);</span>
<span class="nc" id="L226">            String serverParts[] = ConfigUtils.getHostAndPort(serverClientParts[0]);</span>
<span class="nc bnc" id="L227" title="All 6 branches missed.">            if ((serverClientParts.length &gt; 2) || (serverParts.length &lt; 3)</span>
                    || (serverParts.length &gt; 4)) {
<span class="nc" id="L229">                throw new ConfigException(addressStr + wrongFormat);</span>
            }

<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (serverClientParts.length == 2) {</span>
                //LOG.warn(&quot;ClientParts: &quot; + serverClientParts[1]);
<span class="nc" id="L234">                String clientParts[] = ConfigUtils.getHostAndPort(serverClientParts[1]);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                if (clientParts.length &gt; 2) {</span>
<span class="nc" id="L236">                    throw new ConfigException(addressStr + wrongFormat);</span>
                }

                // is client_config a host:port or just a port
<span class="nc bnc" id="L240" title="All 2 branches missed.">                hostname = (clientParts.length == 2) ? clientParts[0] : &quot;0.0.0.0&quot;;</span>
                try {
<span class="nc" id="L242">                    clientAddr = new InetSocketAddress(hostname,</span>
<span class="nc" id="L243">                            Integer.parseInt(clientParts[clientParts.length - 1]));</span>
                    //LOG.warn(&quot;Set clientAddr to &quot; + clientAddr);
<span class="nc" id="L245">                } catch (NumberFormatException e) {</span>
<span class="nc" id="L246">                    throw new ConfigException(&quot;Address unresolved: &quot; + hostname + &quot;:&quot; + clientParts[clientParts.length - 1]);</span>
<span class="nc" id="L247">                }</span>
            }

            // server_config should be either host:port:port or host:port:port:type
            try {
<span class="nc" id="L252">                addr = new InetSocketAddress(serverParts[0],</span>
<span class="nc" id="L253">                        Integer.parseInt(serverParts[1]));</span>
<span class="nc" id="L254">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L255">                throw new ConfigException(&quot;Address unresolved: &quot; + serverParts[0] + &quot;:&quot; + serverParts[1]);</span>
<span class="nc" id="L256">            }</span>
            try {
<span class="nc" id="L258">                electionAddr = new InetSocketAddress(serverParts[0],</span>
<span class="nc" id="L259">                        Integer.parseInt(serverParts[2]));</span>
<span class="nc" id="L260">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L261">                throw new ConfigException(&quot;Address unresolved: &quot; + serverParts[0] + &quot;:&quot; + serverParts[2]);</span>
<span class="nc" id="L262">            }</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">            if(addr.getPort() == electionAddr.getPort()) {</span>
<span class="nc" id="L265">                throw new ConfigException(</span>
                        &quot;Client and election port must be different! Please update the configuration file on server.&quot; + sid);
            }

<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (serverParts.length == 4) {</span>
<span class="nc" id="L270">                setType(serverParts[3]);</span>
            }

<span class="nc" id="L273">            this.hostname = serverParts[0];</span>
            
<span class="nc" id="L275">            setMyAddrs();</span>
<span class="nc" id="L276">        }</span>

        public QuorumServer(long id, InetSocketAddress addr,
                    InetSocketAddress electionAddr, LearnerType type) {
<span class="nc" id="L280">            this(id, addr, electionAddr, (InetSocketAddress)null, type);</span>
<span class="nc" id="L281">        }</span>

        public QuorumServer(long id, InetSocketAddress addr,
<span class="nc" id="L284">                InetSocketAddress electionAddr, InetSocketAddress clientAddr, LearnerType type) {</span>
<span class="nc" id="L285">            this.id = id;</span>
<span class="nc" id="L286">            this.addr = addr;</span>
<span class="nc" id="L287">            this.electionAddr = electionAddr;</span>
<span class="nc" id="L288">            this.type = type;</span>
<span class="nc" id="L289">            this.clientAddr = clientAddr;</span>

<span class="nc" id="L291">            setMyAddrs();</span>
<span class="nc" id="L292">        }</span>

        private void setMyAddrs() {
<span class="nc" id="L295">            this.myAddrs = new ArrayList&lt;InetSocketAddress&gt;();</span>
<span class="nc" id="L296">            this.myAddrs.add(this.addr);</span>
<span class="nc" id="L297">            this.myAddrs.add(this.clientAddr);</span>
<span class="nc" id="L298">            this.myAddrs.add(this.electionAddr);</span>
<span class="nc" id="L299">            this.myAddrs = excludedSpecialAddresses(this.myAddrs);</span>
<span class="nc" id="L300">        }</span>

        private static String delimitedHostString(InetSocketAddress addr)
        {
<span class="nc" id="L304">            String host = addr.getHostString();</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            if (host.contains(&quot;:&quot;)) {</span>
<span class="nc" id="L306">                return &quot;[&quot; + host + &quot;]&quot;;</span>
            } else {
<span class="nc" id="L308">                return host;</span>
            }
        }

        public String toString(){
<span class="nc" id="L313">            StringWriter sw = new StringWriter();</span>
            //addr should never be null, but just to make sure
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (addr !=null) {</span>
<span class="nc" id="L316">                sw.append(delimitedHostString(addr));</span>
<span class="nc" id="L317">                sw.append(&quot;:&quot;);</span>
<span class="nc" id="L318">                sw.append(String.valueOf(addr.getPort()));</span>
            }
<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (electionAddr!=null){</span>
<span class="nc" id="L321">                sw.append(&quot;:&quot;);</span>
<span class="nc" id="L322">                sw.append(String.valueOf(electionAddr.getPort()));</span>
            }           
<span class="nc bnc" id="L324" title="All 2 branches missed.">            if (type == LearnerType.OBSERVER) sw.append(&quot;:observer&quot;);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            else if (type == LearnerType.PARTICIPANT) sw.append(&quot;:participant&quot;);            </span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (clientAddr!=null){</span>
<span class="nc" id="L327">                sw.append(&quot;;&quot;);</span>
<span class="nc" id="L328">                sw.append(delimitedHostString(clientAddr));</span>
<span class="nc" id="L329">                sw.append(&quot;:&quot;);</span>
<span class="nc" id="L330">                sw.append(String.valueOf(clientAddr.getPort()));</span>
            }
<span class="nc" id="L332">            return sw.toString();       </span>
        }

        public int hashCode() {
<span class="nc bnc" id="L336" title="All 2 branches missed.">          assert false : &quot;hashCode not designed&quot;;</span>
<span class="nc" id="L337">          return 42; // any arbitrary constant will do </span>
        }
        
        private boolean checkAddressesEqual(InetSocketAddress addr1, InetSocketAddress addr2){
<span class="nc bnc" id="L341" title="All 12 branches missed.">            if ((addr1 == null &amp;&amp; addr2!=null) ||</span>
                (addr1!=null &amp;&amp; addr2==null) ||
<span class="nc bnc" id="L343" title="All 2 branches missed.">                (addr1!=null &amp;&amp; addr2!=null &amp;&amp; !addr1.equals(addr2))) return false;</span>
<span class="nc" id="L344">            return true;</span>
        }
        
        public boolean equals(Object o){
<span class="nc bnc" id="L348" title="All 2 branches missed.">            if (!(o instanceof QuorumServer)) return false;</span>
<span class="nc" id="L349">            QuorumServer qs = (QuorumServer)o;          </span>
<span class="nc bnc" id="L350" title="All 4 branches missed.">            if ((qs.id != id) || (qs.type != type)) return false;   </span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">            if (!checkAddressesEqual(addr, qs.addr)) return false;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            if (!checkAddressesEqual(electionAddr, qs.electionAddr)) return false;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (!checkAddressesEqual(clientAddr, qs.clientAddr)) return false;                    </span>
<span class="nc" id="L354">            return true;</span>
        }

        public void checkAddressDuplicate(QuorumServer s) throws BadArgumentsException {
<span class="nc" id="L358">            List&lt;InetSocketAddress&gt; otherAddrs = new ArrayList&lt;InetSocketAddress&gt;();</span>
<span class="nc" id="L359">            otherAddrs.add(s.addr);</span>
<span class="nc" id="L360">            otherAddrs.add(s.clientAddr);</span>
<span class="nc" id="L361">            otherAddrs.add(s.electionAddr);</span>
<span class="nc" id="L362">            otherAddrs = excludedSpecialAddresses(otherAddrs);</span>

<span class="nc bnc" id="L364" title="All 2 branches missed.">            for (InetSocketAddress my: this.myAddrs) {</span>

<span class="nc bnc" id="L366" title="All 2 branches missed.">                for (InetSocketAddress other: otherAddrs) {</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                    if (my.equals(other)) {</span>
<span class="nc" id="L368">                        String error = String.format(&quot;%s of server.%d conflicts %s of server.%d&quot;, my, this.id, other, s.id);</span>
<span class="nc" id="L369">                        throw new BadArgumentsException(error);</span>
                    }
<span class="nc" id="L371">                }</span>
<span class="nc" id="L372">            }</span>
<span class="nc" id="L373">        }</span>

        private List&lt;InetSocketAddress&gt; excludedSpecialAddresses(List&lt;InetSocketAddress&gt; addrs) {
<span class="nc" id="L376">            List&lt;InetSocketAddress&gt; included = new ArrayList&lt;InetSocketAddress&gt;();</span>
<span class="nc" id="L377">            InetAddress wcAddr = new InetSocketAddress(0).getAddress();</span>

<span class="nc bnc" id="L379" title="All 2 branches missed.">            for (InetSocketAddress addr : addrs) {</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">                if (addr == null) {</span>
<span class="nc" id="L381">                    continue;</span>
                }
<span class="nc" id="L383">                InetAddress inetaddr = addr.getAddress();</span>

<span class="nc bnc" id="L385" title="All 2 branches missed.">                if (inetaddr == null ||</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">                    inetaddr.equals(wcAddr) || // wildCard address(0.0.0.0)</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                    inetaddr.isLoopbackAddress()) { // loopback address(localhost/127.0.0.1)</span>
<span class="nc" id="L388">                    continue;</span>
                }
<span class="nc" id="L390">                included.add(addr);</span>
<span class="nc" id="L391">            }</span>
<span class="nc" id="L392">            return included;</span>
        }
    }


<span class="nc" id="L397">    public enum ServerState {</span>
<span class="nc" id="L398">        LOOKING, FOLLOWING, LEADING, OBSERVING;</span>
    }

    /*
     * A peer can either be participating, which implies that it is willing to
     * both vote in instances of consensus and to elect or become a Leader, or
     * it may be observing in which case it isn't.
     *
     * We need this distinction to decide which ServerState to move to when
     * conditions change (e.g. which state to become after LOOKING).
     */
<span class="nc" id="L409">    public enum LearnerType {</span>
<span class="nc" id="L410">        PARTICIPANT, OBSERVER;</span>
    }

    /*
     * To enable observers to have no identifier, we need a generic identifier
     * at least for QuorumCnxManager. We use the following constant to as the
     * value of such a generic identifier.
     */

    static final long OBSERVER_ID = Long.MAX_VALUE;

    /*
     * Record leader election time
     */
    public long start_fle, end_fle; // fle = fast leader election
    public static final String FLE_TIME_UNIT = &quot;MS&quot;;

    /*
     * Default value of peer is participant
     */
<span class="nc" id="L430">    private LearnerType learnerType = LearnerType.PARTICIPANT;</span>

    public LearnerType getLearnerType() {
<span class="nc" id="L433">        return learnerType;</span>
    }

    /**
     * Sets the LearnerType
     */
    public void setLearnerType(LearnerType p) {
<span class="nc" id="L440">        learnerType = p;</span>
<span class="nc" id="L441">    }</span>

    protected synchronized void setConfigFileName(String s) {
<span class="nc" id="L444">        configFilename = s;</span>
<span class="nc" id="L445">    }</span>

<span class="nc" id="L447">    private String configFilename = null;</span>

    public int getQuorumSize(){
<span class="nc" id="L450">        return getVotingView().size();</span>
    }

    /**
     * QuorumVerifier implementation; default (majority).
     */

    //last committed quorum verifier
    private QuorumVerifier quorumVerifier;
    
    //last proposed quorum verifier
<span class="nc" id="L461">    private QuorumVerifier lastSeenQuorumVerifier = null;</span>

    // Lock object that guard access to quorumVerifier and lastSeenQuorumVerifier.
<span class="nc" id="L464">    final Object QV_LOCK = new Object();</span>


    /**
     * My id
     */
    private long myid;


    /**
     * get the id of this quorum peer.
     */
    public long getId() {
<span class="nc" id="L477">        return myid;</span>
    }

    // VisibleForTesting
    void setId(long id) {
<span class="nc" id="L482">        this.myid = id;</span>
<span class="nc" id="L483">    }</span>

    private boolean sslQuorum;
    private boolean shouldUsePortUnification;

    public boolean isSslQuorum() {
<span class="nc" id="L489">        return sslQuorum;</span>
    }

    public boolean shouldUsePortUnification() {
<span class="nc" id="L493">        return shouldUsePortUnification;</span>
    }

    private final QuorumX509Util x509Util;

    QuorumX509Util getX509Util() {
<span class="nc" id="L499">        return x509Util;</span>
    }

    /**
     * This is who I think the leader currently is.
     */
    volatile private Vote currentVote;

    public synchronized Vote getCurrentVote(){
<span class="nc" id="L508">        return currentVote;</span>
    }

    public synchronized void setCurrentVote(Vote v){
<span class="nc" id="L512">        currentVote = v;</span>
<span class="nc" id="L513">    }</span>

<span class="nc" id="L515">    private volatile boolean running = true;</span>

    /**
     * The number of milliseconds of each tick
     */
    protected int tickTime;

    /**
     * Whether learners in this quorum should create new sessions as local.
     * False by default to preserve existing behavior.
     */
<span class="nc" id="L526">    protected boolean localSessionsEnabled = false;</span>

    /**
     * Whether learners in this quorum should upgrade local sessions to
     * global. Only matters if local sessions are enabled.
     */
<span class="nc" id="L532">    protected boolean localSessionsUpgradingEnabled = true;</span>

    /**
     * Minimum number of milliseconds to allow for session timeout.
     * A value of -1 indicates unset, use default.
     */
<span class="nc" id="L538">    protected int minSessionTimeout = -1;</span>

    /**
     * Maximum number of milliseconds to allow for session timeout.
     * A value of -1 indicates unset, use default.
     */
<span class="nc" id="L544">    protected int maxSessionTimeout = -1;</span>

    /**
     * The number of ticks that the initial synchronization phase can take
     */
    protected int initLimit;

    /**
     * The number of ticks that can pass between sending a request and getting
     * an acknowledgment
     */
    protected int syncLimit;
    
    /**
     * Enables/Disables sync request processor. This option is enabled
     * by default and is to be used with observers.
     */
<span class="nc" id="L561">    protected boolean syncEnabled = true;</span>

    /**
     * The current tick
     */
<span class="nc" id="L566">    protected AtomicInteger tick = new AtomicInteger();</span>

    /**
     * Whether or not to listen on all IPs for the two quorum ports
     * (broadcast and fast leader election).
     */
<span class="nc" id="L572">    protected boolean quorumListenOnAllIPs = false;</span>

    /**
     * Keeps time taken for leader election in milliseconds. Sets the value to
     * this variable only after the completion of leader election.
     */
<span class="nc" id="L578">    private long electionTimeTaken = -1;</span>

    /**
     * Enable/Disables quorum authentication using sasl. Defaulting to false.
     */
    protected boolean quorumSaslEnableAuth;

    /**
     * If this is false, quorum peer server will accept another quorum peer client
     * connection even if the authentication did not succeed. This can be used while
     * upgrading ZooKeeper server. Defaulting to false (required).
     */
    protected boolean quorumServerSaslAuthRequired;

    /**
     * If this is false, quorum peer learner will talk to quorum peer server
     * without authentication. This can be used while upgrading ZooKeeper
     * server. Defaulting to false (required).
     */
    protected boolean quorumLearnerSaslAuthRequired;

    /**
     * Kerberos quorum service principal. Defaulting to 'zkquorum/localhost'.
     */
    protected String quorumServicePrincipal;

    /**
     * Quorum learner login context name in jaas-conf file to read the kerberos
     * security details. Defaulting to 'QuorumLearner'.
     */
    protected String quorumLearnerLoginContext;

    /**
     * Quorum server login context name in jaas-conf file to read the kerberos
     * security details. Defaulting to 'QuorumServer'.
     */
    protected String quorumServerLoginContext;

    // TODO: need to tune the default value of thread size
    private static final int QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE = 20;
    /**
     * The maximum number of threads to allow in the connectionExecutors thread
     * pool which will be used to initiate quorum server connections.
     */
<span class="nc" id="L622">    protected int quorumCnxnThreadsSize = QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE;</span>

    /**
     * @deprecated As of release 3.4.0, this class has been deprecated, since
     * it is used with one of the udp-based versions of leader election, which
     * we are also deprecating.
     *
     * This class simply responds to requests for the current leader of this
     * node.
     * &lt;p&gt;
     * The request contains just an xid generated by the requestor.
     * &lt;p&gt;
     * The response has the xid, the id of this server, the id of the leader,
     * and the zxid of the leader.
     *
     *
     */
    @Deprecated
    class ResponderThread extends ZooKeeperThread {
<span class="nc" id="L641">        ResponderThread() {</span>
<span class="nc" id="L642">            super(&quot;ResponderThread&quot;);</span>
<span class="nc" id="L643">        }</span>

<span class="nc" id="L645">        volatile boolean running = true;</span>

        @Override
        public void run() {
            try {
<span class="nc" id="L650">                byte b[] = new byte[36];</span>
<span class="nc" id="L651">                ByteBuffer responseBuffer = ByteBuffer.wrap(b);</span>
<span class="nc" id="L652">                DatagramPacket packet = new DatagramPacket(b, b.length);</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                while (running) {</span>
<span class="nc" id="L654">                    udpSocket.receive(packet);</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">                    if (packet.getLength() != 4) {</span>
<span class="nc" id="L656">                        LOG.warn(&quot;Got more than just an xid! Len = &quot;</span>
<span class="nc" id="L657">                                + packet.getLength());</span>
                    } else {
<span class="nc" id="L659">                        responseBuffer.clear();</span>
<span class="nc" id="L660">                        responseBuffer.getInt(); // Skip the xid</span>
<span class="nc" id="L661">                        responseBuffer.putLong(myid);</span>
<span class="nc" id="L662">                        Vote current = getCurrentVote();</span>
<span class="nc bnc" id="L663" title="All 4 branches missed.">                        switch (getPeerState()) {</span>
                        case LOOKING:
<span class="nc" id="L665">                            responseBuffer.putLong(current.getId());</span>
<span class="nc" id="L666">                            responseBuffer.putLong(current.getZxid());</span>
<span class="nc" id="L667">                            break;</span>
                        case LEADING:
<span class="nc" id="L669">                            responseBuffer.putLong(myid);</span>
                            try {
                                long proposed;
<span class="nc" id="L672">                                synchronized(leader) {</span>
<span class="nc" id="L673">                                    proposed = leader.lastProposed;</span>
<span class="nc" id="L674">                                }</span>
<span class="nc" id="L675">                                responseBuffer.putLong(proposed);</span>
<span class="nc" id="L676">                            } catch (NullPointerException npe) {</span>
                                // This can happen in state transitions,
                                // just ignore the request
<span class="nc" id="L679">                            }</span>
<span class="nc" id="L680">                            break;</span>
                        case FOLLOWING:
<span class="nc" id="L682">                            responseBuffer.putLong(current.getId());</span>
                            try {
<span class="nc" id="L684">                                responseBuffer.putLong(follower.getZxid());</span>
<span class="nc" id="L685">                            } catch (NullPointerException npe) {</span>
                                // This can happen in state transitions,
                                // just ignore the request
<span class="nc" id="L688">                            }</span>
<span class="nc" id="L689">                            break;</span>
                        case OBSERVING:
                            // Do nothing, Observers keep themselves to
                            // themselves.
                            break;
                        }
<span class="nc" id="L695">                        packet.setData(b);</span>
<span class="nc" id="L696">                        udpSocket.send(packet);</span>
                    }
<span class="nc" id="L698">                    packet.setLength(b.length);</span>
                }
<span class="nc" id="L700">            } catch (RuntimeException e) {</span>
<span class="nc" id="L701">                LOG.warn(&quot;Unexpected runtime exception in ResponderThread&quot;,e);</span>
<span class="nc" id="L702">            } catch (IOException e) {</span>
<span class="nc" id="L703">                LOG.warn(&quot;Unexpected IO exception in ResponderThread&quot;,e);</span>
            } finally {
<span class="nc" id="L705">                LOG.warn(&quot;QuorumPeer responder thread exited&quot;);</span>
            }
<span class="nc" id="L707">        }</span>
    }

<span class="nc" id="L710">    private ServerState state = ServerState.LOOKING;</span>
    
<span class="nc" id="L712">    private boolean reconfigFlag = false; // indicates that a reconfig just committed</span>

    public synchronized void setPeerState(ServerState newState){
<span class="nc" id="L715">        state=newState;</span>
<span class="nc" id="L716">    }</span>
    public synchronized void reconfigFlagSet(){
<span class="nc" id="L718">       reconfigFlag = true;</span>
<span class="nc" id="L719">    }</span>
    public synchronized void reconfigFlagClear(){
<span class="nc" id="L721">       reconfigFlag = false;</span>
<span class="nc" id="L722">    }</span>
    public synchronized boolean isReconfigStateChange(){
<span class="nc" id="L724">       return reconfigFlag;</span>
    }
    public synchronized ServerState getPeerState(){
<span class="nc" id="L727">        return state;</span>
    }

    DatagramSocket udpSocket;

<span class="nc" id="L732">    private final AtomicReference&lt;AddressTuple&gt; myAddrs = new AtomicReference&lt;&gt;();</span>

    /**
     * Resolves hostname for a given server ID.
     *
     * This method resolves hostname for a given server ID in both quorumVerifer
     * and lastSeenQuorumVerifier. If the server ID matches the local server ID,
     * it also updates myAddrs.
     */
    public void recreateSocketAddresses(long id) {
<span class="nc" id="L742">        QuorumVerifier qv = getQuorumVerifier();</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (qv != null) {</span>
<span class="nc" id="L744">            QuorumServer qs = qv.getAllMembers().get(id);</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">            if (qs != null) {</span>
<span class="nc" id="L746">                qs.recreateSocketAddresses();</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">                if (id == getId()) {</span>
<span class="nc" id="L748">                    setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);</span>
                }
            }
        }
<span class="nc" id="L752">        qv = getLastSeenQuorumVerifier();</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (qv != null) {</span>
<span class="nc" id="L754">            QuorumServer qs = qv.getAllMembers().get(id);</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">            if (qs != null) {</span>
<span class="nc" id="L756">                qs.recreateSocketAddresses();</span>
            }
        }
<span class="nc" id="L759">    }</span>

    private AddressTuple getAddrs(){
<span class="nc" id="L762">        AddressTuple addrs = myAddrs.get();</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">        if (addrs != null) {</span>
<span class="nc" id="L764">            return addrs;</span>
        }
        try {
<span class="nc" id="L767">            synchronized (QV_LOCK) {</span>
<span class="nc" id="L768">                addrs = myAddrs.get();</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                while (addrs == null) {</span>
<span class="nc" id="L770">                    QV_LOCK.wait();</span>
<span class="nc" id="L771">                    addrs = myAddrs.get();</span>
                }
<span class="nc" id="L773">                return addrs;</span>
            }
<span class="nc" id="L775">        } catch (InterruptedException e) {</span>
<span class="nc" id="L776">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L777">            throw new RuntimeException(e);</span>
        }
    }

    public InetSocketAddress getQuorumAddress(){
<span class="nc" id="L782">        return getAddrs().quorumAddr;</span>
    }
    
    public InetSocketAddress getElectionAddress(){
<span class="nc" id="L786">        return getAddrs().electionAddr;</span>
    }

    public InetSocketAddress getClientAddress(){
<span class="nc" id="L790">        final AddressTuple addrs = myAddrs.get();</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">        return (addrs == null) ? null : addrs.clientAddr;</span>
    }
    
    private void setAddrs(InetSocketAddress quorumAddr, InetSocketAddress electionAddr, InetSocketAddress clientAddr){
<span class="nc" id="L795">        synchronized (QV_LOCK) {</span>
<span class="nc" id="L796">            myAddrs.set(new AddressTuple(quorumAddr, electionAddr, clientAddr));</span>
<span class="nc" id="L797">            QV_LOCK.notifyAll();</span>
<span class="nc" id="L798">        }</span>
<span class="nc" id="L799">    }</span>
    
    private int electionType;

    Election electionAlg;

    ServerCnxnFactory cnxnFactory;
    ServerCnxnFactory secureCnxnFactory;

<span class="nc" id="L808">    private FileTxnSnapLog logFactory = null;</span>

    private final QuorumStats quorumStats;

    AdminServer adminServer;

    public static QuorumPeer testingQuorumPeer() throws SaslException {
<span class="nc" id="L815">        return new QuorumPeer();</span>
    }

    public QuorumPeer() throws SaslException {
<span class="nc" id="L819">        super(&quot;QuorumPeer&quot;);</span>
<span class="nc" id="L820">        quorumStats = new QuorumStats(this);</span>
<span class="nc" id="L821">        jmxRemotePeerBean = new HashMap&lt;Long, RemotePeerBean&gt;();</span>
<span class="nc" id="L822">        adminServer = AdminServerFactory.createAdminServer();</span>
<span class="nc" id="L823">        x509Util = new QuorumX509Util();</span>
<span class="nc" id="L824">        initialize();</span>
<span class="nc" id="L825">    }</span>

    /**
     * For backward compatibility purposes, we instantiate QuorumMaj by default.
     */

    public QuorumPeer(Map&lt;Long, QuorumServer&gt; quorumPeers, File dataDir,
            File dataLogDir, int electionType,
            long myid, int tickTime, int initLimit, int syncLimit,
            ServerCnxnFactory cnxnFactory) throws IOException {
<span class="nc" id="L835">        this(quorumPeers, dataDir, dataLogDir, electionType, myid, tickTime,</span>
                initLimit, syncLimit, false, cnxnFactory,
                new QuorumMaj(quorumPeers));
<span class="nc" id="L838">    }</span>

    public QuorumPeer(Map&lt;Long, QuorumServer&gt; quorumPeers, File dataDir,
            File dataLogDir, int electionType,
            long myid, int tickTime, int initLimit, int syncLimit,
            boolean quorumListenOnAllIPs,
            ServerCnxnFactory cnxnFactory,
            QuorumVerifier quorumConfig) throws IOException {
<span class="nc" id="L846">        this();</span>
<span class="nc" id="L847">        this.cnxnFactory = cnxnFactory;</span>
<span class="nc" id="L848">        this.electionType = electionType;</span>
<span class="nc" id="L849">        this.myid = myid;</span>
<span class="nc" id="L850">        this.tickTime = tickTime;</span>
<span class="nc" id="L851">        this.initLimit = initLimit;</span>
<span class="nc" id="L852">        this.syncLimit = syncLimit;</span>
<span class="nc" id="L853">        this.quorumListenOnAllIPs = quorumListenOnAllIPs;</span>
<span class="nc" id="L854">        this.logFactory = new FileTxnSnapLog(dataLogDir, dataDir);</span>
<span class="nc" id="L855">        this.zkDb = new ZKDatabase(this.logFactory);</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">        if(quorumConfig == null) quorumConfig = new QuorumMaj(quorumPeers);</span>
<span class="nc" id="L857">        setQuorumVerifier(quorumConfig, false);</span>
<span class="nc" id="L858">        adminServer = AdminServerFactory.createAdminServer();</span>
<span class="nc" id="L859">    }</span>

    public void initialize() throws SaslException {
        // init quorum auth server &amp; learner
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (isQuorumSaslAuthEnabled()) {</span>
<span class="nc" id="L864">            Set&lt;String&gt; authzHosts = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">            for (QuorumServer qs : getView().values()) {</span>
<span class="nc" id="L866">                authzHosts.add(qs.hostname);</span>
<span class="nc" id="L867">            }</span>
<span class="nc" id="L868">            authServer = new SaslQuorumAuthServer(isQuorumServerSaslAuthRequired(),</span>
                    quorumServerLoginContext, authzHosts);
<span class="nc" id="L870">            authLearner = new SaslQuorumAuthLearner(isQuorumLearnerSaslAuthRequired(),</span>
                    quorumServicePrincipal, quorumLearnerLoginContext);
<span class="nc" id="L872">        } else {</span>
<span class="nc" id="L873">            authServer = new NullQuorumAuthServer();</span>
<span class="nc" id="L874">            authLearner = new NullQuorumAuthLearner();</span>
        }
<span class="nc" id="L876">    }</span>

    QuorumStats quorumStats() {
<span class="nc" id="L879">        return quorumStats;</span>
    }

    @Override
    public synchronized void start() {
<span class="nc bnc" id="L884" title="All 2 branches missed.">        if (!getView().containsKey(myid)) {</span>
<span class="nc" id="L885">            throw new RuntimeException(&quot;My id &quot; + myid + &quot; not in the peer list&quot;);</span>
         }
<span class="nc" id="L887">        loadDataBase();</span>
<span class="nc" id="L888">        startServerCnxnFactory();</span>
        try {
<span class="nc" id="L890">            adminServer.start();</span>
<span class="nc" id="L891">        } catch (AdminServerException e) {</span>
<span class="nc" id="L892">            LOG.warn(&quot;Problem starting AdminServer&quot;, e);</span>
<span class="nc" id="L893">            System.out.println(e);</span>
<span class="nc" id="L894">        }</span>
<span class="nc" id="L895">        startLeaderElection();</span>
<span class="nc" id="L896">        super.start();</span>
<span class="nc" id="L897">    }</span>

    private void loadDataBase() {
        try {
<span class="nc" id="L901">            zkDb.loadDataBase();</span>

            // load the epochs
<span class="nc" id="L904">            long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;</span>
<span class="nc" id="L905">            long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);</span>
            try {
<span class="nc" id="L907">                currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);</span>
<span class="nc" id="L908">            } catch(FileNotFoundException e) {</span>
            	// pick a reasonable epoch number
            	// this should only happen once when moving to a
            	// new code version
<span class="nc" id="L912">            	currentEpoch = epochOfZxid;</span>
<span class="nc" id="L913">            	LOG.info(CURRENT_EPOCH_FILENAME</span>
            	        + &quot; not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation&quot;,
<span class="nc" id="L915">            	        currentEpoch);</span>
<span class="nc" id="L916">            	writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);</span>
<span class="nc" id="L917">            }</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">            if (epochOfZxid &gt; currentEpoch) {</span>
<span class="nc" id="L919">                throw new IOException(&quot;The current epoch, &quot; + ZxidUtils.zxidToString(currentEpoch) + &quot;, is older than the last zxid, &quot; + lastProcessedZxid);</span>
            }
            try {
<span class="nc" id="L922">                acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);</span>
<span class="nc" id="L923">            } catch(FileNotFoundException e) {</span>
            	// pick a reasonable epoch number
            	// this should only happen once when moving to a
            	// new code version
<span class="nc" id="L927">            	acceptedEpoch = epochOfZxid;</span>
<span class="nc" id="L928">            	LOG.info(ACCEPTED_EPOCH_FILENAME</span>
            	        + &quot; not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation&quot;,
<span class="nc" id="L930">            	        acceptedEpoch);</span>
<span class="nc" id="L931">            	writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);</span>
<span class="nc" id="L932">            }</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">            if (acceptedEpoch &lt; currentEpoch) {</span>
<span class="nc" id="L934">                throw new IOException(&quot;The accepted epoch, &quot; + ZxidUtils.zxidToString(acceptedEpoch) + &quot; is less than the current epoch, &quot; + ZxidUtils.zxidToString(currentEpoch));</span>
            }
<span class="nc" id="L936">        } catch(IOException ie) {</span>
<span class="nc" id="L937">            LOG.error(&quot;Unable to load database on disk&quot;, ie);</span>
<span class="nc" id="L938">            throw new RuntimeException(&quot;Unable to run quorum server &quot;, ie);</span>
<span class="nc" id="L939">        }</span>
<span class="nc" id="L940">    }</span>

    ResponderThread responder;

    synchronized public void stopLeaderElection() {
<span class="nc" id="L945">        responder.running = false;</span>
<span class="nc" id="L946">        responder.interrupt();</span>
<span class="nc" id="L947">    }</span>
    synchronized public void startLeaderElection() {
       try {
<span class="nc bnc" id="L950" title="All 2 branches missed.">           if (getPeerState() == ServerState.LOOKING) {</span>
<span class="nc" id="L951">               currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span>
           }
<span class="nc" id="L953">       } catch(IOException e) {</span>
<span class="nc" id="L954">           RuntimeException re = new RuntimeException(e.getMessage());</span>
<span class="nc" id="L955">           re.setStackTrace(e.getStackTrace());</span>
<span class="nc" id="L956">           throw re;</span>
<span class="nc" id="L957">       }</span>

       // if (!getView().containsKey(myid)) {
      //      throw new RuntimeException(&quot;My id &quot; + myid + &quot; not in the peer list&quot;);
        //}
<span class="nc bnc" id="L962" title="All 2 branches missed.">        if (electionType == 0) {</span>
            try {
<span class="nc" id="L964">                udpSocket = new DatagramSocket(getQuorumAddress().getPort());</span>
<span class="nc" id="L965">                responder = new ResponderThread();</span>
<span class="nc" id="L966">                responder.start();</span>
<span class="nc" id="L967">            } catch (SocketException e) {</span>
<span class="nc" id="L968">                throw new RuntimeException(e);</span>
<span class="nc" id="L969">            }</span>
        }
<span class="nc" id="L971">        this.electionAlg = createElectionAlgorithm(electionType);</span>
<span class="nc" id="L972">    }</span>

    /**
     * Count the number of nodes in the map that could be followers.
     * @param peers
     * @return The number of followers in the map
     */
    protected static int countParticipants(Map&lt;Long,QuorumServer&gt; peers) {
<span class="nc" id="L980">      int count = 0;</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">      for (QuorumServer q : peers.values()) {</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">          if (q.type == LearnerType.PARTICIPANT) {</span>
<span class="nc" id="L983">              count++;</span>
          }
<span class="nc" id="L985">      }</span>
<span class="nc" id="L986">      return count;</span>
    }

    /**

     * This constructor is only used by the existing unit test code.
     * It defaults to FileLogProvider persistence provider.
     */
    public QuorumPeer(Map&lt;Long,QuorumServer&gt; quorumPeers, File snapDir,
            File logDir, int clientPort, int electionAlg,
            long myid, int tickTime, int initLimit, int syncLimit)
        throws IOException
    {
<span class="nc" id="L999">        this(quorumPeers, snapDir, logDir, electionAlg, myid, tickTime, initLimit, syncLimit, false,</span>
<span class="nc" id="L1000">                ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),</span>
                new QuorumMaj(quorumPeers));
<span class="nc" id="L1002">    }</span>

    /**
     * This constructor is only used by the existing unit test code.
     * It defaults to FileLogProvider persistence provider.
     */
    public QuorumPeer(Map&lt;Long,QuorumServer&gt; quorumPeers, File snapDir,
            File logDir, int clientPort, int electionAlg,
            long myid, int tickTime, int initLimit, int syncLimit,
            QuorumVerifier quorumConfig)
        throws IOException
    {
<span class="nc" id="L1014">        this(quorumPeers, snapDir, logDir, electionAlg,</span>
                myid,tickTime, initLimit,syncLimit, false,
<span class="nc" id="L1016">                ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),</span>
                quorumConfig);
<span class="nc" id="L1018">    }</span>

    private static InetSocketAddress getClientAddress(Map&lt;Long, QuorumServer&gt; quorumPeers, long myid, int clientPort)
            throws IOException {
<span class="nc" id="L1022">        QuorumServer quorumServer = quorumPeers.get(myid);</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">        if (null == quorumServer) {</span>
<span class="nc" id="L1024">            throw new IOException(&quot;No QuorumServer correspoding to myid &quot; + myid);</span>
        }
<span class="nc bnc" id="L1026" title="All 2 branches missed.">        if (null == quorumServer.clientAddr) {</span>
<span class="nc" id="L1027">            return new InetSocketAddress(clientPort);</span>
        }
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if (quorumServer.clientAddr.getPort() != clientPort) {</span>
<span class="nc" id="L1030">            throw new IOException(&quot;QuorumServer port &quot; + quorumServer.clientAddr.getPort()</span>
                    + &quot; does not match with given port &quot; + clientPort);
        }
<span class="nc" id="L1033">        return quorumServer.clientAddr;</span>
    }

    /**
     * returns the highest zxid that this host has seen
     *
     * @return the highest zxid for this host
     */
    public long getLastLoggedZxid() {
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        if (!zkDb.isInitialized()) {</span>
<span class="nc" id="L1043">            loadDataBase();</span>
        }
<span class="nc" id="L1045">        return zkDb.getDataTreeLastProcessedZxid();</span>
    }

    public Follower follower;
    public Leader leader;
    public Observer observer;

    protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {
<span class="nc" id="L1053">        return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.zkDb));</span>
    }

    protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception {
<span class="nc" id="L1057">        return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.zkDb));</span>
    }

    protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException {
<span class="nc" id="L1061">        return new Observer(this, new ObserverZooKeeperServer(logFactory, this, this.zkDb));</span>
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    protected Election createElectionAlgorithm(int electionAlgorithm){
<span class="nc" id="L1066">        Election le=null;</span>

        //TODO: use a factory rather than a switch
<span class="nc bnc" id="L1069" title="All 5 branches missed.">        switch (electionAlgorithm) {</span>
        case 0:
<span class="nc" id="L1071">            le = new LeaderElection(this);</span>
<span class="nc" id="L1072">            break;</span>
        case 1:
<span class="nc" id="L1074">            le = new AuthFastLeaderElection(this);</span>
<span class="nc" id="L1075">            break;</span>
        case 2:
<span class="nc" id="L1077">            le = new AuthFastLeaderElection(this, true);</span>
<span class="nc" id="L1078">            break;</span>
        case 3:
<span class="nc" id="L1080">            QuorumCnxManager qcm = createCnxnManager();</span>
<span class="nc" id="L1081">            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">            if (oldQcm != null) {</span>
<span class="nc" id="L1083">                LOG.warn(&quot;Clobbering already-set QuorumCnxManager (restarting leader election?)&quot;);</span>
<span class="nc" id="L1084">                oldQcm.halt();</span>
            }
<span class="nc" id="L1086">            QuorumCnxManager.Listener listener = qcm.listener;</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">            if(listener != null){</span>
<span class="nc" id="L1088">                listener.start();</span>
<span class="nc" id="L1089">                FastLeaderElection fle = new FastLeaderElection(this, qcm);</span>
<span class="nc" id="L1090">                fle.start();</span>
<span class="nc" id="L1091">                le = fle;</span>
<span class="nc" id="L1092">            } else {</span>
<span class="nc" id="L1093">                LOG.error(&quot;Null listener when initializing cnx manager&quot;);</span>
            }
<span class="nc" id="L1095">            break;</span>
        default:
<span class="nc bnc" id="L1097" title="All 2 branches missed.">            assert false;</span>
        }
<span class="nc" id="L1099">        return le;</span>
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    protected Election makeLEStrategy(){
<span class="nc" id="L1104">        LOG.debug(&quot;Initializing leader election protocol...&quot;);</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        if (getElectionType() == 0) {</span>
<span class="nc" id="L1106">            electionAlg = new LeaderElection(this);</span>
        }
<span class="nc" id="L1108">        return electionAlg;</span>
    }

    synchronized protected void setLeader(Leader newLeader){
<span class="nc" id="L1112">        leader=newLeader;</span>
<span class="nc" id="L1113">    }</span>

    synchronized protected void setFollower(Follower newFollower){
<span class="nc" id="L1116">        follower=newFollower;</span>
<span class="nc" id="L1117">    }</span>

    synchronized protected void setObserver(Observer newObserver){
<span class="nc" id="L1120">        observer=newObserver;</span>
<span class="nc" id="L1121">    }</span>

    synchronized public ZooKeeperServer getActiveServer(){
<span class="nc bnc" id="L1124" title="All 2 branches missed.">        if(leader!=null)</span>
<span class="nc" id="L1125">            return leader.zk;</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        else if(follower!=null)</span>
<span class="nc" id="L1127">            return follower.zk;</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">        else if (observer != null)</span>
<span class="nc" id="L1129">            return observer.zk;</span>
<span class="nc" id="L1130">        return null;</span>
    }

<span class="nc" id="L1133">    boolean shuttingDownLE = false;</span>
    
    @Override
    public void run() {
<span class="nc" id="L1137">        updateThreadName();</span>

<span class="nc" id="L1139">        LOG.debug(&quot;Starting quorum peer&quot;);</span>
        try {
<span class="nc" id="L1141">            jmxQuorumBean = new QuorumBean(this);</span>
<span class="nc" id="L1142">            MBeanRegistry.getInstance().register(jmxQuorumBean, null);</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">            for(QuorumServer s: getView().values()){</span>
                ZKMBeanInfo p;
<span class="nc bnc" id="L1145" title="All 2 branches missed.">                if (getId() == s.id) {</span>
<span class="nc" id="L1146">                    p = jmxLocalPeerBean = new LocalPeerBean(this);</span>
                    try {
<span class="nc" id="L1148">                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);</span>
<span class="nc" id="L1149">                    } catch (Exception e) {</span>
<span class="nc" id="L1150">                        LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="nc" id="L1151">                        jmxLocalPeerBean = null;</span>
<span class="nc" id="L1152">                    }</span>
                } else {
<span class="nc" id="L1154">                    RemotePeerBean rBean = new RemotePeerBean(this, s);</span>
                    try {
<span class="nc" id="L1156">                        MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);</span>
<span class="nc" id="L1157">                        jmxRemotePeerBean.put(s.id, rBean);</span>
<span class="nc" id="L1158">                    } catch (Exception e) {</span>
<span class="nc" id="L1159">                        LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="nc" id="L1160">                    }</span>
                }
<span class="nc" id="L1162">            }</span>
<span class="nc" id="L1163">        } catch (Exception e) {</span>
<span class="nc" id="L1164">            LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="nc" id="L1165">            jmxQuorumBean = null;</span>
<span class="nc" id="L1166">        }</span>

        try {
            /*
             * Main loop
             */
<span class="nc bnc" id="L1172" title="All 2 branches missed.">            while (running) {</span>
<span class="nc bnc" id="L1173" title="All 5 branches missed.">                switch (getPeerState()) {</span>
                case LOOKING:
<span class="nc" id="L1175">                    LOG.info(&quot;LOOKING&quot;);</span>

<span class="nc bnc" id="L1177" title="All 2 branches missed.">                    if (Boolean.getBoolean(&quot;readonlymode.enabled&quot;)) {</span>
<span class="nc" id="L1178">                        LOG.info(&quot;Attempting to start ReadOnlyZooKeeperServer&quot;);</span>

                        // Create read-only server but don't start it immediately
<span class="nc" id="L1181">                        final ReadOnlyZooKeeperServer roZk =</span>
                            new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);
    
                        // Instead of starting roZk immediately, wait some grace
                        // period before we decide we're partitioned.
                        //
                        // Thread is used here because otherwise it would require
                        // changes in each of election strategy classes which is
                        // unnecessary code coupling.
<span class="nc" id="L1190">                        Thread roZkMgr = new Thread() {</span>
                            public void run() {
                                try {
                                    // lower-bound grace period to 2 secs
<span class="nc" id="L1194">                                    sleep(Math.max(2000, tickTime));</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">                                    if (ServerState.LOOKING.equals(getPeerState())) {</span>
<span class="nc" id="L1196">                                        roZk.startup();</span>
                                    }
<span class="nc" id="L1198">                                } catch (InterruptedException e) {</span>
<span class="nc" id="L1199">                                    LOG.info(&quot;Interrupted while attempting to start ReadOnlyZooKeeperServer, not started&quot;);</span>
<span class="nc" id="L1200">                                } catch (Exception e) {</span>
<span class="nc" id="L1201">                                    LOG.error(&quot;FAILED to start ReadOnlyZooKeeperServer&quot;, e);</span>
<span class="nc" id="L1202">                                }</span>
<span class="nc" id="L1203">                            }</span>
                        };
                        try {
<span class="nc" id="L1206">                            roZkMgr.start();</span>
<span class="nc" id="L1207">                            reconfigFlagClear();</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                            if (shuttingDownLE) {</span>
<span class="nc" id="L1209">                                shuttingDownLE = false;</span>
<span class="nc" id="L1210">                                startLeaderElection();</span>
                            }
<span class="nc" id="L1212">                            setCurrentVote(makeLEStrategy().lookForLeader());</span>
<span class="nc" id="L1213">                        } catch (Exception e) {</span>
<span class="nc" id="L1214">                            LOG.warn(&quot;Unexpected exception&quot;, e);</span>
<span class="nc" id="L1215">                            setPeerState(ServerState.LOOKING);</span>
                        } finally {
                            // If the thread is in the the grace period, interrupt
                            // to come out of waiting.
<span class="nc" id="L1219">                            roZkMgr.interrupt();</span>
<span class="nc" id="L1220">                            roZk.shutdown();</span>
                        }
<span class="nc" id="L1222">                    } else {</span>
                        try {
<span class="nc" id="L1224">                           reconfigFlagClear();</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">                            if (shuttingDownLE) {</span>
<span class="nc" id="L1226">                               shuttingDownLE = false;</span>
<span class="nc" id="L1227">                               startLeaderElection();</span>
                               }
<span class="nc" id="L1229">                            setCurrentVote(makeLEStrategy().lookForLeader());</span>
<span class="nc" id="L1230">                        } catch (Exception e) {</span>
<span class="nc" id="L1231">                            LOG.warn(&quot;Unexpected exception&quot;, e);</span>
<span class="nc" id="L1232">                            setPeerState(ServerState.LOOKING);</span>
<span class="nc" id="L1233">                        }                        </span>
                    }
<span class="nc" id="L1235">                    break;</span>
                case OBSERVING:
                    try {
<span class="nc" id="L1238">                        LOG.info(&quot;OBSERVING&quot;);</span>
<span class="nc" id="L1239">                        setObserver(makeObserver(logFactory));</span>
<span class="nc" id="L1240">                        observer.observeLeader();</span>
<span class="nc" id="L1241">                    } catch (Exception e) {</span>
<span class="nc" id="L1242">                        LOG.warn(&quot;Unexpected exception&quot;,e );</span>
                    } finally {
<span class="nc" id="L1244">                        observer.shutdown();</span>
<span class="nc" id="L1245">                        setObserver(null);  </span>
<span class="nc" id="L1246">                       updateServerState();</span>
                    }
<span class="nc" id="L1248">                    break;</span>
                case FOLLOWING:
                    try {
<span class="nc" id="L1251">                       LOG.info(&quot;FOLLOWING&quot;);</span>
<span class="nc" id="L1252">                        setFollower(makeFollower(logFactory));</span>
<span class="nc" id="L1253">                        follower.followLeader();</span>
<span class="nc" id="L1254">                    } catch (Exception e) {</span>
<span class="nc" id="L1255">                       LOG.warn(&quot;Unexpected exception&quot;,e);</span>
                    } finally {
<span class="nc" id="L1257">                       follower.shutdown();</span>
<span class="nc" id="L1258">                       setFollower(null);</span>
<span class="nc" id="L1259">                       updateServerState();</span>
                    }
<span class="nc" id="L1261">                    break;</span>
                case LEADING:
<span class="nc" id="L1263">                    LOG.info(&quot;LEADING&quot;);</span>
                    try {
<span class="nc" id="L1265">                        setLeader(makeLeader(logFactory));</span>
<span class="nc" id="L1266">                        leader.lead();</span>
<span class="nc" id="L1267">                        setLeader(null);</span>
<span class="nc" id="L1268">                    } catch (Exception e) {</span>
<span class="nc" id="L1269">                        LOG.warn(&quot;Unexpected exception&quot;,e);</span>
                    } finally {
<span class="nc bnc" id="L1271" title="All 2 branches missed.">                        if (leader != null) {</span>
<span class="nc" id="L1272">                            leader.shutdown(&quot;Forcing shutdown&quot;);</span>
<span class="nc" id="L1273">                            setLeader(null);</span>
                        }
<span class="nc" id="L1275">                        updateServerState();</span>
                    }
                    break;
                }
<span class="nc" id="L1279">                start_fle = Time.currentElapsedTime();</span>
            }
        } finally {
<span class="nc" id="L1282">            LOG.warn(&quot;QuorumPeer main thread exited&quot;);</span>
<span class="nc" id="L1283">            MBeanRegistry instance = MBeanRegistry.getInstance();</span>
<span class="nc" id="L1284">            instance.unregister(jmxQuorumBean);</span>
<span class="nc" id="L1285">            instance.unregister(jmxLocalPeerBean);</span>

<span class="nc bnc" id="L1287" title="All 2 branches missed.">            for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {</span>
<span class="nc" id="L1288">                instance.unregister(remotePeerBean);</span>
<span class="nc" id="L1289">            }</span>

<span class="nc" id="L1291">            jmxQuorumBean = null;</span>
<span class="nc" id="L1292">            jmxLocalPeerBean = null;</span>
<span class="nc" id="L1293">            jmxRemotePeerBean = null;</span>
        }
<span class="nc" id="L1295">    }</span>

    private synchronized void updateServerState(){
<span class="nc bnc" id="L1298" title="All 2 branches missed.">       if (!reconfigFlag) {</span>
<span class="nc" id="L1299">           setPeerState(ServerState.LOOKING);</span>
<span class="nc" id="L1300">           LOG.warn(&quot;PeerState set to LOOKING&quot;);</span>
<span class="nc" id="L1301">           return;</span>
       }
       
<span class="nc bnc" id="L1304" title="All 2 branches missed.">       if (getId() == getCurrentVote().getId()) {</span>
<span class="nc" id="L1305">           setPeerState(ServerState.LEADING);</span>
<span class="nc" id="L1306">           LOG.debug(&quot;PeerState set to LEADING&quot;);</span>
<span class="nc bnc" id="L1307" title="All 2 branches missed.">       } else if (getLearnerType() == LearnerType.PARTICIPANT) {</span>
<span class="nc" id="L1308">           setPeerState(ServerState.FOLLOWING);</span>
<span class="nc" id="L1309">           LOG.debug(&quot;PeerState set to FOLLOWING&quot;);</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">       } else if (getLearnerType() == LearnerType.OBSERVER) {</span>
<span class="nc" id="L1311">           setPeerState(ServerState.OBSERVING);</span>
<span class="nc" id="L1312">           LOG.debug(&quot;PeerState set to OBSERVER&quot;);</span>
       } else { // currently shouldn't happen since there are only 2 learner types
<span class="nc" id="L1314">           setPeerState(ServerState.LOOKING);</span>
<span class="nc" id="L1315">           LOG.debug(&quot;Shouldn't be here&quot;);</span>
       }       
<span class="nc" id="L1317">       reconfigFlag = false;   </span>
<span class="nc" id="L1318">    }</span>
    
    public void shutdown() {
<span class="nc" id="L1321">        running = false;</span>
<span class="nc" id="L1322">        x509Util.close();</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">        if (leader != null) {</span>
<span class="nc" id="L1324">            leader.shutdown(&quot;quorum Peer shutdown&quot;);</span>
        }
<span class="nc bnc" id="L1326" title="All 2 branches missed.">        if (follower != null) {</span>
<span class="nc" id="L1327">            follower.shutdown();</span>
        }
<span class="nc" id="L1329">        shutdownServerCnxnFactory();</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">        if(udpSocket != null) {</span>
<span class="nc" id="L1331">            udpSocket.close();</span>
        }

        try {
<span class="nc" id="L1335">            adminServer.shutdown();</span>
<span class="nc" id="L1336">        } catch (AdminServerException e) {</span>
<span class="nc" id="L1337">            LOG.warn(&quot;Problem stopping AdminServer&quot;, e);</span>
<span class="nc" id="L1338">        }</span>

<span class="nc bnc" id="L1340" title="All 2 branches missed.">        if(getElectionAlg() != null){</span>
<span class="nc" id="L1341">            this.interrupt();</span>
<span class="nc" id="L1342">            getElectionAlg().shutdown();</span>
        }
        try {
<span class="nc" id="L1345">            zkDb.close();</span>
<span class="nc" id="L1346">        } catch (IOException ie) {</span>
<span class="nc" id="L1347">            LOG.warn(&quot;Error closing logs &quot;, ie);</span>
<span class="nc" id="L1348">        }</span>
<span class="nc" id="L1349">    }</span>

    /**
     * A 'view' is a node's current opinion of the membership of the entire
     * ensemble.
     */
    public Map&lt;Long,QuorumPeer.QuorumServer&gt; getView() {
<span class="nc" id="L1356">        return Collections.unmodifiableMap(getQuorumVerifier().getAllMembers());</span>
    }

    /**
     * Observers are not contained in this view, only nodes with
     * PeerType=PARTICIPANT.
     */
    public Map&lt;Long,QuorumPeer.QuorumServer&gt; getVotingView() {
<span class="nc" id="L1364">        return getQuorumVerifier().getVotingMembers();</span>
    }

    /**
     * Returns only observers, no followers.
     */
    public Map&lt;Long,QuorumPeer.QuorumServer&gt; getObservingView() {
<span class="nc" id="L1371">       return getQuorumVerifier().getObservingMembers();</span>
    }

    public synchronized Set&lt;Long&gt; getCurrentAndNextConfigVoters() {
<span class="nc" id="L1375">        Set&lt;Long&gt; voterIds = new HashSet&lt;Long&gt;(getQuorumVerifier()</span>
<span class="nc" id="L1376">                .getVotingMembers().keySet());</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">        if (getLastSeenQuorumVerifier() != null) {</span>
<span class="nc" id="L1378">            voterIds.addAll(getLastSeenQuorumVerifier().getVotingMembers()</span>
<span class="nc" id="L1379">                    .keySet());</span>
        }
<span class="nc" id="L1381">        return voterIds;</span>
    }
    
    /**
     * Check if a node is in the current view. With static membership, the
     * result of this check will never change; only when dynamic membership
     * is introduced will this be more useful.
     */
    public boolean viewContains(Long sid) {
<span class="nc" id="L1390">        return this.getView().containsKey(sid);</span>
    }

    /**
     * Only used by QuorumStats at the moment
     */
    public String[] getQuorumPeers() {
<span class="nc" id="L1397">        List&lt;String&gt; l = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1398">        synchronized (this) {</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">            if (leader != null) {</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">                for (LearnerHandler fh : leader.getLearners()) {</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                    if (fh.getSocket() != null) {</span>
<span class="nc" id="L1402">                        String s = formatInetAddr((InetSocketAddress)fh.getSocket().getRemoteSocketAddress());</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">                        if (leader.isLearnerSynced(fh))</span>
<span class="nc" id="L1404">                            s += &quot;*&quot;;</span>
<span class="nc" id="L1405">                        l.add(s);</span>
                    }
<span class="nc" id="L1407">                }</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">            } else if (follower != null) {</span>
<span class="nc" id="L1409">                l.add(formatInetAddr((InetSocketAddress)follower.sock.getRemoteSocketAddress()));</span>
            }
<span class="nc" id="L1411">        }</span>
<span class="nc" id="L1412">        return l.toArray(new String[0]);</span>
    }

    public String getServerState() {
<span class="nc bnc" id="L1416" title="All 5 branches missed.">        switch (getPeerState()) {</span>
        case LOOKING:
<span class="nc" id="L1418">            return QuorumStats.Provider.LOOKING_STATE;</span>
        case LEADING:
<span class="nc" id="L1420">            return QuorumStats.Provider.LEADING_STATE;</span>
        case FOLLOWING:
<span class="nc" id="L1422">            return QuorumStats.Provider.FOLLOWING_STATE;</span>
        case OBSERVING:
<span class="nc" id="L1424">            return QuorumStats.Provider.OBSERVING_STATE;</span>
        }
<span class="nc" id="L1426">        return QuorumStats.Provider.UNKNOWN_STATE;</span>
    }


    /**
     * set the id of this quorum peer.
     */
    public void setMyid(long myid) {
<span class="nc" id="L1434">        this.myid = myid;</span>
<span class="nc" id="L1435">    }</span>

    /**
     * Get the number of milliseconds of each tick
     */
    public int getTickTime() {
<span class="nc" id="L1441">        return tickTime;</span>
    }

    /**
     * Set the number of milliseconds of each tick
     */
    public void setTickTime(int tickTime) {
<span class="nc" id="L1448">        LOG.info(&quot;tickTime set to &quot; + tickTime);</span>
<span class="nc" id="L1449">        this.tickTime = tickTime;</span>
<span class="nc" id="L1450">    }</span>

    /** Maximum number of connections allowed from particular host (ip) */
    public int getMaxClientCnxnsPerHost() {
<span class="nc bnc" id="L1454" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L1455">            return cnxnFactory.getMaxClientCnxnsPerHost();</span>
        }
<span class="nc bnc" id="L1457" title="All 2 branches missed.">        if (secureCnxnFactory != null) {</span>
<span class="nc" id="L1458">            return secureCnxnFactory.getMaxClientCnxnsPerHost();</span>
        }
<span class="nc" id="L1460">        return -1;</span>
    }

    /** Whether local sessions are enabled */
    public boolean areLocalSessionsEnabled() {
<span class="nc" id="L1465">        return localSessionsEnabled;</span>
    }

    /** Whether to enable local sessions */
    public void enableLocalSessions(boolean flag) {
<span class="nc bnc" id="L1470" title="All 2 branches missed.">        LOG.info(&quot;Local sessions &quot; + (flag ? &quot;enabled&quot; : &quot;disabled&quot;));</span>
<span class="nc" id="L1471">        localSessionsEnabled = flag;</span>
<span class="nc" id="L1472">    }</span>

    /** Whether local sessions are allowed to upgrade to global sessions */
    public boolean isLocalSessionsUpgradingEnabled() {
<span class="nc" id="L1476">        return localSessionsUpgradingEnabled;</span>
    }

    /** Whether to allow local sessions to upgrade to global sessions */
    public void enableLocalSessionsUpgrading(boolean flag) {
<span class="nc bnc" id="L1481" title="All 2 branches missed.">        LOG.info(&quot;Local session upgrading &quot; + (flag ? &quot;enabled&quot; : &quot;disabled&quot;));</span>
<span class="nc" id="L1482">        localSessionsUpgradingEnabled = flag;</span>
<span class="nc" id="L1483">    }</span>

    /** minimum session timeout in milliseconds */
    public int getMinSessionTimeout() {
<span class="nc" id="L1487">        return minSessionTimeout;</span>
    }

    /** minimum session timeout in milliseconds */
    public void setMinSessionTimeout(int min) {
<span class="nc" id="L1492">        LOG.info(&quot;minSessionTimeout set to &quot; + min);</span>
<span class="nc" id="L1493">        this.minSessionTimeout = min;</span>
<span class="nc" id="L1494">    }</span>

    /** maximum session timeout in milliseconds */
    public int getMaxSessionTimeout() {
<span class="nc" id="L1498">        return maxSessionTimeout;</span>
    }

    /** maximum session timeout in milliseconds */
    public void setMaxSessionTimeout(int max) {
<span class="nc" id="L1503">        LOG.info(&quot;maxSessionTimeout set to &quot; + max);</span>
<span class="nc" id="L1504">        this.maxSessionTimeout = max;</span>
<span class="nc" id="L1505">    }</span>

    /**
     * Get the number of ticks that the initial synchronization phase can take
     */
    public int getInitLimit() {
<span class="nc" id="L1511">        return initLimit;</span>
    }

    /**
     * Set the number of ticks that the initial synchronization phase can take
     */
    public void setInitLimit(int initLimit) {
<span class="nc" id="L1518">        LOG.info(&quot;initLimit set to &quot; + initLimit);</span>
<span class="nc" id="L1519">        this.initLimit = initLimit;</span>
<span class="nc" id="L1520">    }</span>

    /**
     * Get the current tick
     */
    public int getTick() {
<span class="nc" id="L1526">        return tick.get();</span>
    }

    public QuorumVerifier configFromString(String s) throws IOException, ConfigException{
<span class="nc" id="L1530">        Properties props = new Properties();        </span>
<span class="nc" id="L1531">        props.load(new StringReader(s));</span>
<span class="nc" id="L1532">        return QuorumPeerConfig.parseDynamicConfig(props, electionType, false, false);</span>
    }
    
    /**
     * Return QuorumVerifier object for the last committed configuration.
     */
    public QuorumVerifier getQuorumVerifier(){
<span class="nc" id="L1539">        synchronized (QV_LOCK) {</span>
<span class="nc" id="L1540">            return quorumVerifier;</span>
        }
    }

    /**
     * Return QuorumVerifier object for the last proposed configuration.
     */
    public QuorumVerifier getLastSeenQuorumVerifier(){
<span class="nc" id="L1548">        synchronized (QV_LOCK) {</span>
<span class="nc" id="L1549">            return lastSeenQuorumVerifier;</span>
        }
    }
    
    public synchronized void restartLeaderElection(QuorumVerifier qvOLD, QuorumVerifier qvNEW){
<span class="nc bnc" id="L1554" title="All 4 branches missed.">        if (qvOLD == null || !qvOLD.equals(qvNEW)) {</span>
<span class="nc" id="L1555">            LOG.warn(&quot;Restarting Leader Election&quot;);</span>
<span class="nc" id="L1556">            getElectionAlg().shutdown();</span>
<span class="nc" id="L1557">            shuttingDownLE = false;</span>
<span class="nc" id="L1558">            startLeaderElection();</span>
        }           
<span class="nc" id="L1560">    }</span>

    public String getNextDynamicConfigFilename() {
<span class="nc bnc" id="L1563" title="All 2 branches missed.">        if (configFilename == null) {</span>
<span class="nc" id="L1564">            LOG.warn(&quot;configFilename is null! This should only happen in tests.&quot;);</span>
<span class="nc" id="L1565">            return null;</span>
        }
<span class="nc" id="L1567">        return configFilename + QuorumPeerConfig.nextDynamicConfigFileSuffix;</span>
    }
    
    // On entry to this method, qcm must be non-null and the locks on both qcm and QV_LOCK
    // must be held.  We don't want quorumVerifier/lastSeenQuorumVerifier to change out from
    // under us, so we have to hold QV_LOCK; and since the call to qcm.connectOne() will take
    // the lock on qcm (and take QV_LOCK again inside that), the caller needs to have taken
    // qcm outside QV_LOCK to avoid a deadlock against other callers of qcm.connectOne().
    private void connectNewPeers(QuorumCnxManager qcm){
<span class="nc bnc" id="L1576" title="All 4 branches missed.">        if (quorumVerifier != null &amp;&amp; lastSeenQuorumVerifier != null) {</span>
<span class="nc" id="L1577">            Map&lt;Long, QuorumServer&gt; committedView = quorumVerifier.getAllMembers();</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">            for (Entry&lt;Long, QuorumServer&gt; e : lastSeenQuorumVerifier.getAllMembers().entrySet()) {</span>
<span class="nc bnc" id="L1579" title="All 4 branches missed.">                if (e.getKey() != getId() &amp;&amp; !committedView.containsKey(e.getKey()))</span>
<span class="nc" id="L1580">                    qcm.connectOne(e.getKey());</span>
<span class="nc" id="L1581">            }</span>
        }
<span class="nc" id="L1583">    }</span>

    public void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk){
        // If qcm is non-null, we may call qcm.connectOne(), which will take the lock on qcm
        // and then take QV_LOCK.  Take the locks in the same order to ensure that we don't
        // deadlock against other callers of connectOne().  If qcmRef gets set in another
        // thread while we're inside the synchronized block, that does no harm; if we didn't
        // take a lock on qcm (because it was null when we sampled it), we won't call
        // connectOne() on it.  (Use of an AtomicReference is enough to guarantee visibility
        // of updates that provably happen in another thread before entering this method.)
<span class="nc" id="L1593">        QuorumCnxManager qcm = qcmRef.get();</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">        Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;</span>
<span class="nc" id="L1595">        synchronized (outerLockObject) {</span>
<span class="nc" id="L1596">            synchronized (QV_LOCK) {</span>
<span class="nc bnc" id="L1597" title="All 4 branches missed.">                if (lastSeenQuorumVerifier != null &amp;&amp; lastSeenQuorumVerifier.getVersion() &gt; qv.getVersion()) {</span>
<span class="nc" id="L1598">                    LOG.error(&quot;setLastSeenQuorumVerifier called with stale config &quot; + qv.getVersion() +</span>
<span class="nc" id="L1599">                            &quot;. Current version: &quot; + quorumVerifier.getVersion());</span>
                }
                // assuming that a version uniquely identifies a configuration, so if
                // version is the same, nothing to do here.
<span class="nc bnc" id="L1603" title="All 2 branches missed.">                if (lastSeenQuorumVerifier != null &amp;&amp;</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">                        lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {</span>
<span class="nc" id="L1605">                    return;</span>
                }
<span class="nc" id="L1607">                lastSeenQuorumVerifier = qv;</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">                if (qcm != null) {</span>
<span class="nc" id="L1609">                    connectNewPeers(qcm);</span>
                }

<span class="nc bnc" id="L1612" title="All 2 branches missed.">                if (writeToDisk) {</span>
                    try {
<span class="nc" id="L1614">                        String fileName = getNextDynamicConfigFilename();</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">                        if (fileName != null) {</span>
<span class="nc" id="L1616">                            QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);</span>
                        }
<span class="nc" id="L1618">                    } catch (IOException e) {</span>
<span class="nc" id="L1619">                        LOG.error(&quot;Error writing next dynamic config file to disk: &quot;, e.getMessage());</span>
<span class="nc" id="L1620">                    }</span>
                }
<span class="nc" id="L1622">            }</span>
<span class="nc" id="L1623">        }</span>
<span class="nc" id="L1624">    }</span>
    
    public QuorumVerifier setQuorumVerifier(QuorumVerifier qv, boolean writeToDisk){
<span class="nc" id="L1627">        synchronized (QV_LOCK) {</span>
<span class="nc bnc" id="L1628" title="All 4 branches missed.">            if ((quorumVerifier != null) &amp;&amp; (quorumVerifier.getVersion() &gt;= qv.getVersion())) {</span>
                // this is normal. For example - server found out about new config through FastLeaderElection gossiping
                // and then got the same config in UPTODATE message so its already known
<span class="nc" id="L1631">                LOG.debug(getId() + &quot; setQuorumVerifier called with known or old config &quot; + qv.getVersion() +</span>
<span class="nc" id="L1632">                        &quot;. Current version: &quot; + quorumVerifier.getVersion());</span>
<span class="nc" id="L1633">                return quorumVerifier;</span>
            }
<span class="nc" id="L1635">            QuorumVerifier prevQV = quorumVerifier;</span>
<span class="nc" id="L1636">            quorumVerifier = qv;</span>
<span class="nc bnc" id="L1637" title="All 4 branches missed.">            if (lastSeenQuorumVerifier == null || (qv.getVersion() &gt; lastSeenQuorumVerifier.getVersion()))</span>
<span class="nc" id="L1638">                lastSeenQuorumVerifier = qv;</span>

<span class="nc bnc" id="L1640" title="All 2 branches missed.">            if (writeToDisk) {</span>
                // some tests initialize QuorumPeer without a static config file
<span class="nc bnc" id="L1642" title="All 2 branches missed.">                if (configFilename != null) {</span>
                    try {
<span class="nc" id="L1644">                        String dynamicConfigFilename = makeDynamicConfigFilename(</span>
<span class="nc" id="L1645">                                qv.getVersion());</span>
<span class="nc" id="L1646">                        QuorumPeerConfig.writeDynamicConfig(</span>
                                dynamicConfigFilename, qv, false);
<span class="nc" id="L1648">                        QuorumPeerConfig.editStaticConfig(configFilename,</span>
                                dynamicConfigFilename,
<span class="nc" id="L1650">                                needEraseClientInfoFromStaticConfig());</span>
<span class="nc" id="L1651">                    } catch (IOException e) {</span>
<span class="nc" id="L1652">                        LOG.error(&quot;Error closing file: &quot;, e.getMessage());</span>
<span class="nc" id="L1653">                    }</span>
                } else {
<span class="nc" id="L1655">                    LOG.info(&quot;writeToDisk == true but configFilename == null&quot;);</span>
                }
            }

<span class="nc bnc" id="L1659" title="All 2 branches missed.">            if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {</span>
<span class="nc" id="L1660">                QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());</span>
            }
<span class="nc" id="L1662">            QuorumServer qs = qv.getAllMembers().get(getId());</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">            if (qs != null) {</span>
<span class="nc" id="L1664">                setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);</span>
            }
<span class="nc" id="L1666">            return prevQV;</span>
        }
    }

    private String makeDynamicConfigFilename(long version) {
<span class="nc" id="L1671">        return configFilename + &quot;.dynamic.&quot; + Long.toHexString(version);</span>
    }

    private boolean needEraseClientInfoFromStaticConfig() {
<span class="nc" id="L1675">        QuorumServer server = quorumVerifier.getAllMembers().get(getId());</span>
<span class="nc bnc" id="L1676" title="All 4 branches missed.">        return (server != null &amp;&amp; server.clientAddr != null);</span>
    }

    /**
     * Get an instance of LeaderElection
     */
    public Election getElectionAlg(){
<span class="nc" id="L1683">        return electionAlg;</span>
    }

    /**
     * Get the synclimit
     */
    public int getSyncLimit() {
<span class="nc" id="L1690">        return syncLimit;</span>
    }

    /**
     * Set the synclimit
     */
    public void setSyncLimit(int syncLimit) {
<span class="nc" id="L1697">        this.syncLimit = syncLimit;</span>
<span class="nc" id="L1698">    }</span>
    
    
    /**
     * The syncEnabled can also be set via a system property.
     */
    public static final String SYNC_ENABLED = &quot;zookeeper.observer.syncEnabled&quot;;
    
    /**
     * Return syncEnabled.
     * 
     * @return
     */
    public boolean getSyncEnabled() {
<span class="nc bnc" id="L1712" title="All 2 branches missed.">        if (System.getProperty(SYNC_ENABLED) != null) {</span>
<span class="nc" id="L1713">            LOG.info(SYNC_ENABLED + &quot;=&quot; + Boolean.getBoolean(SYNC_ENABLED));   </span>
<span class="nc" id="L1714">            return Boolean.getBoolean(SYNC_ENABLED);</span>
        } else {        
<span class="nc" id="L1716">            return syncEnabled;</span>
        }
    }
    
    /**
     * Set syncEnabled.
     * 
     * @param syncEnabled
     */
    public void setSyncEnabled(boolean syncEnabled) {
<span class="nc" id="L1726">        this.syncEnabled = syncEnabled;</span>
<span class="nc" id="L1727">    }</span>

    /**
     * Gets the election type
     */
    public int getElectionType() {
<span class="nc" id="L1733">        return electionType;</span>
    }

    /**
     * Sets the election type
     */
    public void setElectionType(int electionType) {
<span class="nc" id="L1740">        this.electionType = electionType;</span>
<span class="nc" id="L1741">    }</span>

    public boolean getQuorumListenOnAllIPs() {
<span class="nc" id="L1744">        return quorumListenOnAllIPs;</span>
    }

    public void setQuorumListenOnAllIPs(boolean quorumListenOnAllIPs) {
<span class="nc" id="L1748">        this.quorumListenOnAllIPs = quorumListenOnAllIPs;</span>
<span class="nc" id="L1749">    }</span>

    public void setCnxnFactory(ServerCnxnFactory cnxnFactory) {
<span class="nc" id="L1752">        this.cnxnFactory = cnxnFactory;</span>
<span class="nc" id="L1753">    }</span>

    public void setSecureCnxnFactory(ServerCnxnFactory secureCnxnFactory) {
<span class="nc" id="L1756">        this.secureCnxnFactory = secureCnxnFactory;</span>
<span class="nc" id="L1757">    }</span>

    public void setSslQuorum(boolean sslQuorum) {
<span class="nc bnc" id="L1760" title="All 2 branches missed.">        if (sslQuorum) {</span>
<span class="nc" id="L1761">            LOG.info(&quot;Using TLS encrypted quorum communication&quot;);</span>
        } else {
<span class="nc" id="L1763">            LOG.info(&quot;Using insecure (non-TLS) quorum communication&quot;);</span>
        }
<span class="nc" id="L1765">        this.sslQuorum = sslQuorum;</span>
<span class="nc" id="L1766">    }</span>

    public void setUsePortUnification(boolean shouldUsePortUnification) {
<span class="nc bnc" id="L1769" title="All 2 branches missed.">        LOG.info(&quot;Port unification {}&quot;, shouldUsePortUnification ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="nc" id="L1770">        this.shouldUsePortUnification = shouldUsePortUnification;</span>
<span class="nc" id="L1771">    }</span>

    private void startServerCnxnFactory() {
<span class="nc bnc" id="L1774" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L1775">            cnxnFactory.start();</span>
        }
<span class="nc bnc" id="L1777" title="All 2 branches missed.">        if (secureCnxnFactory != null) {</span>
<span class="nc" id="L1778">            secureCnxnFactory.start();</span>
        }
<span class="nc" id="L1780">    }</span>

    private void shutdownServerCnxnFactory() {
<span class="nc bnc" id="L1783" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L1784">            cnxnFactory.shutdown();</span>
        }
<span class="nc bnc" id="L1786" title="All 2 branches missed.">        if (secureCnxnFactory != null) {</span>
<span class="nc" id="L1787">            secureCnxnFactory.shutdown();</span>
        }
<span class="nc" id="L1789">    }</span>

    // Leader and learner will control the zookeeper server and pass it into QuorumPeer.
    public void setZooKeeperServer(ZooKeeperServer zks) {
<span class="nc bnc" id="L1793" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L1794">            cnxnFactory.setZooKeeperServer(zks);</span>
        }
<span class="nc bnc" id="L1796" title="All 2 branches missed.">        if (secureCnxnFactory != null) {</span>
<span class="nc" id="L1797">            secureCnxnFactory.setZooKeeperServer(zks);</span>
        }
<span class="nc" id="L1799">    }</span>

    public void closeAllConnections() {
<span class="nc bnc" id="L1802" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L1803">            cnxnFactory.closeAll();</span>
        }
<span class="nc bnc" id="L1805" title="All 2 branches missed.">        if (secureCnxnFactory != null) {</span>
<span class="nc" id="L1806">            secureCnxnFactory.closeAll();</span>
        }
<span class="nc" id="L1808">    }</span>

    public int getClientPort() {
<span class="nc bnc" id="L1811" title="All 2 branches missed.">        if (cnxnFactory != null) {</span>
<span class="nc" id="L1812">            return cnxnFactory.getLocalPort();</span>
        }
<span class="nc" id="L1814">        return -1;</span>
    }

    public void setTxnFactory(FileTxnSnapLog factory) {
<span class="nc" id="L1818">        this.logFactory = factory;</span>
<span class="nc" id="L1819">    }</span>

    public FileTxnSnapLog getTxnFactory() {
<span class="nc" id="L1822">        return this.logFactory;</span>
    }

    /**
     * set zk database for this node
     * @param database
     */
    public void setZKDatabase(ZKDatabase database) {
<span class="nc" id="L1830">        this.zkDb = database;</span>
<span class="nc" id="L1831">    }</span>

    protected ZKDatabase getZkDb() {
<span class="nc" id="L1834">        return zkDb;</span>
    }

    public synchronized void initConfigInZKDatabase() {   
<span class="nc bnc" id="L1838" title="All 2 branches missed.">        if (zkDb != null) zkDb.initConfigInZKDatabase(getQuorumVerifier());</span>
<span class="nc" id="L1839">    }</span>

    public boolean isRunning() {
<span class="nc" id="L1842">        return running;</span>
    }

    /**
     * get reference to QuorumCnxManager
     */
    public QuorumCnxManager getQuorumCnxManager() {
<span class="nc" id="L1849">        return qcmRef.get();</span>
    }
    private long readLongFromFile(String name) throws IOException {
<span class="nc" id="L1852">        File file = new File(logFactory.getSnapDir(), name);</span>
<span class="nc" id="L1853">        BufferedReader br = new BufferedReader(new FileReader(file));</span>
<span class="nc" id="L1854">        String line = &quot;&quot;;</span>
        try {
<span class="nc" id="L1856">            line = br.readLine();</span>
<span class="nc" id="L1857">            return Long.parseLong(line);</span>
<span class="nc" id="L1858">        } catch(NumberFormatException e) {</span>
<span class="nc" id="L1859">            throw new IOException(&quot;Found &quot; + line + &quot; in &quot; + file);</span>
        } finally {
<span class="nc" id="L1861">            br.close();</span>
        }
    }

<span class="nc" id="L1865">    private long acceptedEpoch = -1;</span>
<span class="nc" id="L1866">    private long currentEpoch = -1;</span>

    public static final String CURRENT_EPOCH_FILENAME = &quot;currentEpoch&quot;;

    public static final String ACCEPTED_EPOCH_FILENAME = &quot;acceptedEpoch&quot;;

	/**
	 * Write a long value to disk atomically. Either succeeds or an exception
	 * is thrown.
	 * @param name file name to write the long to
	 * @param value the long value to write to the named file
	 * @throws IOException if the file cannot be written atomically
	 */
    // visibleForTest
    void writeLongToFile(String name, final long value) throws IOException {
<span class="nc" id="L1881">        File file = new File(logFactory.getSnapDir(), name);</span>
<span class="nc" id="L1882">        new AtomicFileWritingIdiom(file, new WriterStatement() {</span>
            @Override
            public void write(Writer bw) throws IOException {
<span class="nc" id="L1885">                bw.write(Long.toString(value));</span>
<span class="nc" id="L1886">            }</span>
        });
<span class="nc" id="L1888">    }</span>

    public long getCurrentEpoch() throws IOException {
<span class="nc bnc" id="L1891" title="All 2 branches missed.">        if (currentEpoch == -1) {</span>
<span class="nc" id="L1892">            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);</span>
        }
<span class="nc" id="L1894">        return currentEpoch;</span>
    }

    public long getAcceptedEpoch() throws IOException {
<span class="nc bnc" id="L1898" title="All 2 branches missed.">        if (acceptedEpoch == -1) {</span>
<span class="nc" id="L1899">            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);</span>
        }
<span class="nc" id="L1901">        return acceptedEpoch;</span>
    }

    public void setCurrentEpoch(long e) throws IOException {
<span class="nc" id="L1905">        writeLongToFile(CURRENT_EPOCH_FILENAME, e);</span>
<span class="nc" id="L1906">        currentEpoch = e;</span>

<span class="nc" id="L1908">    }</span>

    public void setAcceptedEpoch(long e) throws IOException {
<span class="nc" id="L1911">        writeLongToFile(ACCEPTED_EPOCH_FILENAME, e);</span>
<span class="nc" id="L1912">        acceptedEpoch = e;</span>
<span class="nc" id="L1913">    }</span>
   
    public boolean processReconfig(QuorumVerifier qv, Long suggestedLeaderId, Long zxid, boolean restartLE) {
<span class="nc bnc" id="L1916" title="All 2 branches missed.">       if (!QuorumPeerConfig.isReconfigEnabled()) {</span>
<span class="nc" id="L1917">           LOG.debug(&quot;Reconfig feature is disabled, skip reconfig processing.&quot;);</span>
<span class="nc" id="L1918">           return false;</span>
       }

<span class="nc" id="L1921">       InetSocketAddress oldClientAddr = getClientAddress();</span>

       // update last committed quorum verifier, write the new config to disk
       // and restart leader election if config changed.
<span class="nc" id="L1925">       QuorumVerifier prevQV = setQuorumVerifier(qv, true);</span>

       // There is no log record for the initial config, thus after syncing
       // with leader
       // /zookeeper/config is empty! it is also possible that last committed
       // config is propagated during leader election
       // without the propagation the corresponding log records.
       // so we should explicitly do this (this is not necessary when we're
       // already a Follower/Observer, only
       // for Learner):
<span class="nc" id="L1935">       initConfigInZKDatabase();</span>

<span class="nc bnc" id="L1937" title="All 4 branches missed.">       if (prevQV.getVersion() &lt; qv.getVersion() &amp;&amp; !prevQV.equals(qv)) {</span>
<span class="nc" id="L1938">           Map&lt;Long, QuorumServer&gt; newMembers = qv.getAllMembers();</span>
<span class="nc" id="L1939">           updateRemotePeerMXBeans(newMembers);</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">           if (restartLE) restartLeaderElection(prevQV, qv);</span>

<span class="nc" id="L1942">           QuorumServer myNewQS = newMembers.get(getId());</span>
<span class="nc bnc" id="L1943" title="All 4 branches missed.">           if (myNewQS != null &amp;&amp; myNewQS.clientAddr != null</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">                   &amp;&amp; !myNewQS.clientAddr.equals(oldClientAddr)) {</span>
<span class="nc" id="L1945">               cnxnFactory.reconfigure(myNewQS.clientAddr);</span>
<span class="nc" id="L1946">               updateThreadName();</span>
           }

<span class="nc" id="L1949">           boolean roleChange = updateLearnerType(qv);</span>
<span class="nc" id="L1950">           boolean leaderChange = false;</span>
<span class="nc bnc" id="L1951" title="All 2 branches missed.">           if (suggestedLeaderId != null) {</span>
               // zxid should be non-null too
<span class="nc" id="L1953">               leaderChange = updateVote(suggestedLeaderId, zxid);</span>
           } else {
<span class="nc" id="L1955">               long currentLeaderId = getCurrentVote().getId();</span>
<span class="nc" id="L1956">               QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);</span>
<span class="nc" id="L1957">               QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);</span>
<span class="nc bnc" id="L1958" title="All 6 branches missed.">               leaderChange = (myleaderInCurQV == null || myleaderInCurQV.addr == null || </span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">                               myleaderInNewQV == null || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));</span>
               // we don't have a designated leader - need to go into leader
               // election
<span class="nc" id="L1962">               reconfigFlagClear();</span>
           }
           
<span class="nc bnc" id="L1965" title="All 4 branches missed.">           if (roleChange || leaderChange) {</span>
<span class="nc" id="L1966">               return true;</span>
           }
       }
<span class="nc" id="L1969">       return false;</span>

   }

    private void updateRemotePeerMXBeans(Map&lt;Long, QuorumServer&gt; newMembers) {
<span class="nc" id="L1974">        Set&lt;Long&gt; existingMembers = new HashSet&lt;Long&gt;(newMembers.keySet());</span>
<span class="nc" id="L1975">        existingMembers.retainAll(jmxRemotePeerBean.keySet());</span>
<span class="nc bnc" id="L1976" title="All 2 branches missed.">        for (Long id : existingMembers) {</span>
<span class="nc" id="L1977">            RemotePeerBean rBean = jmxRemotePeerBean.get(id);</span>
<span class="nc" id="L1978">            rBean.setQuorumServer(newMembers.get(id));</span>
<span class="nc" id="L1979">        }</span>

<span class="nc" id="L1981">        Set&lt;Long&gt; joiningMembers = new HashSet&lt;Long&gt;(newMembers.keySet());</span>
<span class="nc" id="L1982">        joiningMembers.removeAll(jmxRemotePeerBean.keySet());</span>
<span class="nc" id="L1983">        joiningMembers.remove(getId()); // remove self as it is local bean</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">        for (Long id : joiningMembers) {</span>
<span class="nc" id="L1985">            QuorumServer qs = newMembers.get(id);</span>
<span class="nc" id="L1986">            RemotePeerBean rBean = new RemotePeerBean(this, qs);</span>
            try {
<span class="nc" id="L1988">                MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);</span>
<span class="nc" id="L1989">                jmxRemotePeerBean.put(qs.id, rBean);</span>
<span class="nc" id="L1990">            } catch (Exception e) {</span>
<span class="nc" id="L1991">                LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="nc" id="L1992">            }</span>
<span class="nc" id="L1993">        }</span>

<span class="nc" id="L1995">        Set&lt;Long&gt; leavingMembers = new HashSet&lt;Long&gt;(jmxRemotePeerBean.keySet());</span>
<span class="nc" id="L1996">        leavingMembers.removeAll(newMembers.keySet());</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">        for (Long id : leavingMembers) {</span>
<span class="nc" id="L1998">            RemotePeerBean rBean = jmxRemotePeerBean.remove(id);</span>
            try {
<span class="nc" id="L2000">                MBeanRegistry.getInstance().unregister(rBean);</span>
<span class="nc" id="L2001">            } catch (Exception e) {</span>
<span class="nc" id="L2002">                LOG.warn(&quot;Failed to unregister with JMX&quot;, e);</span>
<span class="nc" id="L2003">            }</span>
<span class="nc" id="L2004">        }</span>
<span class="nc" id="L2005">    }</span>

   private boolean updateLearnerType(QuorumVerifier newQV) {        
       //check if I'm an observer in new config
<span class="nc bnc" id="L2009" title="All 2 branches missed.">       if (newQV.getObservingMembers().containsKey(getId())) {</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">           if (getLearnerType()!=LearnerType.OBSERVER){</span>
<span class="nc" id="L2011">               setLearnerType(LearnerType.OBSERVER);</span>
<span class="nc" id="L2012">               LOG.info(&quot;Becoming an observer&quot;);</span>
<span class="nc" id="L2013">               reconfigFlagSet();</span>
<span class="nc" id="L2014">               return true;</span>
           } else {
<span class="nc" id="L2016">               return false;           </span>
           }
<span class="nc bnc" id="L2018" title="All 2 branches missed.">       } else if (newQV.getVotingMembers().containsKey(getId())) {</span>
<span class="nc bnc" id="L2019" title="All 2 branches missed.">           if (getLearnerType()!=LearnerType.PARTICIPANT){</span>
<span class="nc" id="L2020">               setLearnerType(LearnerType.PARTICIPANT);</span>
<span class="nc" id="L2021">               LOG.info(&quot;Becoming a voting participant&quot;);</span>
<span class="nc" id="L2022">               reconfigFlagSet();</span>
<span class="nc" id="L2023">               return true;</span>
           } else {
<span class="nc" id="L2025">               return false;</span>
           }
       }
       // I'm not in the view
<span class="nc bnc" id="L2029" title="All 2 branches missed.">      if (getLearnerType()!=LearnerType.PARTICIPANT){</span>
<span class="nc" id="L2030">          setLearnerType(LearnerType.PARTICIPANT);</span>
<span class="nc" id="L2031">          LOG.info(&quot;Becoming a non-voting participant&quot;);</span>
<span class="nc" id="L2032">          reconfigFlagSet();</span>
<span class="nc" id="L2033">          return true;</span>
      }
<span class="nc" id="L2035">      return false;</span>
   }
   
   private boolean updateVote(long designatedLeader, long zxid){       
<span class="nc" id="L2039">       Vote currentVote = getCurrentVote();</span>
<span class="nc bnc" id="L2040" title="All 4 branches missed.">       if (currentVote!=null &amp;&amp; designatedLeader != currentVote.getId()) {</span>
<span class="nc" id="L2041">           setCurrentVote(new Vote(designatedLeader, zxid));</span>
<span class="nc" id="L2042">           reconfigFlagSet();</span>
<span class="nc" id="L2043">           LOG.warn(&quot;Suggested leader: &quot; + designatedLeader);</span>
<span class="nc" id="L2044">           return true;</span>
       }
<span class="nc" id="L2046">       return false;</span>
   }
 
    /**
     * Updates leader election info to avoid inconsistencies when
     * a new server tries to join the ensemble.
     *
     * Here is the inconsistency scenario we try to solve by updating the peer 
     * epoch after following leader:
     *
     * Let's say we have an ensemble with 3 servers z1, z2 and z3.
     *
     * 1. z1, z2 were following z3 with peerEpoch to be 0xb8, the new epoch is 
     *    0xb9, aka current accepted epoch on disk.
     * 2. z2 get restarted, which will use 0xb9 as it's peer epoch when loading
     *    the current accept epoch from disk.
     * 3. z2 received notification from z1 and z3, which is following z3 with 
     *    epoch 0xb8, so it started following z3 again with peer epoch 0xb8.
     * 4. before z2 successfully connected to z3, z3 get restarted with new 
     *    epoch 0xb9.
     * 5. z2 will retry around a few round (default 5s) before giving up, 
     *    meanwhile it will report z3 as leader.
     * 6. z1 restarted, and looking with peer epoch 0xb9.
     * 7. z1 voted z3, and z3 was elected as leader again with peer epoch 0xb9.
     * 8. z2 successfully connected to z3 before giving up, but with peer 
     *    epoch 0xb8.
     * 9. z1 get restarted, looking for leader with peer epoch 0xba, but cannot 
     *    join, because z2 is reporting peer epoch 0xb8, while z3 is reporting 
     *    0xb9.
     *
     * By updating the election vote after actually following leader, we can 
     * avoid this kind of stuck happened.
     *
     * Btw, the zxid and electionEpoch could be inconsistent because of the same 
     * reason, it's better to update these as well after syncing with leader, but 
     * that required protocol change which is non trivial. This problem is worked 
     * around by skipping comparing the zxid and electionEpoch when counting for 
     * votes for out of election servers during looking for leader.
     * 
     * {@see https://issues.apache.org/jira/browse/ZOOKEEPER-1732}
     */
    protected void updateElectionVote(long newEpoch) {
<span class="nc" id="L2088">        Vote currentVote = getCurrentVote();</span>
<span class="nc bnc" id="L2089" title="All 2 branches missed.">        if (currentVote != null) {</span>
<span class="nc" id="L2090">            setCurrentVote(new Vote(currentVote.getId(),</span>
<span class="nc" id="L2091">                currentVote.getZxid(),</span>
<span class="nc" id="L2092">                currentVote.getElectionEpoch(),</span>
                newEpoch,
<span class="nc" id="L2094">                currentVote.getState()));</span>
        }
<span class="nc" id="L2096">    }</span>

    private void updateThreadName() {
<span class="nc bnc" id="L2099" title="All 2 branches missed.">        String plain = cnxnFactory != null ?</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">                cnxnFactory.getLocalAddress() != null ?</span>
<span class="nc" id="L2101">                        formatInetAddr(cnxnFactory.getLocalAddress()) : &quot;disabled&quot; : &quot;disabled&quot;;</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">        String secure = secureCnxnFactory != null ? formatInetAddr(secureCnxnFactory.getLocalAddress()) : &quot;disabled&quot;;</span>
<span class="nc" id="L2103">        setName(String.format(&quot;QuorumPeer[myid=%d](plain=%s)(secure=%s)&quot;, getId(), plain, secure));</span>
<span class="nc" id="L2104">    }</span>

    /**
     * Sets the time taken for leader election in milliseconds.
     *
     * @param electionTimeTaken time taken for leader election
     */
    void setElectionTimeTaken(long electionTimeTaken) {
<span class="nc" id="L2112">        this.electionTimeTaken = electionTimeTaken;</span>
<span class="nc" id="L2113">    }</span>

    /**
     * @return the time taken for leader election in milliseconds.
     */
    long getElectionTimeTaken() {
<span class="nc" id="L2119">        return electionTimeTaken;</span>
    }

    void setQuorumServerSaslRequired(boolean serverSaslRequired) {
<span class="nc" id="L2123">        quorumServerSaslAuthRequired = serverSaslRequired;</span>
<span class="nc" id="L2124">        LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED,</span>
<span class="nc" id="L2125">                serverSaslRequired);</span>
<span class="nc" id="L2126">    }</span>

    void setQuorumLearnerSaslRequired(boolean learnerSaslRequired) {
<span class="nc" id="L2129">        quorumLearnerSaslAuthRequired = learnerSaslRequired;</span>
<span class="nc" id="L2130">        LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED,</span>
<span class="nc" id="L2131">                learnerSaslRequired);</span>
<span class="nc" id="L2132">    }</span>

    void setQuorumSaslEnabled(boolean enableAuth) {
<span class="nc" id="L2135">        quorumSaslEnableAuth = enableAuth;</span>
<span class="nc bnc" id="L2136" title="All 2 branches missed.">        if (!quorumSaslEnableAuth) {</span>
<span class="nc" id="L2137">            LOG.info(&quot;QuorumPeer communication is not secured! (SASL auth disabled)&quot;);</span>
        } else {
<span class="nc" id="L2139">            LOG.info(&quot;{} set to {}&quot;,</span>
<span class="nc" id="L2140">                    QuorumAuth.QUORUM_SASL_AUTH_ENABLED, enableAuth);</span>
        }
<span class="nc" id="L2142">    }</span>

    void setQuorumServicePrincipal(String servicePrincipal) {
<span class="nc" id="L2145">        quorumServicePrincipal = servicePrincipal;</span>
<span class="nc" id="L2146">        LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL,</span>
                quorumServicePrincipal);
<span class="nc" id="L2148">    }</span>

    void setQuorumLearnerLoginContext(String learnerContext) {
<span class="nc" id="L2151">        quorumLearnerLoginContext = learnerContext;</span>
<span class="nc" id="L2152">        LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT,</span>
                quorumLearnerLoginContext);
<span class="nc" id="L2154">    }</span>

    void setQuorumServerLoginContext(String serverContext) {
<span class="nc" id="L2157">        quorumServerLoginContext = serverContext;</span>
<span class="nc" id="L2158">        LOG.info(&quot;{} set to {}&quot;, QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT,</span>
                quorumServerLoginContext);
<span class="nc" id="L2160">    }</span>

    void setQuorumCnxnThreadsSize(int qCnxnThreadsSize) {
<span class="nc bnc" id="L2163" title="All 2 branches missed.">        if (qCnxnThreadsSize &gt; QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {</span>
<span class="nc" id="L2164">            quorumCnxnThreadsSize = qCnxnThreadsSize;</span>
        }
<span class="nc" id="L2166">        LOG.info(&quot;quorum.cnxn.threads.size set to {}&quot;, quorumCnxnThreadsSize);</span>
<span class="nc" id="L2167">    }</span>

    boolean isQuorumSaslAuthEnabled() {
<span class="nc" id="L2170">        return quorumSaslEnableAuth;</span>
    }

    private boolean isQuorumServerSaslAuthRequired() {
<span class="nc" id="L2174">        return quorumServerSaslAuthRequired;</span>
    }

    private boolean isQuorumLearnerSaslAuthRequired() {
<span class="nc" id="L2178">        return quorumLearnerSaslAuthRequired;</span>
    }

    public QuorumCnxManager createCnxnManager() {
<span class="nc" id="L2182">        return new QuorumCnxManager(this,</span>
<span class="nc" id="L2183">                this.getId(),</span>
<span class="nc" id="L2184">                this.getView(),</span>
                this.authServer,
                this.authLearner,
                this.tickTime * this.syncLimit,
<span class="nc" id="L2188">                this.getQuorumListenOnAllIPs(),</span>
                this.quorumCnxnThreadsSize,
<span class="nc" id="L2190">                this.isQuorumSaslAuthEnabled());</span>
    }

    boolean isLeader(long id) {
<span class="nc" id="L2194">        Vote vote = getCurrentVote();</span>
<span class="nc bnc" id="L2195" title="All 4 branches missed.">        return vote != null &amp;&amp; id == vote.getId();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>