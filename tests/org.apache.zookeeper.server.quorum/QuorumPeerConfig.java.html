<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuorumPeerConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">parent$MyZookeeperRemoveWatchesTest.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server.quorum</a> &gt; <span class="el_source">QuorumPeerConfig.java</span></div><h1>QuorumPeerConfig.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server.quorum;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringReader;
import java.io.Writer;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Map.Entry;

import org.apache.yetus.audience.InterfaceAudience;
import org.apache.zookeeper.common.ClientX509Util;
import org.apache.zookeeper.common.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.apache.zookeeper.common.AtomicFileWritingIdiom;
import org.apache.zookeeper.common.AtomicFileWritingIdiom.OutputStreamStatement;
import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;
import org.apache.zookeeper.common.PathUtils;
import org.apache.zookeeper.server.ZooKeeperServer;
import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
import org.apache.zookeeper.server.quorum.auth.QuorumAuth;
import org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical;
import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
import org.apache.zookeeper.server.util.VerifyingFileFactory;

import static org.apache.zookeeper.common.NetUtils.formatInetAddr;

@InterfaceAudience.Public
<span class="nc" id="L61">public class QuorumPeerConfig {</span>
<span class="nc" id="L62">    private static final Logger LOG = LoggerFactory.getLogger(QuorumPeerConfig.class);</span>
    private static final int UNSET_SERVERID = -1;
    public static final String nextDynamicConfigFileSuffix = &quot;.dynamic.next&quot;;

<span class="nc" id="L66">    private static boolean standaloneEnabled = true;</span>
<span class="nc" id="L67">    private static boolean reconfigEnabled = false;</span>

    protected InetSocketAddress clientPortAddress;
    protected InetSocketAddress secureClientPortAddress;
<span class="nc" id="L71">    protected boolean sslQuorum = false;</span>
<span class="nc" id="L72">    protected boolean shouldUsePortUnification = false;</span>
<span class="nc" id="L73">    protected boolean sslQuorumReloadCertFiles = false;</span>
    protected File dataDir;
    protected File dataLogDir;
<span class="nc" id="L76">    protected String dynamicConfigFileStr = null;</span>
<span class="nc" id="L77">    protected String configFileStr = null;</span>
<span class="nc" id="L78">    protected int tickTime = ZooKeeperServer.DEFAULT_TICK_TIME;</span>
<span class="nc" id="L79">    protected int maxClientCnxns = 60;</span>
    /** defaults to -1 if not set explicitly */
<span class="nc" id="L81">    protected int minSessionTimeout = -1;</span>
    /** defaults to -1 if not set explicitly */
<span class="nc" id="L83">    protected int maxSessionTimeout = -1;</span>
<span class="nc" id="L84">    protected boolean localSessionsEnabled = false;</span>
<span class="nc" id="L85">    protected boolean localSessionsUpgradingEnabled = false;</span>

    protected int initLimit;
    protected int syncLimit;
<span class="nc" id="L89">    protected int electionAlg = 3;</span>
<span class="nc" id="L90">    protected int electionPort = 2182;</span>
<span class="nc" id="L91">    protected boolean quorumListenOnAllIPs = false;</span>

<span class="nc" id="L93">    protected long serverId = UNSET_SERVERID;</span>

<span class="nc" id="L95">    protected QuorumVerifier quorumVerifier = null, lastSeenQuorumVerifier = null;</span>
<span class="nc" id="L96">    protected int snapRetainCount = 3;</span>
<span class="nc" id="L97">    protected int purgeInterval = 0;</span>
<span class="nc" id="L98">    protected boolean syncEnabled = true;</span>

<span class="nc" id="L100">    protected LearnerType peerType = LearnerType.PARTICIPANT;</span>

    /**
     * Configurations for the quorumpeer-to-quorumpeer sasl authentication
     */
<span class="nc" id="L105">    protected boolean quorumServerRequireSasl = false;</span>
<span class="nc" id="L106">    protected boolean quorumLearnerRequireSasl = false;</span>
<span class="nc" id="L107">    protected boolean quorumEnableSasl = false;</span>
<span class="nc" id="L108">    protected String quorumServicePrincipal = QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE;</span>
<span class="nc" id="L109">    protected String quorumLearnerLoginContext = QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT_DFAULT_VALUE;</span>
<span class="nc" id="L110">    protected String quorumServerLoginContext = QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT_DFAULT_VALUE;</span>
    protected int quorumCnxnThreadsSize;

    /**
     * Minimum snapshot retain count.
     * @see org.apache.zookeeper.server.PurgeTxnLog#purge(File, File, int)
     */
<span class="nc" id="L117">    private final int MIN_SNAP_RETAIN_COUNT = 3;</span>

    @SuppressWarnings(&quot;serial&quot;)
    public static class ConfigException extends Exception {
        public ConfigException(String msg) {
<span class="nc" id="L122">            super(msg);</span>
<span class="nc" id="L123">        }</span>
        public ConfigException(String msg, Exception e) {
<span class="nc" id="L125">            super(msg, e);</span>
<span class="nc" id="L126">        }</span>
    }

    /**
     * Parse a ZooKeeper configuration file
     * @param path the patch of the configuration file
     * @throws ConfigException error processing configuration
     */
    public void parse(String path) throws ConfigException {
<span class="nc" id="L135">        LOG.info(&quot;Reading configuration from: &quot; + path);</span>
       
        try {
<span class="nc" id="L138">            File configFile = (new VerifyingFileFactory.Builder(LOG)</span>
<span class="nc" id="L139">                .warnForRelativePath()</span>
<span class="nc" id="L140">                .failForNonExistingPath()</span>
<span class="nc" id="L141">                .build()).create(path);</span>
                
<span class="nc" id="L143">            Properties cfg = new Properties();</span>
<span class="nc" id="L144">            FileInputStream in = new FileInputStream(configFile);</span>
            try {
<span class="nc" id="L146">                cfg.load(in);</span>
<span class="nc" id="L147">                configFileStr = path;</span>
            } finally {
<span class="nc" id="L149">                in.close();</span>
            }
            
<span class="nc" id="L152">            parseProperties(cfg);</span>
<span class="nc" id="L153">        } catch (IOException e) {</span>
<span class="nc" id="L154">            throw new ConfigException(&quot;Error processing &quot; + path, e);</span>
<span class="nc" id="L155">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L156">            throw new ConfigException(&quot;Error processing &quot; + path, e);</span>
<span class="nc" id="L157">        }   </span>
        
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (dynamicConfigFileStr!=null) {</span>
           try {           
<span class="nc" id="L161">               Properties dynamicCfg = new Properties();</span>
<span class="nc" id="L162">               FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr);</span>
               try {
<span class="nc" id="L164">                   dynamicCfg.load(inConfig);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                   if (dynamicCfg.getProperty(&quot;version&quot;) != null) {</span>
<span class="nc" id="L166">                       throw new ConfigException(&quot;dynamic file shouldn't have version inside&quot;);</span>
                   }

<span class="nc" id="L169">                   String version = getVersionFromFilename(dynamicConfigFileStr);</span>
                   // If there isn't any version associated with the filename,
                   // the default version is 0.
<span class="nc bnc" id="L172" title="All 2 branches missed.">                   if (version != null) {</span>
<span class="nc" id="L173">                       dynamicCfg.setProperty(&quot;version&quot;, version);</span>
                   }
               } finally {
<span class="nc" id="L176">                   inConfig.close();</span>
               }
<span class="nc" id="L178">               setupQuorumPeerConfig(dynamicCfg, false);</span>

<span class="nc" id="L180">           } catch (IOException e) {</span>
<span class="nc" id="L181">               throw new ConfigException(&quot;Error processing &quot; + dynamicConfigFileStr, e);</span>
<span class="nc" id="L182">           } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L183">               throw new ConfigException(&quot;Error processing &quot; + dynamicConfigFileStr, e);</span>
<span class="nc" id="L184">           }        </span>
<span class="nc" id="L185">           File nextDynamicConfigFile = new File(configFileStr + nextDynamicConfigFileSuffix);</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">           if (nextDynamicConfigFile.exists()) {</span>
               try {           
<span class="nc" id="L188">                   Properties dynamicConfigNextCfg = new Properties();</span>
<span class="nc" id="L189">                   FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile);       </span>
                   try {
<span class="nc" id="L191">                       dynamicConfigNextCfg.load(inConfigNext);</span>
                   } finally {
<span class="nc" id="L193">                       inConfigNext.close();</span>
                   }
<span class="nc" id="L195">                   boolean isHierarchical = false;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                   for (Entry&lt;Object, Object&gt; entry : dynamicConfigNextCfg.entrySet()) {</span>
<span class="nc" id="L197">                       String key = entry.getKey().toString().trim();  </span>
<span class="nc bnc" id="L198" title="All 4 branches missed.">                       if (key.startsWith(&quot;group&quot;) || key.startsWith(&quot;weight&quot;)) {</span>
<span class="nc" id="L199">                           isHierarchical = true;</span>
<span class="nc" id="L200">                           break;</span>
                       }
<span class="nc" id="L202">                   }</span>
<span class="nc" id="L203">                   lastSeenQuorumVerifier = createQuorumVerifier(dynamicConfigNextCfg, isHierarchical);</span>
<span class="nc" id="L204">               } catch (IOException e) {</span>
<span class="nc" id="L205">                   LOG.warn(&quot;NextQuorumVerifier is initiated to null&quot;);</span>
<span class="nc" id="L206">               }</span>
           }
        }
<span class="nc" id="L209">    }</span>

    // This method gets the version from the end of dynamic file name.
    // For example, &quot;zoo.cfg.dynamic.0&quot; returns initial version &quot;0&quot;.
    // &quot;zoo.cfg.dynamic.1001&quot; returns version of hex number &quot;0x1001&quot;.
    // If a dynamic file name doesn't have any version at the end of file,
    // e.g. &quot;zoo.cfg.dynamic&quot;, it returns null.
    public static String getVersionFromFilename(String filename) {
<span class="nc" id="L217">        int i = filename.lastIndexOf('.');</span>
<span class="nc bnc" id="L218" title="All 4 branches missed.">        if(i &lt; 0 || i &gt;= filename.length())</span>
<span class="nc" id="L219">            return null;</span>

<span class="nc" id="L221">        String hexVersion = filename.substring(i + 1);</span>
        try {
<span class="nc" id="L223">            long version = Long.parseLong(hexVersion, 16);</span>
<span class="nc" id="L224">            return Long.toHexString(version);</span>
<span class="nc" id="L225">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L226">            return null;</span>
        }
    }

    /**
     * Parse config from a Properties.
     * @param zkProp Properties to parse from.
     * @throws IOException
     * @throws ConfigException
     */
    public void parseProperties(Properties zkProp)
    throws IOException, ConfigException {
<span class="nc" id="L238">        int clientPort = 0;</span>
<span class="nc" id="L239">        int secureClientPort = 0;</span>
<span class="nc" id="L240">        String clientPortAddress = null;</span>
<span class="nc" id="L241">        String secureClientPortAddress = null;</span>
<span class="nc" id="L242">        VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        for (Entry&lt;Object, Object&gt; entry : zkProp.entrySet()) {</span>
<span class="nc" id="L244">            String key = entry.getKey().toString().trim();</span>
<span class="nc" id="L245">            String value = entry.getValue().toString().trim();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (key.equals(&quot;dataDir&quot;)) {</span>
<span class="nc" id="L247">                dataDir = vff.create(value);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            } else if (key.equals(&quot;dataLogDir&quot;)) {</span>
<span class="nc" id="L249">                dataLogDir = vff.create(value);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            } else if (key.equals(&quot;clientPort&quot;)) {</span>
<span class="nc" id="L251">                clientPort = Integer.parseInt(value);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">            } else if (key.equals(&quot;localSessionsEnabled&quot;)) {</span>
<span class="nc" id="L253">                localSessionsEnabled = Boolean.parseBoolean(value);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            } else if (key.equals(&quot;localSessionsUpgradingEnabled&quot;)) {</span>
<span class="nc" id="L255">                localSessionsUpgradingEnabled = Boolean.parseBoolean(value);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            } else if (key.equals(&quot;clientPortAddress&quot;)) {</span>
<span class="nc" id="L257">                clientPortAddress = value.trim();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            } else if (key.equals(&quot;secureClientPort&quot;)) {</span>
<span class="nc" id="L259">                secureClientPort = Integer.parseInt(value);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            } else if (key.equals(&quot;secureClientPortAddress&quot;)){</span>
<span class="nc" id="L261">                secureClientPortAddress = value.trim();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">            } else if (key.equals(&quot;tickTime&quot;)) {</span>
<span class="nc" id="L263">                tickTime = Integer.parseInt(value);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            } else if (key.equals(&quot;maxClientCnxns&quot;)) {</span>
<span class="nc" id="L265">                maxClientCnxns = Integer.parseInt(value);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            } else if (key.equals(&quot;minSessionTimeout&quot;)) {</span>
<span class="nc" id="L267">                minSessionTimeout = Integer.parseInt(value);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            } else if (key.equals(&quot;maxSessionTimeout&quot;)) {</span>
<span class="nc" id="L269">                maxSessionTimeout = Integer.parseInt(value);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            } else if (key.equals(&quot;initLimit&quot;)) {</span>
<span class="nc" id="L271">                initLimit = Integer.parseInt(value);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            } else if (key.equals(&quot;syncLimit&quot;)) {</span>
<span class="nc" id="L273">                syncLimit = Integer.parseInt(value);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            } else if (key.equals(&quot;electionAlg&quot;)) {</span>
<span class="nc" id="L275">                electionAlg = Integer.parseInt(value);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            } else if (key.equals(&quot;quorumListenOnAllIPs&quot;)) {</span>
<span class="nc" id="L277">                quorumListenOnAllIPs = Boolean.parseBoolean(value);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            } else if (key.equals(&quot;peerType&quot;)) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                if (value.toLowerCase().equals(&quot;observer&quot;)) {</span>
<span class="nc" id="L280">                    peerType = LearnerType.OBSERVER;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">                } else if (value.toLowerCase().equals(&quot;participant&quot;)) {</span>
<span class="nc" id="L282">                    peerType = LearnerType.PARTICIPANT;</span>
                } else
                {
<span class="nc" id="L285">                    throw new ConfigException(&quot;Unrecognised peertype: &quot; + value);</span>
                }
<span class="nc bnc" id="L287" title="All 2 branches missed.">            } else if (key.equals( &quot;syncEnabled&quot; )) {</span>
<span class="nc" id="L288">                syncEnabled = Boolean.parseBoolean(value);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            } else if (key.equals(&quot;dynamicConfigFile&quot;)){</span>
<span class="nc" id="L290">                dynamicConfigFileStr = value;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">            } else if (key.equals(&quot;autopurge.snapRetainCount&quot;)) {</span>
<span class="nc" id="L292">                snapRetainCount = Integer.parseInt(value);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            } else if (key.equals(&quot;autopurge.purgeInterval&quot;)) {</span>
<span class="nc" id="L294">                purgeInterval = Integer.parseInt(value);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            } else if (key.equals(&quot;standaloneEnabled&quot;)) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                if (value.toLowerCase().equals(&quot;true&quot;)) {</span>
<span class="nc" id="L297">                    setStandaloneEnabled(true);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                } else if (value.toLowerCase().equals(&quot;false&quot;)) {</span>
<span class="nc" id="L299">                    setStandaloneEnabled(false);</span>
                } else {
<span class="nc" id="L301">                    throw new ConfigException(&quot;Invalid option &quot; + value + &quot; for standalone mode. Choose 'true' or 'false.'&quot;);</span>
                }
<span class="nc bnc" id="L303" title="All 2 branches missed.">            } else if (key.equals(&quot;reconfigEnabled&quot;)) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                if (value.toLowerCase().equals(&quot;true&quot;)) {</span>
<span class="nc" id="L305">                    setReconfigEnabled(true);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                } else if (value.toLowerCase().equals(&quot;false&quot;)) {</span>
<span class="nc" id="L307">                    setReconfigEnabled(false);</span>
                } else {
<span class="nc" id="L309">                    throw new ConfigException(&quot;Invalid option &quot; + value + &quot; for reconfigEnabled flag. Choose 'true' or 'false.'&quot;);</span>
                }
<span class="nc bnc" id="L311" title="All 2 branches missed.">            } else if (key.equals(&quot;sslQuorum&quot;)){</span>
<span class="nc" id="L312">                sslQuorum = Boolean.parseBoolean(value);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">            } else if (key.equals(&quot;portUnification&quot;)){</span>
<span class="nc" id="L314">                shouldUsePortUnification = Boolean.parseBoolean(value);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            } else if (key.equals(&quot;sslQuorumReloadCertFiles&quot;)) {</span>
<span class="nc" id="L316">                sslQuorumReloadCertFiles = Boolean.parseBoolean(value);</span>
<span class="nc bnc" id="L317" title="All 8 branches missed.">            } else if ((key.startsWith(&quot;server.&quot;) || key.startsWith(&quot;group&quot;) || key.startsWith(&quot;weight&quot;)) &amp;&amp; zkProp.containsKey(&quot;dynamicConfigFile&quot;)) {</span>
<span class="nc" id="L318">                throw new ConfigException(&quot;parameter: &quot; + key + &quot; must be in a separate dynamic config file&quot;);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            } else if (key.equals(QuorumAuth.QUORUM_SASL_AUTH_ENABLED)) {</span>
<span class="nc" id="L320">                quorumEnableSasl = Boolean.parseBoolean(value);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED)) {</span>
<span class="nc" id="L322">                quorumServerRequireSasl = Boolean.parseBoolean(value);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED)) {</span>
<span class="nc" id="L324">                quorumLearnerRequireSasl = Boolean.parseBoolean(value);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT)) {</span>
<span class="nc" id="L326">                quorumLearnerLoginContext = value;</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">            } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT)) {</span>
<span class="nc" id="L328">                quorumServerLoginContext = value;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            } else if (key.equals(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL)) {</span>
<span class="nc" id="L330">                quorumServicePrincipal = value;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            } else if (key.equals(&quot;quorum.cnxn.threads.size&quot;)) {</span>
<span class="nc" id="L332">                quorumCnxnThreadsSize = Integer.parseInt(value);</span>
            } else {
<span class="nc" id="L334">                System.setProperty(&quot;zookeeper.&quot; + key, value);</span>
            }
<span class="nc" id="L336">        }</span>

<span class="nc bnc" id="L338" title="All 4 branches missed.">        if (!quorumEnableSasl &amp;&amp; quorumServerRequireSasl) {</span>
<span class="nc" id="L339">            throw new IllegalArgumentException(</span>
                    QuorumAuth.QUORUM_SASL_AUTH_ENABLED
                            + &quot; is disabled, so cannot enable &quot;
                            + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);
        }
<span class="nc bnc" id="L344" title="All 4 branches missed.">        if (!quorumEnableSasl &amp;&amp; quorumLearnerRequireSasl) {</span>
<span class="nc" id="L345">            throw new IllegalArgumentException(</span>
                    QuorumAuth.QUORUM_SASL_AUTH_ENABLED
                            + &quot; is disabled, so cannot enable &quot;
                            + QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED);
        }
        // If quorumpeer learner is not auth enabled then self won't be able to
        // join quorum. So this condition is ensuring that the quorumpeer learner
        // is also auth enabled while enabling quorum server require sasl.
<span class="nc bnc" id="L353" title="All 4 branches missed.">        if (!quorumLearnerRequireSasl &amp;&amp; quorumServerRequireSasl) {</span>
<span class="nc" id="L354">            throw new IllegalArgumentException(</span>
                    QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED
                            + &quot; is disabled, so cannot enable &quot;
                            + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);
        }

        // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)
        // PurgeTxnLog.purge(File, File, int) will not allow to purge less
        // than 3.
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (snapRetainCount &lt; MIN_SNAP_RETAIN_COUNT) {</span>
<span class="nc" id="L364">            LOG.warn(&quot;Invalid autopurge.snapRetainCount: &quot; + snapRetainCount</span>
                    + &quot;. Defaulting to &quot; + MIN_SNAP_RETAIN_COUNT);
<span class="nc" id="L366">            snapRetainCount = MIN_SNAP_RETAIN_COUNT;</span>
        }

<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (dataDir == null) {</span>
<span class="nc" id="L370">            throw new IllegalArgumentException(&quot;dataDir is not set&quot;);</span>
        }
<span class="nc bnc" id="L372" title="All 2 branches missed.">        if (dataLogDir == null) {</span>
<span class="nc" id="L373">            dataLogDir = dataDir;</span>
        }

<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (clientPort == 0) {</span>
<span class="nc" id="L377">            LOG.info(&quot;clientPort is not set&quot;);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">            if (clientPortAddress != null) {</span>
<span class="nc" id="L379">                throw new IllegalArgumentException(&quot;clientPortAddress is set but clientPort is not set&quot;);</span>
            }
<span class="nc bnc" id="L381" title="All 2 branches missed.">        } else if (clientPortAddress != null) {</span>
<span class="nc" id="L382">            this.clientPortAddress = new InetSocketAddress(</span>
<span class="nc" id="L383">                    InetAddress.getByName(clientPortAddress), clientPort);</span>
<span class="nc" id="L384">            LOG.info(&quot;clientPortAddress is {}&quot;, formatInetAddr(this.clientPortAddress));</span>
        } else {
<span class="nc" id="L386">            this.clientPortAddress = new InetSocketAddress(clientPort);</span>
<span class="nc" id="L387">            LOG.info(&quot;clientPortAddress is {}&quot;, formatInetAddr(this.clientPortAddress));</span>
        }

<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (secureClientPort == 0) {</span>
<span class="nc" id="L391">            LOG.info(&quot;secureClientPort is not set&quot;);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (secureClientPortAddress != null) {</span>
<span class="nc" id="L393">                throw new IllegalArgumentException(&quot;secureClientPortAddress is set but secureClientPort is not set&quot;);</span>
            }
<span class="nc bnc" id="L395" title="All 2 branches missed.">        } else if (secureClientPortAddress != null) {</span>
<span class="nc" id="L396">            this.secureClientPortAddress = new InetSocketAddress(</span>
<span class="nc" id="L397">                    InetAddress.getByName(secureClientPortAddress), secureClientPort);</span>
<span class="nc" id="L398">            LOG.info(&quot;secureClientPortAddress is {}&quot;, formatInetAddr(this.secureClientPortAddress));</span>
        } else {
<span class="nc" id="L400">            this.secureClientPortAddress = new InetSocketAddress(secureClientPort);</span>
<span class="nc" id="L401">            LOG.info(&quot;secureClientPortAddress is {}&quot;, formatInetAddr(this.secureClientPortAddress));</span>
        }
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (this.secureClientPortAddress != null) {</span>
<span class="nc" id="L404">            configureSSLAuth();</span>
        }

<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (tickTime == 0) {</span>
<span class="nc" id="L408">            throw new IllegalArgumentException(&quot;tickTime is not set&quot;);</span>
        }

<span class="nc bnc" id="L411" title="All 2 branches missed.">        minSessionTimeout = minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        maxSessionTimeout = maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (minSessionTimeout &gt; maxSessionTimeout) {</span>
<span class="nc" id="L415">            throw new IllegalArgumentException(</span>
                    &quot;minSessionTimeout must not be larger than maxSessionTimeout&quot;);
        }          

        // backward compatibility - dynamic configuration in the same file as
        // static configuration params see writeDynamicConfig()
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (dynamicConfigFileStr == null) {</span>
<span class="nc" id="L422">            setupQuorumPeerConfig(zkProp, true);</span>
<span class="nc bnc" id="L423" title="All 4 branches missed.">            if (isDistributed() &amp;&amp; isReconfigEnabled()) {</span>
                // we don't backup static config for standalone mode.
                // we also don't backup if reconfig feature is disabled.
<span class="nc" id="L426">                backupOldConfig();</span>
            }
        }
<span class="nc" id="L429">    }</span>

    /**
     * Configure SSL authentication only if it is not configured.
     * 
     * @throws ConfigException
     *             If authentication scheme is configured but authentication
     *             provider is not configured.
     */
    public static void configureSSLAuth() throws ConfigException {
<span class="nc" id="L439">        try (ClientX509Util clientX509Util = new ClientX509Util()) {</span>
<span class="nc" id="L440">            String sslAuthProp = &quot;zookeeper.authProvider.&quot; + System.getProperty(clientX509Util.getSslAuthProviderProperty(), &quot;x509&quot;);</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">            if (System.getProperty(sslAuthProp) == null) {</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">                if (&quot;zookeeper.authProvider.x509&quot;.equals(sslAuthProp)) {</span>
<span class="nc" id="L443">                    System.setProperty(&quot;zookeeper.authProvider.x509&quot;,</span>
                            &quot;org.apache.zookeeper.server.auth.X509AuthenticationProvider&quot;);
                } else {
<span class="nc" id="L446">                    throw new ConfigException(&quot;No auth provider configured for the SSL authentication scheme '&quot;</span>
<span class="nc" id="L447">                            + System.getProperty(clientX509Util.getSslAuthProviderProperty()) + &quot;'.&quot;);</span>
                }
            }
        }
<span class="nc" id="L451">    }</span>

    /**
     * Backward compatibility -- It would backup static config file on bootup
     * if users write dynamic configuration in &quot;zoo.cfg&quot;.
     */
    private void backupOldConfig() throws IOException {
<span class="nc" id="L458">        new AtomicFileWritingIdiom(new File(configFileStr + &quot;.bak&quot;), new OutputStreamStatement() {</span>
            @Override
            public void write(OutputStream output) throws IOException {
<span class="nc" id="L461">                InputStream input = null;</span>
                try {
<span class="nc" id="L463">                    input = new FileInputStream(new File(configFileStr));</span>
<span class="nc" id="L464">                    byte[] buf = new byte[1024];</span>
                    int bytesRead;
<span class="nc bnc" id="L466" title="All 2 branches missed.">                    while ((bytesRead = input.read(buf)) &gt; 0) {</span>
<span class="nc" id="L467">                        output.write(buf, 0, bytesRead);</span>
                    }
                } finally {
<span class="nc bnc" id="L470" title="All 2 branches missed.">                    if( input != null) {</span>
<span class="nc" id="L471">                        input.close();</span>
                    }
                }
<span class="nc" id="L474">            }</span>
        });
<span class="nc" id="L476">    }</span>

    /**
     * Writes dynamic configuration file
     */
    public static void writeDynamicConfig(final String dynamicConfigFilename,
                                          final QuorumVerifier qv,
                                          final boolean needKeepVersion)
            throws IOException {

<span class="nc" id="L486">        new AtomicFileWritingIdiom(new File(dynamicConfigFilename), new WriterStatement() {</span>
            @Override
            public void write(Writer out) throws IOException {
<span class="nc" id="L489">                Properties cfg = new Properties();</span>
<span class="nc" id="L490">                cfg.load( new StringReader(</span>
<span class="nc" id="L491">                        qv.toString()));</span>

<span class="nc" id="L493">                List&lt;String&gt; servers = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                for (Entry&lt;Object, Object&gt; entry : cfg.entrySet()) {</span>
<span class="nc" id="L495">                    String key = entry.getKey().toString().trim();</span>
<span class="nc bnc" id="L496" title="All 4 branches missed.">                    if ( !needKeepVersion &amp;&amp; key.startsWith(&quot;version&quot;))</span>
<span class="nc" id="L497">                        continue;</span>

<span class="nc" id="L499">                    String value = entry.getValue().toString().trim();</span>
<span class="nc" id="L500">                    servers.add(key</span>
<span class="nc" id="L501">                            .concat(&quot;=&quot;)</span>
<span class="nc" id="L502">                            .concat(value));</span>
<span class="nc" id="L503">                }</span>

<span class="nc" id="L505">                Collections.sort(servers);</span>
<span class="nc" id="L506">                out.write(StringUtils.joinStrings(servers, &quot;\n&quot;));</span>
<span class="nc" id="L507">            }</span>
        });
<span class="nc" id="L509">    }</span>

    /**
     * Edit static config file.
     * If there are quorum information in static file, e.g. &quot;server.X&quot;, &quot;group&quot;,
     * it will remove them.
     * If it needs to erase client port information left by the old config,
     * &quot;eraseClientPortAddress&quot; should be set true.
     * It should also updates dynamic file pointer on reconfig.
     */
    public static void editStaticConfig(final String configFileStr,
                                        final String dynamicFileStr,
                                        final boolean eraseClientPortAddress)
            throws IOException {
        // Some tests may not have a static config file.
<span class="nc bnc" id="L524" title="All 2 branches missed.">        if (configFileStr == null)</span>
<span class="nc" id="L525">            return;</span>

<span class="nc" id="L527">        File configFile = (new VerifyingFileFactory.Builder(LOG)</span>
<span class="nc" id="L528">                .warnForRelativePath()</span>
<span class="nc" id="L529">                .failForNonExistingPath()</span>
<span class="nc" id="L530">                .build()).create(configFileStr);</span>

<span class="nc" id="L532">        final File dynamicFile = (new VerifyingFileFactory.Builder(LOG)</span>
<span class="nc" id="L533">                .warnForRelativePath()</span>
<span class="nc" id="L534">                .failForNonExistingPath()</span>
<span class="nc" id="L535">                .build()).create(dynamicFileStr);</span>
        
<span class="nc" id="L537">        final Properties cfg = new Properties();</span>
<span class="nc" id="L538">        FileInputStream in = new FileInputStream(configFile);</span>
        try {
<span class="nc" id="L540">            cfg.load(in);</span>
        } finally {
<span class="nc" id="L542">            in.close();</span>
        }

<span class="nc" id="L545">        new AtomicFileWritingIdiom(new File(configFileStr), new WriterStatement() {</span>
            @Override
            public void write(Writer out) throws IOException {
<span class="nc bnc" id="L548" title="All 2 branches missed.">                for (Entry&lt;Object, Object&gt; entry : cfg.entrySet()) {</span>
<span class="nc" id="L549">                    String key = entry.getKey().toString().trim();</span>

<span class="nc bnc" id="L551" title="All 2 branches missed.">                    if (key.startsWith(&quot;server.&quot;)</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                        || key.startsWith(&quot;group&quot;)</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                        || key.startsWith(&quot;weight&quot;)</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">                        || key.startsWith(&quot;dynamicConfigFile&quot;)</span>
                        || (eraseClientPortAddress
<span class="nc bnc" id="L556" title="All 2 branches missed.">                            &amp;&amp; (key.startsWith(&quot;clientPort&quot;)</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                                || key.startsWith(&quot;clientPortAddress&quot;)))) {</span>
                        // not writing them back to static file
<span class="nc" id="L559">                        continue;</span>
                    }

<span class="nc" id="L562">                    String value = entry.getValue().toString().trim();</span>
<span class="nc" id="L563">                    out.write(key.concat(&quot;=&quot;).concat(value).concat(&quot;\n&quot;));</span>
<span class="nc" id="L564">                }</span>

                // updates the dynamic file pointer
<span class="nc" id="L567">                String dynamicConfigFilePath = PathUtils.normalizeFileSystemPath(dynamicFile.getCanonicalPath());</span>
<span class="nc" id="L568">                out.write(&quot;dynamicConfigFile=&quot;</span>
<span class="nc" id="L569">                         .concat(dynamicConfigFilePath)</span>
<span class="nc" id="L570">                         .concat(&quot;\n&quot;));</span>
<span class="nc" id="L571">            }</span>
        });
<span class="nc" id="L573">    }</span>


    public static void deleteFile(String filename){
<span class="nc bnc" id="L577" title="All 2 branches missed.">       if (filename == null) return;</span>
<span class="nc" id="L578">       File f = new File(filename);</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">       if (f.exists()) {</span>
           try{ 
<span class="nc" id="L581">               f.delete();</span>
<span class="nc" id="L582">           } catch (Exception e) {</span>
<span class="nc" id="L583">               LOG.warn(&quot;deleting &quot; + filename + &quot; failed&quot;);</span>
<span class="nc" id="L584">           }</span>
       }                   
<span class="nc" id="L586">    }</span>
    
    
    private static QuorumVerifier createQuorumVerifier(Properties dynamicConfigProp, boolean isHierarchical) throws ConfigException{
<span class="nc bnc" id="L590" title="All 2 branches missed.">       if(isHierarchical){</span>
<span class="nc" id="L591">            return new QuorumHierarchical(dynamicConfigProp);</span>
        } else {
           /*
             * The default QuorumVerifier is QuorumMaj
             */        
            //LOG.info(&quot;Defaulting to majority quorums&quot;);
<span class="nc" id="L597">            return new QuorumMaj(dynamicConfigProp);            </span>
        }          
    }

    void setupQuorumPeerConfig(Properties prop, boolean configBackwardCompatibilityMode)
            throws IOException, ConfigException {
<span class="nc" id="L603">        quorumVerifier = parseDynamicConfig(prop, electionAlg, true, configBackwardCompatibilityMode);</span>
<span class="nc" id="L604">        setupMyId();</span>
<span class="nc" id="L605">        setupClientPort();</span>
<span class="nc" id="L606">        setupPeerType();</span>
<span class="nc" id="L607">        checkValidity();</span>
<span class="nc" id="L608">    }</span>

    /**
     * Parse dynamic configuration file and return
     * quorumVerifier for new configuration.
     * @param dynamicConfigProp Properties to parse from.
     * @throws IOException
     * @throws ConfigException
     */
    public static QuorumVerifier parseDynamicConfig(Properties dynamicConfigProp, int eAlg, boolean warnings,
	   boolean configBackwardCompatibilityMode) throws IOException, ConfigException {
<span class="nc" id="L619">       boolean isHierarchical = false;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">        for (Entry&lt;Object, Object&gt; entry : dynamicConfigProp.entrySet()) {</span>
<span class="nc" id="L621">            String key = entry.getKey().toString().trim();                    </span>
<span class="nc bnc" id="L622" title="All 4 branches missed.">            if (key.startsWith(&quot;group&quot;) || key.startsWith(&quot;weight&quot;)) {</span>
<span class="nc" id="L623">               isHierarchical = true;</span>
<span class="nc bnc" id="L624" title="All 6 branches missed.">            } else if (!configBackwardCompatibilityMode &amp;&amp; !key.startsWith(&quot;server.&quot;) &amp;&amp; !key.equals(&quot;version&quot;)){ </span>
<span class="nc" id="L625">               LOG.info(dynamicConfigProp.toString());</span>
<span class="nc" id="L626">               throw new ConfigException(&quot;Unrecognised parameter: &quot; + key);                </span>
            }
<span class="nc" id="L628">        }</span>
        
<span class="nc" id="L630">        QuorumVerifier qv = createQuorumVerifier(dynamicConfigProp, isHierarchical);</span>
               
<span class="nc" id="L632">        int numParticipators = qv.getVotingMembers().size();</span>
<span class="nc" id="L633">        int numObservers = qv.getObservingMembers().size();</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">        if (numParticipators == 0) {</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">            if (!standaloneEnabled) {</span>
<span class="nc" id="L636">                throw new IllegalArgumentException(&quot;standaloneEnabled = false then &quot; +</span>
                        &quot;number of participants should be &gt;0&quot;);
            }
<span class="nc bnc" id="L639" title="All 2 branches missed.">            if (numObservers &gt; 0) {</span>
<span class="nc" id="L640">                throw new IllegalArgumentException(&quot;Observers w/o participants is an invalid configuration&quot;);</span>
            }
<span class="nc bnc" id="L642" title="All 4 branches missed.">        } else if (numParticipators == 1 &amp;&amp; standaloneEnabled) {</span>
            // HBase currently adds a single server line to the config, for
            // b/w compatibility reasons we need to keep this here. If standaloneEnabled
            // is true, the QuorumPeerMain script will create a standalone server instead
            // of a quorum configuration
<span class="nc" id="L647">            LOG.error(&quot;Invalid configuration, only one server specified (ignoring)&quot;);</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">            if (numObservers &gt; 0) {</span>
<span class="nc" id="L649">                throw new IllegalArgumentException(&quot;Observers w/o quorum is an invalid configuration&quot;);</span>
            }
        } else {
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (warnings) {</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                if (numParticipators &lt;= 2) {</span>
<span class="nc" id="L654">                    LOG.warn(&quot;No server failure will be tolerated. &quot; +</span>
                        &quot;You need at least 3 servers.&quot;);
<span class="nc bnc" id="L656" title="All 2 branches missed.">                } else if (numParticipators % 2 == 0) {</span>
<span class="nc" id="L657">                    LOG.warn(&quot;Non-optimial configuration, consider an odd number of servers.&quot;);</span>
                }
            }
            /*
             * If using FLE, then every server requires a separate election
             * port.
             */            
<span class="nc bnc" id="L664" title="All 2 branches missed.">           if (eAlg != 0) {</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">               for (QuorumServer s : qv.getVotingMembers().values()) {</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                   if (s.electionAddr == null)</span>
<span class="nc" id="L667">                       throw new IllegalArgumentException(</span>
                               &quot;Missing election port for server: &quot; + s.id);
<span class="nc" id="L669">               }</span>
           }   
        }
<span class="nc" id="L672">        return qv;</span>
    }

    private void setupMyId() throws IOException {
<span class="nc" id="L676">        File myIdFile = new File(dataDir, &quot;myid&quot;);</span>
        // standalone server doesn't need myid file.
<span class="nc bnc" id="L678" title="All 2 branches missed.">        if (!myIdFile.isFile()) {</span>
<span class="nc" id="L679">            return;</span>
        }
<span class="nc" id="L681">        BufferedReader br = new BufferedReader(new FileReader(myIdFile));</span>
        String myIdString;
        try {
<span class="nc" id="L684">            myIdString = br.readLine();</span>
        } finally {
<span class="nc" id="L686">            br.close();</span>
        }
        try {
<span class="nc" id="L689">            serverId = Long.parseLong(myIdString);</span>
<span class="nc" id="L690">            MDC.put(&quot;myid&quot;, myIdString);</span>
<span class="nc" id="L691">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L692">            throw new IllegalArgumentException(&quot;serverid &quot; + myIdString</span>
                    + &quot; is not a number&quot;);
<span class="nc" id="L694">        }</span>
<span class="nc" id="L695">    }</span>

    private void setupClientPort() throws ConfigException {
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (serverId == UNSET_SERVERID) {</span>
<span class="nc" id="L699">            return;</span>
        }
<span class="nc" id="L701">        QuorumServer qs = quorumVerifier.getAllMembers().get(serverId);</span>
<span class="nc bnc" id="L702" title="All 6 branches missed.">        if (clientPortAddress != null &amp;&amp; qs != null &amp;&amp; qs.clientAddr != null) {</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">            if ((!clientPortAddress.getAddress().isAnyLocalAddress()</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                    &amp;&amp; !clientPortAddress.equals(qs.clientAddr)) ||</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                    (clientPortAddress.getAddress().isAnyLocalAddress()</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                            &amp;&amp; clientPortAddress.getPort() != qs.clientAddr.getPort()))</span>
<span class="nc" id="L707">                throw new ConfigException(&quot;client address for this server (id = &quot; + serverId +</span>
                        &quot;) in static config file is &quot; + clientPortAddress +
                        &quot; is different from client address found in dynamic file: &quot; + qs.clientAddr);
        }
<span class="nc bnc" id="L711" title="All 4 branches missed.">        if (qs != null &amp;&amp; qs.clientAddr != null) clientPortAddress = qs.clientAddr;</span>
<span class="nc" id="L712">    }</span>

    private void setupPeerType() {
        // Warn about inconsistent peer type
<span class="nc bnc" id="L716" title="All 2 branches missed.">        LearnerType roleByServersList = quorumVerifier.getObservingMembers().containsKey(serverId) ? LearnerType.OBSERVER</span>
<span class="nc" id="L717">                : LearnerType.PARTICIPANT;</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">        if (roleByServersList != peerType) {</span>
<span class="nc" id="L719">            LOG.warn(&quot;Peer type from servers list (&quot; + roleByServersList</span>
                    + &quot;) doesn't match peerType (&quot; + peerType
                    + &quot;). Defaulting to servers list.&quot;);

<span class="nc" id="L723">            peerType = roleByServersList;</span>
        }
<span class="nc" id="L725">    }</span>

    public void checkValidity() throws IOException, ConfigException{
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (isDistributed()) {</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">            if (initLimit == 0) {</span>
<span class="nc" id="L730">                throw new IllegalArgumentException(&quot;initLimit is not set&quot;);</span>
            }
<span class="nc bnc" id="L732" title="All 2 branches missed.">            if (syncLimit == 0) {</span>
<span class="nc" id="L733">                throw new IllegalArgumentException(&quot;syncLimit is not set&quot;);</span>
            }
<span class="nc bnc" id="L735" title="All 2 branches missed.">            if (serverId == UNSET_SERVERID) {</span>
<span class="nc" id="L736">                throw new IllegalArgumentException(&quot;myid file is missing&quot;);</span>
            }
       }
<span class="nc" id="L739">    }</span>

<span class="nc" id="L741">    public InetSocketAddress getClientPortAddress() { return clientPortAddress; }</span>
<span class="nc" id="L742">    public InetSocketAddress getSecureClientPortAddress() { return secureClientPortAddress; }</span>
<span class="nc" id="L743">    public File getDataDir() { return dataDir; }</span>
<span class="nc" id="L744">    public File getDataLogDir() { return dataLogDir; }</span>
<span class="nc" id="L745">    public int getTickTime() { return tickTime; }</span>
<span class="nc" id="L746">    public int getMaxClientCnxns() { return maxClientCnxns; }</span>
<span class="nc" id="L747">    public int getMinSessionTimeout() { return minSessionTimeout; }</span>
<span class="nc" id="L748">    public int getMaxSessionTimeout() { return maxSessionTimeout; }</span>
<span class="nc" id="L749">    public boolean areLocalSessionsEnabled() { return localSessionsEnabled; }</span>
    public boolean isLocalSessionsUpgradingEnabled() {
<span class="nc" id="L751">        return localSessionsUpgradingEnabled;</span>
    }
    public boolean isSslQuorum() {
<span class="nc" id="L754">        return sslQuorum;</span>
    }

    public boolean shouldUsePortUnification() {
<span class="nc" id="L758">        return shouldUsePortUnification;</span>
    }

<span class="nc" id="L761">    public int getInitLimit() { return initLimit; }</span>
<span class="nc" id="L762">    public int getSyncLimit() { return syncLimit; }</span>
<span class="nc" id="L763">    public int getElectionAlg() { return electionAlg; }</span>
<span class="nc" id="L764">    public int getElectionPort() { return electionPort; }</span>

    public int getSnapRetainCount() {
<span class="nc" id="L767">        return snapRetainCount;</span>
    }

    public int getPurgeInterval() {
<span class="nc" id="L771">        return purgeInterval;</span>
    }
    
    public boolean getSyncEnabled() {
<span class="nc" id="L775">        return syncEnabled;</span>
    }

    public QuorumVerifier getQuorumVerifier() {
<span class="nc" id="L779">        return quorumVerifier;</span>
    }
    
    public QuorumVerifier getLastSeenQuorumVerifier() {   
<span class="nc" id="L783">        return lastSeenQuorumVerifier;</span>
    }

    public Map&lt;Long,QuorumServer&gt; getServers() {
        // returns all configuration servers -- participants and observers
<span class="nc" id="L788">        return Collections.unmodifiableMap(quorumVerifier.getAllMembers());</span>
    }

<span class="nc" id="L791">    public long getServerId() { return serverId; }</span>

    public boolean isDistributed() {
<span class="nc bnc" id="L794" title="All 6 branches missed.">        return quorumVerifier!=null &amp;&amp; (!standaloneEnabled || quorumVerifier.getVotingMembers().size() &gt; 1);</span>
    }

    public LearnerType getPeerType() {
<span class="nc" id="L798">        return peerType;</span>
    }

    public String getConfigFilename(){
<span class="nc" id="L802">        return configFileStr;</span>
    }
    
    public Boolean getQuorumListenOnAllIPs() {
<span class="nc" id="L806">        return quorumListenOnAllIPs;</span>
    }
 
    public static boolean isStandaloneEnabled() {
<span class="nc" id="L810">	return standaloneEnabled;</span>
    }
    
    public static void setStandaloneEnabled(boolean enabled) {
<span class="nc" id="L814">        standaloneEnabled = enabled;</span>
<span class="nc" id="L815">    }</span>

<span class="nc" id="L817">    public static boolean isReconfigEnabled() { return reconfigEnabled; }</span>

    public static void setReconfigEnabled(boolean enabled) {
<span class="nc" id="L820">        reconfigEnabled = enabled;</span>
<span class="nc" id="L821">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>