<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PrepRequestProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">parent$MyZookeeperRemoveWatchesTest.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">PrepRequestProcessor.java</span></div><h1>PrepRequestProcessor.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import org.apache.jute.BinaryOutputArchive;
import org.apache.jute.Record;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.KeeperException.BadArgumentsException;
import org.apache.zookeeper.KeeperException.Code;
import org.apache.zookeeper.MultiTransactionRecord;
import org.apache.zookeeper.Op;
import org.apache.zookeeper.ZooDefs;
import org.apache.zookeeper.ZooDefs.OpCode;
import org.apache.zookeeper.common.PathUtils;
import org.apache.zookeeper.common.StringUtils;
import org.apache.zookeeper.common.Time;
import org.apache.zookeeper.data.ACL;
import org.apache.zookeeper.data.Id;
import org.apache.zookeeper.data.StatPersisted;
import org.apache.zookeeper.proto.CheckVersionRequest;
import org.apache.zookeeper.proto.CreateRequest;
import org.apache.zookeeper.proto.CreateTTLRequest;
import org.apache.zookeeper.proto.DeleteRequest;
import org.apache.zookeeper.proto.ReconfigRequest;
import org.apache.zookeeper.proto.SetACLRequest;
import org.apache.zookeeper.proto.SetDataRequest;
import org.apache.zookeeper.server.ZooKeeperServer.ChangeRecord;
import org.apache.zookeeper.server.auth.AuthenticationProvider;
import org.apache.zookeeper.server.auth.ProviderRegistry;
import org.apache.zookeeper.server.quorum.Leader.XidRolloverException;
import org.apache.zookeeper.server.quorum.LeaderZooKeeperServer;
import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
import org.apache.zookeeper.server.quorum.QuorumPeerConfig;
import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
import org.apache.zookeeper.txn.CheckVersionTxn;
import org.apache.zookeeper.txn.CreateContainerTxn;
import org.apache.zookeeper.txn.CreateSessionTxn;
import org.apache.zookeeper.txn.CreateTTLTxn;
import org.apache.zookeeper.txn.CreateTxn;
import org.apache.zookeeper.txn.DeleteTxn;
import org.apache.zookeeper.txn.ErrorTxn;
import org.apache.zookeeper.txn.MultiTxn;
import org.apache.zookeeper.txn.SetACLTxn;
import org.apache.zookeeper.txn.SetDataTxn;
import org.apache.zookeeper.txn.Txn;
import org.apache.zookeeper.txn.TxnHeader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.StringReader;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * This request processor is generally at the start of a RequestProcessor
 * change. It sets up any transactions associated with requests that change the
 * state of the system. It counts on ZooKeeperServer to update
 * outstandingRequests, so that it can take into account transactions that are
 * in the queue to be applied when generating a transaction.
 */
public class PrepRequestProcessor extends ZooKeeperCriticalThread implements
        RequestProcessor {
<span class="fc" id="L93">    private static final Logger LOG = LoggerFactory.getLogger(PrepRequestProcessor.class);</span>

    static boolean skipACL;
    static {
<span class="fc" id="L97">        skipACL = System.getProperty(&quot;zookeeper.skipACL&quot;, &quot;no&quot;).equals(&quot;yes&quot;);</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (skipACL) {</span>
<span class="nc" id="L99">            LOG.info(&quot;zookeeper.skipACL==\&quot;yes\&quot;, ACL checks will be skipped&quot;);</span>
        }
    }

    /**
     * this is only for testing purposes.
     * should never be used otherwise
     */
<span class="fc" id="L107">    private static  boolean failCreate = false;</span>

<span class="fc" id="L109">    LinkedBlockingQueue&lt;Request&gt; submittedRequests = new LinkedBlockingQueue&lt;Request&gt;();</span>

    private final RequestProcessor nextProcessor;

    ZooKeeperServer zks;

    public PrepRequestProcessor(ZooKeeperServer zks,
            RequestProcessor nextProcessor) {
<span class="fc" id="L117">        super(&quot;ProcessThread(sid:&quot; + zks.getServerId() + &quot; cport:&quot;</span>
<span class="fc" id="L118">                + zks.getClientPort() + &quot;):&quot;, zks.getZooKeeperServerListener());</span>
<span class="fc" id="L119">        this.nextProcessor = nextProcessor;</span>
<span class="fc" id="L120">        this.zks = zks;</span>
<span class="fc" id="L121">    }</span>

    /**
     * method for tests to set failCreate
     * @param b
     */
    public static void setFailCreate(boolean b) {
<span class="nc" id="L128">        failCreate = b;</span>
<span class="nc" id="L129">    }</span>
    @Override
    public void run() {
        try {
            while (true) {
<span class="fc" id="L134">                Request request = submittedRequests.take();</span>
<span class="fc" id="L135">                long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">                if (request.type == OpCode.ping) {</span>
<span class="nc" id="L137">                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span>
                }
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">                if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L140">                    ZooTrace.logRequest(LOG, traceMask, 'P', request, &quot;&quot;);</span>
                }
<span class="fc bfc" id="L142" title="All 2 branches covered.">                if (Request.requestOfDeath == request) {</span>
<span class="fc" id="L143">                    break;</span>
                }
<span class="fc" id="L145">                pRequest(request);</span>
<span class="fc" id="L146">            }</span>
<span class="nc" id="L147">        } catch (RequestProcessorException e) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (e.getCause() instanceof XidRolloverException) {</span>
<span class="nc" id="L149">                LOG.info(e.getCause().getMessage());</span>
            }
<span class="nc" id="L151">            handleException(this.getName(), e);</span>
<span class="nc" id="L152">        } catch (Exception e) {</span>
<span class="nc" id="L153">            handleException(this.getName(), e);</span>
<span class="pc" id="L154">        }</span>
<span class="fc" id="L155">        LOG.info(&quot;PrepRequestProcessor exited loop!&quot;);</span>
<span class="fc" id="L156">    }</span>

    private ChangeRecord getRecordForPath(String path) throws KeeperException.NoNodeException {
<span class="nc" id="L159">        ChangeRecord lastChange = null;</span>
<span class="nc" id="L160">        synchronized (zks.outstandingChanges) {</span>
<span class="nc" id="L161">            lastChange = zks.outstandingChangesForPath.get(path);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (lastChange == null) {</span>
<span class="nc" id="L163">                DataNode n = zks.getZKDatabase().getNode(path);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">                if (n != null) {</span>
                    Set&lt;String&gt; children;
<span class="nc" id="L166">                    synchronized(n) {</span>
<span class="nc" id="L167">                        children = n.getChildren();</span>
<span class="nc" id="L168">                    }</span>
<span class="nc" id="L169">                    lastChange = new ChangeRecord(-1, path, n.stat, children.size(),</span>
<span class="nc" id="L170">                            zks.getZKDatabase().aclForNode(n));</span>
                }
            }
<span class="nc" id="L173">        }</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">        if (lastChange == null || lastChange.stat == null) {</span>
<span class="nc" id="L175">            throw new KeeperException.NoNodeException(path);</span>
        }
<span class="nc" id="L177">        return lastChange;</span>
    }

    private ChangeRecord getOutstandingChange(String path) {
<span class="nc" id="L181">        synchronized (zks.outstandingChanges) {</span>
<span class="nc" id="L182">            return zks.outstandingChangesForPath.get(path);</span>
        }
    }

    private void addChangeRecord(ChangeRecord c) {
<span class="nc" id="L187">        synchronized (zks.outstandingChanges) {</span>
<span class="nc" id="L188">            zks.outstandingChanges.add(c);</span>
<span class="nc" id="L189">            zks.outstandingChangesForPath.put(c.path, c);</span>
<span class="nc" id="L190">        }</span>
<span class="nc" id="L191">    }</span>

    /**
     * Grab current pending change records for each op in a multi-op.
     *
     * This is used inside MultiOp error code path to rollback in the event
     * of a failed multi-op.
     *
     * @param multiRequest
     * @return a map that contains previously existed records that probably need to be
     *         rolled back in any failure.
     */
    private Map&lt;String, ChangeRecord&gt; getPendingChanges(MultiTransactionRecord multiRequest) {
<span class="nc" id="L204">        HashMap&lt;String, ChangeRecord&gt; pendingChangeRecords = new HashMap&lt;String, ChangeRecord&gt;();</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">        for (Op op : multiRequest) {</span>
<span class="nc" id="L207">            String path = op.getPath();</span>
<span class="nc" id="L208">            ChangeRecord cr = getOutstandingChange(path);</span>
            // only previously existing records need to be rolled back.
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (cr != null) {</span>
<span class="nc" id="L211">                pendingChangeRecords.put(path, cr);</span>
            }

            /*
             * ZOOKEEPER-1624 - We need to store for parent's ChangeRecord
             * of the parent node of a request. So that if this is a
             * sequential node creation request, rollbackPendingChanges()
             * can restore previous parent's ChangeRecord correctly.
             *
             * Otherwise, sequential node name generation will be incorrect
             * for a subsequent request.
             */
<span class="nc" id="L223">            int lastSlash = path.lastIndexOf('/');</span>
<span class="nc bnc" id="L224" title="All 4 branches missed.">            if (lastSlash == -1 || path.indexOf('\0') != -1) {</span>
<span class="nc" id="L225">                continue;</span>
            }
<span class="nc" id="L227">            String parentPath = path.substring(0, lastSlash);</span>
<span class="nc" id="L228">            ChangeRecord parentCr = getOutstandingChange(parentPath);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if (parentCr != null) {</span>
<span class="nc" id="L230">                pendingChangeRecords.put(parentPath, parentCr);</span>
            }
<span class="nc" id="L232">        }</span>

<span class="nc" id="L234">        return pendingChangeRecords;</span>
    }

    /**
     * Rollback pending changes records from a failed multi-op.
     *
     * If a multi-op fails, we can't leave any invalid change records we created
     * around. We also need to restore their prior value (if any) if their prior
     * value is still valid.
     *
     * @param zxid
     * @param pendingChangeRecords
     */
    void rollbackPendingChanges(long zxid, Map&lt;String, ChangeRecord&gt;pendingChangeRecords) {
<span class="nc" id="L248">        synchronized (zks.outstandingChanges) {</span>
            // Grab a list iterator starting at the END of the list so we can iterate in reverse
<span class="nc" id="L250">            Iterator&lt;ChangeRecord&gt; iter = zks.outstandingChanges.descendingIterator();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L252">                ChangeRecord c = iter.next();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">                if (c.zxid == zxid) {</span>
<span class="nc" id="L254">                    iter.remove();</span>
                    // Remove all outstanding changes for paths of this multi.
                    // Previous records will be added back later.
<span class="nc" id="L257">                    zks.outstandingChangesForPath.remove(c.path);</span>
                } else {
                    break;
                }
<span class="nc" id="L261">            }</span>

            // we don't need to roll back any records because there is nothing left.
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (zks.outstandingChanges.isEmpty()) {</span>
<span class="nc" id="L265">                return;</span>
            }

<span class="nc" id="L268">            long firstZxid = zks.outstandingChanges.peek().zxid;</span>

<span class="nc bnc" id="L270" title="All 2 branches missed.">            for (ChangeRecord c : pendingChangeRecords.values()) {</span>
                // Don't apply any prior change records less than firstZxid.
                // Note that previous outstanding requests might have been removed
                // once they are completed.
<span class="nc bnc" id="L274" title="All 2 branches missed.">                if (c.zxid &lt; firstZxid) {</span>
<span class="nc" id="L275">                    continue;</span>
                }

                // add previously existing records back.
<span class="nc" id="L279">                zks.outstandingChangesForPath.put(c.path, c);</span>
<span class="nc" id="L280">            }</span>
<span class="nc" id="L281">        }</span>
<span class="nc" id="L282">    }</span>

    /**
     * Grant or deny authorization to an operation on a node as a function of:
     *
     * @param zks: not used.
     * @param acl:  set of ACLs for the node
     * @param perm: the permission that the client is requesting
     * @param ids:  the credentials supplied by the client
     */
    static void checkACL(ZooKeeperServer zks, List&lt;ACL&gt; acl, int perm,
            List&lt;Id&gt; ids) throws KeeperException.NoAuthException {
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (skipACL) {</span>
<span class="nc" id="L295">            return;</span>
        }
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L298">            LOG.debug(&quot;Permission requested: {} &quot;, perm);</span>
<span class="nc" id="L299">            LOG.debug(&quot;ACLs for node: {}&quot;, acl);</span>
<span class="nc" id="L300">            LOG.debug(&quot;Client credentials: {}&quot;, ids);</span>
        }
<span class="nc bnc" id="L302" title="All 4 branches missed.">        if (acl == null || acl.size() == 0) {</span>
<span class="nc" id="L303">            return;</span>
        }
<span class="nc bnc" id="L305" title="All 2 branches missed.">        for (Id authId : ids) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (authId.getScheme().equals(&quot;super&quot;)) {</span>
<span class="nc" id="L307">                return;</span>
            }
<span class="nc" id="L309">        }</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        for (ACL a : acl) {</span>
<span class="nc" id="L311">            Id id = a.getId();</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if ((a.getPerms() &amp; perm) != 0) {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">                if (id.getScheme().equals(&quot;world&quot;)</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">                        &amp;&amp; id.getId().equals(&quot;anyone&quot;)) {</span>
<span class="nc" id="L315">                    return;</span>
                }
<span class="nc" id="L317">                AuthenticationProvider ap = ProviderRegistry.getProvider(id</span>
<span class="nc" id="L318">                        .getScheme());</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">                if (ap != null) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">                    for (Id authId : ids) {</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">                        if (authId.getScheme().equals(id.getScheme())</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">                                &amp;&amp; ap.matches(authId.getId(), id.getId())) {</span>
<span class="nc" id="L323">                            return;</span>
                        }
<span class="nc" id="L325">                    }</span>
                }
            }
<span class="nc" id="L328">        }</span>
<span class="nc" id="L329">        throw new KeeperException.NoAuthException();</span>
    }

    /**
     * Performs basic validation of a path for a create request.
     * Throws if the path is not valid and returns the parent path.
     * @throws BadArgumentsException
     */
    private String validatePathForCreate(String path, long sessionId)
            throws BadArgumentsException {
<span class="nc" id="L339">        int lastSlash = path.lastIndexOf('/');</span>
<span class="nc bnc" id="L340" title="All 6 branches missed.">        if (lastSlash == -1 || path.indexOf('\0') != -1 || failCreate) {</span>
<span class="nc" id="L341">            LOG.info(&quot;Invalid path %s with session 0x%s&quot;,</span>
<span class="nc" id="L342">                    path, Long.toHexString(sessionId));</span>
<span class="nc" id="L343">            throw new KeeperException.BadArgumentsException(path);</span>
        }
<span class="nc" id="L345">        return path.substring(0, lastSlash);</span>
    }

    /**
     * This method will be called inside the ProcessRequestThread, which is a
     * singleton, so there will be a single thread calling this code.
     *
     * @param type
     * @param zxid
     * @param request
     * @param record
     */
    protected void pRequest2Txn(int type, long zxid, Request request,
                                Record record, boolean deserialize)
        throws KeeperException, IOException, RequestProcessorException
    {
<span class="fc" id="L361">        request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,</span>
<span class="fc" id="L362">                Time.currentWallTime(), type));</span>

<span class="pc bpc" id="L364" title="8 of 10 branches missed.">        switch (type) {</span>
            case OpCode.create:
            case OpCode.create2:
            case OpCode.createTTL:
            case OpCode.createContainer: {
<span class="nc" id="L369">                pRequest2TxnCreate(type, request, record, deserialize);</span>
<span class="nc" id="L370">                break;</span>
            }
            case OpCode.deleteContainer: {
<span class="nc" id="L373">                String path = new String(request.request.array());</span>
<span class="nc" id="L374">                String parentPath = getParentPathAndValidate(path);</span>
<span class="nc" id="L375">                ChangeRecord parentRecord = getRecordForPath(parentPath);</span>
<span class="nc" id="L376">                ChangeRecord nodeRecord = getRecordForPath(path);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">                if (nodeRecord.childCount &gt; 0) {</span>
<span class="nc" id="L378">                    throw new KeeperException.NotEmptyException(path);</span>
                }
<span class="nc bnc" id="L380" title="All 2 branches missed.">                if (EphemeralType.get(nodeRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL) {</span>
<span class="nc" id="L381">                    throw new KeeperException.BadVersionException(path);</span>
                }
<span class="nc" id="L383">                request.setTxn(new DeleteTxn(path));</span>
<span class="nc" id="L384">                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L385">                parentRecord.childCount--;</span>
<span class="nc" id="L386">                addChangeRecord(parentRecord);</span>
<span class="nc" id="L387">                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));</span>
<span class="nc" id="L388">                break;</span>
            }
            case OpCode.delete:
<span class="nc" id="L391">                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
<span class="nc" id="L392">                DeleteRequest deleteRequest = (DeleteRequest)record;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">                if(deserialize)</span>
<span class="nc" id="L394">                    ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);</span>
<span class="nc" id="L395">                String path = deleteRequest.getPath();</span>
<span class="nc" id="L396">                String parentPath = getParentPathAndValidate(path);</span>
<span class="nc" id="L397">                ChangeRecord parentRecord = getRecordForPath(parentPath);</span>
<span class="nc" id="L398">                ChangeRecord nodeRecord = getRecordForPath(path);</span>
<span class="nc" id="L399">                checkACL(zks, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo);</span>
<span class="nc" id="L400">                checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">                if (nodeRecord.childCount &gt; 0) {</span>
<span class="nc" id="L402">                    throw new KeeperException.NotEmptyException(path);</span>
                }
<span class="nc" id="L404">                request.setTxn(new DeleteTxn(path));</span>
<span class="nc" id="L405">                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L406">                parentRecord.childCount--;</span>
<span class="nc" id="L407">                addChangeRecord(parentRecord);</span>
<span class="nc" id="L408">                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));</span>
<span class="nc" id="L409">                break;</span>
            case OpCode.setData:
<span class="nc" id="L411">                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
<span class="nc" id="L412">                SetDataRequest setDataRequest = (SetDataRequest)record;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if(deserialize)</span>
<span class="nc" id="L414">                    ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);</span>
<span class="nc" id="L415">                path = setDataRequest.getPath();</span>
<span class="nc" id="L416">                validatePath(path, request.sessionId);</span>
<span class="nc" id="L417">                nodeRecord = getRecordForPath(path);</span>
<span class="nc" id="L418">                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);</span>
<span class="nc" id="L419">                int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);</span>
<span class="nc" id="L420">                request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));</span>
<span class="nc" id="L421">                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L422">                nodeRecord.stat.setVersion(newVersion);</span>
<span class="nc" id="L423">                addChangeRecord(nodeRecord);</span>
<span class="nc" id="L424">                break;</span>
            case OpCode.reconfig:
<span class="nc bnc" id="L426" title="All 2 branches missed.">                if (!QuorumPeerConfig.isReconfigEnabled()) {</span>
<span class="nc" id="L427">                    LOG.error(&quot;Reconfig operation requested but reconfig feature is disabled.&quot;);</span>
<span class="nc" id="L428">                    throw new KeeperException.ReconfigDisabledException();</span>
                }

<span class="nc bnc" id="L431" title="All 2 branches missed.">                if (skipACL) {</span>
<span class="nc" id="L432">                    LOG.warn(&quot;skipACL is set, reconfig operation will skip ACL checks!&quot;);</span>
                }

<span class="nc" id="L435">                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
<span class="nc" id="L436">                ReconfigRequest reconfigRequest = (ReconfigRequest)record; </span>
                LeaderZooKeeperServer lzks;
                try {
<span class="nc" id="L439">                    lzks = (LeaderZooKeeperServer)zks;</span>
<span class="nc" id="L440">                } catch (ClassCastException e) {</span>
                    // standalone mode - reconfiguration currently not supported
<span class="nc" id="L442">                    throw new KeeperException.UnimplementedException();</span>
<span class="nc" id="L443">                }</span>
<span class="nc" id="L444">                QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();                                                                                 </span>
                // check that there's no reconfig in progress
<span class="nc bnc" id="L446" title="All 2 branches missed.">                if (lastSeenQV.getVersion()!=lzks.self.getQuorumVerifier().getVersion()) {</span>
<span class="nc" id="L447">                       throw new KeeperException.ReconfigInProgress(); </span>
                }
<span class="nc" id="L449">                long configId = reconfigRequest.getCurConfigId();</span>
  
<span class="nc bnc" id="L451" title="All 4 branches missed.">                if (configId != -1 &amp;&amp; configId!=lzks.self.getLastSeenQuorumVerifier().getVersion()){</span>
<span class="nc" id="L452">                   String msg = &quot;Reconfiguration from version &quot; + configId + &quot; failed -- last seen version is &quot; +</span>
<span class="nc" id="L453">                           lzks.self.getLastSeenQuorumVerifier().getVersion();</span>
<span class="nc" id="L454">                   throw new KeeperException.BadVersionException(msg);</span>
                }

<span class="nc" id="L457">                String newMembers = reconfigRequest.getNewMembers();</span>
                
<span class="nc bnc" id="L459" title="All 2 branches missed.">                if (newMembers != null) { //non-incremental membership change                  </span>
<span class="nc" id="L460">                   LOG.info(&quot;Non-incremental reconfig&quot;);</span>
                
                   // Input may be delimited by either commas or newlines so convert to common newline separated format
<span class="nc" id="L463">                   newMembers = newMembers.replaceAll(&quot;,&quot;, &quot;\n&quot;);</span>
                   
                   try{
<span class="nc" id="L466">                       Properties props = new Properties();                        </span>
<span class="nc" id="L467">                       props.load(new StringReader(newMembers));</span>
<span class="nc" id="L468">                       request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false);</span>
<span class="nc" id="L469">                       request.qv.setVersion(request.getHdr().getZxid());</span>
<span class="nc" id="L470">                   } catch (IOException | ConfigException e) {</span>
<span class="nc" id="L471">                       throw new KeeperException.BadArgumentsException(e.getMessage());</span>
<span class="nc" id="L472">                   }</span>
                } else { //incremental change - must be a majority quorum system   
<span class="nc" id="L474">                   LOG.info(&quot;Incremental reconfig&quot;);</span>
                   
<span class="nc" id="L476">                   List&lt;String&gt; joiningServers = null; </span>
<span class="nc" id="L477">                   String joiningServersString = reconfigRequest.getJoiningServers();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">                   if (joiningServersString != null)</span>
                   {
<span class="nc" id="L480">                       joiningServers = StringUtils.split(joiningServersString,&quot;,&quot;);</span>
                   }
                   
<span class="nc" id="L483">                   List&lt;String&gt; leavingServers = null;</span>
<span class="nc" id="L484">                   String leavingServersString = reconfigRequest.getLeavingServers();</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">                   if (leavingServersString != null)</span>
                   {
<span class="nc" id="L487">                       leavingServers = StringUtils.split(leavingServersString, &quot;,&quot;);</span>
                   }
                   
<span class="nc bnc" id="L490" title="All 2 branches missed.">                   if (!(lastSeenQV instanceof QuorumMaj)) {</span>
<span class="nc" id="L491">                           String msg = &quot;Incremental reconfiguration requested but last configuration seen has a non-majority quorum system&quot;;</span>
<span class="nc" id="L492">                           LOG.warn(msg);</span>
<span class="nc" id="L493">                           throw new KeeperException.BadArgumentsException(msg);               </span>
                   }
<span class="nc" id="L495">                   Map&lt;Long, QuorumServer&gt; nextServers = new HashMap&lt;Long, QuorumServer&gt;(lastSeenQV.getAllMembers());</span>
                   try {                           
<span class="nc bnc" id="L497" title="All 2 branches missed.">                       if (leavingServers != null) {</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                           for (String leaving: leavingServers){</span>
<span class="nc" id="L499">                               long sid = Long.parseLong(leaving);</span>
<span class="nc" id="L500">                               nextServers.remove(sid);</span>
<span class="nc" id="L501">                           } </span>
                       }
<span class="nc bnc" id="L503" title="All 2 branches missed.">                       if (joiningServers != null) {</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                           for (String joiner: joiningServers){</span>
                        	   // joiner should have the following format: server.x = server_spec;client_spec               
<span class="nc" id="L506">                        	   String[] parts = StringUtils.split(joiner, &quot;=&quot;).toArray(new String[0]);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                               if (parts.length != 2) {</span>
<span class="nc" id="L508">                                   throw new KeeperException.BadArgumentsException(&quot;Wrong format of server string&quot;);</span>
                               }
                               // extract server id x from first part of joiner: server.x
<span class="nc" id="L511">                               Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));</span>
<span class="nc" id="L512">                               QuorumServer qs = new QuorumServer(sid, parts[1]);</span>
<span class="nc bnc" id="L513" title="All 6 branches missed.">                               if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {</span>
<span class="nc" id="L514">                                   throw new KeeperException.BadArgumentsException(&quot;Wrong format of server string - each server should have 3 ports specified&quot;); 	   </span>
                               }

                               // check duplication of addresses and ports
<span class="nc bnc" id="L518" title="All 2 branches missed.">                               for (QuorumServer nqs: nextServers.values()) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">                                   if (qs.id == nqs.id) {</span>
<span class="nc" id="L520">                                       continue;</span>
                                   }
<span class="nc" id="L522">                                   qs.checkAddressDuplicate(nqs);</span>
<span class="nc" id="L523">                               }</span>

<span class="nc" id="L525">                               nextServers.remove(qs.id);</span>
<span class="nc" id="L526">                               nextServers.put(qs.id, qs);</span>
<span class="nc" id="L527">                           }  </span>
                       }
<span class="nc" id="L529">                   } catch (ConfigException e){</span>
<span class="nc" id="L530">                       throw new KeeperException.BadArgumentsException(&quot;Reconfiguration failed&quot;);</span>
<span class="nc" id="L531">                   }</span>
<span class="nc" id="L532">                   request.qv = new QuorumMaj(nextServers);</span>
<span class="nc" id="L533">                   request.qv.setVersion(request.getHdr().getZxid());</span>
                }
<span class="nc bnc" id="L535" title="All 4 branches missed.">                if (QuorumPeerConfig.isStandaloneEnabled() &amp;&amp; request.qv.getVotingMembers().size() &lt; 2) {</span>
<span class="nc" id="L536">                   String msg = &quot;Reconfig failed - new configuration must include at least 2 followers&quot;;</span>
<span class="nc" id="L537">                   LOG.warn(msg);</span>
<span class="nc" id="L538">                   throw new KeeperException.BadArgumentsException(msg);</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                } else if (request.qv.getVotingMembers().size() &lt; 1) {</span>
<span class="nc" id="L540">                   String msg = &quot;Reconfig failed - new configuration must include at least 1 follower&quot;;</span>
<span class="nc" id="L541">                   LOG.warn(msg);</span>
<span class="nc" id="L542">                   throw new KeeperException.BadArgumentsException(msg);</span>
                }                           
                   
<span class="nc bnc" id="L545" title="All 2 branches missed.">                if (!lzks.getLeader().isQuorumSynced(request.qv)) {</span>
<span class="nc" id="L546">                   String msg2 = &quot;Reconfig failed - there must be a connected and synced quorum in new configuration&quot;;</span>
<span class="nc" id="L547">                   LOG.warn(msg2);             </span>
<span class="nc" id="L548">                   throw new KeeperException.NewConfigNoQuorum();</span>
                }
                
<span class="nc" id="L551">                nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);               </span>
<span class="nc" id="L552">                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo);                  </span>
<span class="nc" id="L553">                request.setTxn(new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1));    </span>
<span class="nc" id="L554">                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L555">                nodeRecord.stat.setVersion(-1);                </span>
<span class="nc" id="L556">                addChangeRecord(nodeRecord);</span>
<span class="nc" id="L557">                break;                         </span>
            case OpCode.setACL:
<span class="nc" id="L559">                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
<span class="nc" id="L560">                SetACLRequest setAclRequest = (SetACLRequest)record;</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">                if(deserialize)</span>
<span class="nc" id="L562">                    ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);</span>
<span class="nc" id="L563">                path = setAclRequest.getPath();</span>
<span class="nc" id="L564">                validatePath(path, request.sessionId);</span>
<span class="nc" id="L565">                List&lt;ACL&gt; listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());</span>
<span class="nc" id="L566">                nodeRecord = getRecordForPath(path);</span>
<span class="nc" id="L567">                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo);</span>
<span class="nc" id="L568">                newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);</span>
<span class="nc" id="L569">                request.setTxn(new SetACLTxn(path, listACL, newVersion));</span>
<span class="nc" id="L570">                nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L571">                nodeRecord.stat.setAversion(newVersion);</span>
<span class="nc" id="L572">                addChangeRecord(nodeRecord);</span>
<span class="nc" id="L573">                break;</span>
            case OpCode.createSession:
<span class="fc" id="L575">                request.request.rewind();</span>
<span class="fc" id="L576">                int to = request.request.getInt();</span>
<span class="fc" id="L577">                request.setTxn(new CreateSessionTxn(to));</span>
<span class="fc" id="L578">                request.request.rewind();</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">                if (request.isLocalSession()) {</span>
                    // This will add to local session tracker if it is enabled
<span class="nc" id="L581">                    zks.sessionTracker.addSession(request.sessionId, to);</span>
                } else {
                    // Explicitly add to global session if the flag is not set
<span class="fc" id="L584">                    zks.sessionTracker.addGlobalSession(request.sessionId, to);</span>
                }
<span class="fc" id="L586">                zks.setOwner(request.sessionId, request.getOwner());</span>
<span class="fc" id="L587">                break;</span>
            case OpCode.closeSession:
                // We don't want to do this check since the session expiration thread
                // queues up this operation without being the session owner.
                // this request is the last of the session so it should be ok
                //zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
<span class="fc" id="L593">                Set&lt;String&gt; es = zks.getZKDatabase()</span>
<span class="fc" id="L594">                        .getEphemerals(request.sessionId);</span>
<span class="fc" id="L595">                synchronized (zks.outstandingChanges) {</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">                    for (ChangeRecord c : zks.outstandingChanges) {</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">                        if (c.stat == null) {</span>
                            // Doing a delete
<span class="nc" id="L599">                            es.remove(c.path);</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                        } else if (c.stat.getEphemeralOwner() == request.sessionId) {</span>
<span class="nc" id="L601">                            es.add(c.path);</span>
                        }
<span class="nc" id="L603">                    }</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">                    for (String path2Delete : es) {</span>
<span class="nc" id="L605">                        addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));</span>
<span class="nc" id="L606">                    }</span>

<span class="fc" id="L608">                    zks.sessionTracker.setSessionClosing(request.sessionId);</span>
<span class="fc" id="L609">                }</span>
<span class="fc" id="L610">                break;</span>
            case OpCode.check:
<span class="nc" id="L612">                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span>
<span class="nc" id="L613">                CheckVersionRequest checkVersionRequest = (CheckVersionRequest)record;</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                if(deserialize)</span>
<span class="nc" id="L615">                    ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);</span>
<span class="nc" id="L616">                path = checkVersionRequest.getPath();</span>
<span class="nc" id="L617">                validatePath(path, request.sessionId);</span>
<span class="nc" id="L618">                nodeRecord = getRecordForPath(path);</span>
<span class="nc" id="L619">                checkACL(zks, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo);</span>
<span class="nc" id="L620">                request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(),</span>
<span class="nc" id="L621">                        checkVersionRequest.getVersion(), path)));</span>
<span class="nc" id="L622">                break;</span>
            default:
<span class="nc" id="L624">                LOG.warn(&quot;unknown type &quot; + type);</span>
                break;
        }
<span class="fc" id="L627">    }</span>

    private void pRequest2TxnCreate(int type, Request request, Record record, boolean deserialize) throws IOException, KeeperException {
<span class="nc bnc" id="L630" title="All 2 branches missed.">        if (deserialize) {</span>
<span class="nc" id="L631">            ByteBufferInputStream.byteBuffer2Record(request.request, record);</span>
        }

        int flags;
        String path;
        List&lt;ACL&gt; acl;
        byte[] data;
        long ttl;
<span class="nc bnc" id="L639" title="All 2 branches missed.">        if (type == OpCode.createTTL) {</span>
<span class="nc" id="L640">            CreateTTLRequest createTtlRequest = (CreateTTLRequest)record;</span>
<span class="nc" id="L641">            flags = createTtlRequest.getFlags();</span>
<span class="nc" id="L642">            path = createTtlRequest.getPath();</span>
<span class="nc" id="L643">            acl = createTtlRequest.getAcl();</span>
<span class="nc" id="L644">            data = createTtlRequest.getData();</span>
<span class="nc" id="L645">            ttl = createTtlRequest.getTtl();</span>
<span class="nc" id="L646">        } else {</span>
<span class="nc" id="L647">            CreateRequest createRequest = (CreateRequest)record;</span>
<span class="nc" id="L648">            flags = createRequest.getFlags();</span>
<span class="nc" id="L649">            path = createRequest.getPath();</span>
<span class="nc" id="L650">            acl = createRequest.getAcl();</span>
<span class="nc" id="L651">            data = createRequest.getData();</span>
<span class="nc" id="L652">            ttl = -1;</span>
        }
<span class="nc" id="L654">        CreateMode createMode = CreateMode.fromFlag(flags);</span>
<span class="nc" id="L655">        validateCreateRequest(path, createMode, request, ttl);</span>
<span class="nc" id="L656">        String parentPath = validatePathForCreate(path, request.sessionId);</span>

<span class="nc" id="L658">        List&lt;ACL&gt; listACL = fixupACL(path, request.authInfo, acl);</span>
<span class="nc" id="L659">        ChangeRecord parentRecord = getRecordForPath(parentPath);</span>

<span class="nc" id="L661">        checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo);</span>
<span class="nc" id="L662">        int parentCVersion = parentRecord.stat.getCversion();</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (createMode.isSequential()) {</span>
<span class="nc" id="L664">            path = path + String.format(Locale.ENGLISH, &quot;%010d&quot;, parentCVersion);</span>
        }
<span class="nc" id="L666">        validatePath(path, request.sessionId);</span>
        try {
<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (getRecordForPath(path) != null) {</span>
<span class="nc" id="L669">                throw new KeeperException.NodeExistsException(path);</span>
            }
<span class="nc" id="L671">        } catch (KeeperException.NoNodeException e) {</span>
            // ignore this one
<span class="nc" id="L673">        }</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">        boolean ephemeralParent = EphemeralType.get(parentRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL;</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (ephemeralParent) {</span>
<span class="nc" id="L676">            throw new KeeperException.NoChildrenForEphemeralsException(path);</span>
        }
<span class="nc" id="L678">        int newCversion = parentRecord.stat.getCversion()+1;</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (type == OpCode.createContainer) {</span>
<span class="nc" id="L680">            request.setTxn(new CreateContainerTxn(path, data, listACL, newCversion));</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">        } else if (type == OpCode.createTTL) {</span>
<span class="nc" id="L682">            request.setTxn(new CreateTTLTxn(path, data, listACL, newCversion, ttl));</span>
        } else {
<span class="nc" id="L684">            request.setTxn(new CreateTxn(path, data, listACL, createMode.isEphemeral(),</span>
                    newCversion));
        }
<span class="nc" id="L687">        StatPersisted s = new StatPersisted();</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (createMode.isEphemeral()) {</span>
<span class="nc" id="L689">            s.setEphemeralOwner(request.sessionId);</span>
        }
<span class="nc" id="L691">        parentRecord = parentRecord.duplicate(request.getHdr().getZxid());</span>
<span class="nc" id="L692">        parentRecord.childCount++;</span>
<span class="nc" id="L693">        parentRecord.stat.setCversion(newCversion);</span>
<span class="nc" id="L694">        addChangeRecord(parentRecord);</span>
<span class="nc" id="L695">        addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));</span>
<span class="nc" id="L696">    }</span>

    private void validatePath(String path, long sessionId) throws BadArgumentsException {
        try {
<span class="nc" id="L700">            PathUtils.validatePath(path);</span>
<span class="nc" id="L701">        } catch(IllegalArgumentException ie) {</span>
<span class="nc" id="L702">            LOG.info(&quot;Invalid path {} with session 0x{}, reason: {}&quot;,</span>
<span class="nc" id="L703">                    path, Long.toHexString(sessionId), ie.getMessage());</span>
<span class="nc" id="L704">            throw new BadArgumentsException(path);</span>
<span class="nc" id="L705">        }</span>
<span class="nc" id="L706">    }</span>

    private String getParentPathAndValidate(String path)
            throws BadArgumentsException {
<span class="nc" id="L710">        int lastSlash = path.lastIndexOf('/');</span>
<span class="nc bnc" id="L711" title="All 4 branches missed.">        if (lastSlash == -1 || path.indexOf('\0') != -1</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                || zks.getZKDatabase().isSpecialPath(path)) {</span>
<span class="nc" id="L713">            throw new BadArgumentsException(path);</span>
        }
<span class="nc" id="L715">        return path.substring(0, lastSlash);</span>
    }

    private static int checkAndIncVersion(int currentVersion, int expectedVersion, String path)
            throws KeeperException.BadVersionException {
<span class="nc bnc" id="L720" title="All 4 branches missed.">        if (expectedVersion != -1 &amp;&amp; expectedVersion != currentVersion) {</span>
<span class="nc" id="L721">            throw new KeeperException.BadVersionException(path);</span>
        }
<span class="nc" id="L723">        return currentVersion + 1;</span>
    }

    /**
     * This method will be called inside the ProcessRequestThread, which is a
     * singleton, so there will be a single thread calling this code.
     *
     * @param request
     */
    protected void pRequest(Request request) throws RequestProcessorException {
        // LOG.info(&quot;Prep&gt;&gt;&gt; cxid = &quot; + request.cxid + &quot; type = &quot; +
        // request.type + &quot; id = 0x&quot; + Long.toHexString(request.sessionId));
<span class="fc" id="L735">        request.setHdr(null);</span>
<span class="fc" id="L736">        request.setTxn(null);</span>

        try {
<span class="pc bpc" id="L739" title="9 of 11 branches missed.">            switch (request.type) {</span>
            case OpCode.createContainer:
            case OpCode.create:
            case OpCode.create2:
<span class="nc" id="L743">                CreateRequest create2Request = new CreateRequest();</span>
<span class="nc" id="L744">                pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);</span>
<span class="nc" id="L745">                break;</span>
            case OpCode.createTTL:
<span class="nc" id="L747">                CreateTTLRequest createTtlRequest = new CreateTTLRequest();</span>
<span class="nc" id="L748">                pRequest2Txn(request.type, zks.getNextZxid(), request, createTtlRequest, true);</span>
<span class="nc" id="L749">                break;</span>
            case OpCode.deleteContainer:
            case OpCode.delete:
<span class="nc" id="L752">                DeleteRequest deleteRequest = new DeleteRequest();</span>
<span class="nc" id="L753">                pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, true);</span>
<span class="nc" id="L754">                break;</span>
            case OpCode.setData:
<span class="nc" id="L756">                SetDataRequest setDataRequest = new SetDataRequest();                </span>
<span class="nc" id="L757">                pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, true);</span>
<span class="nc" id="L758">                break;</span>
            case OpCode.reconfig:
<span class="nc" id="L760">                ReconfigRequest reconfigRequest = new ReconfigRequest();</span>
<span class="nc" id="L761">                ByteBufferInputStream.byteBuffer2Record(request.request, reconfigRequest);</span>
<span class="nc" id="L762">                pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest, true);</span>
<span class="nc" id="L763">                break;</span>
            case OpCode.setACL:
<span class="nc" id="L765">                SetACLRequest setAclRequest = new SetACLRequest();                </span>
<span class="nc" id="L766">                pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, true);</span>
<span class="nc" id="L767">                break;</span>
            case OpCode.check:
<span class="nc" id="L769">                CheckVersionRequest checkRequest = new CheckVersionRequest();              </span>
<span class="nc" id="L770">                pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, true);</span>
<span class="nc" id="L771">                break;</span>
            case OpCode.multi:
<span class="nc" id="L773">                MultiTransactionRecord multiRequest = new MultiTransactionRecord();</span>
                try {
<span class="nc" id="L775">                    ByteBufferInputStream.byteBuffer2Record(request.request, multiRequest);</span>
<span class="nc" id="L776">                } catch(IOException e) {</span>
<span class="nc" id="L777">                    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(),</span>
<span class="nc" id="L778">                            Time.currentWallTime(), OpCode.multi));</span>
<span class="nc" id="L779">                    throw e;</span>
<span class="nc" id="L780">                }</span>
<span class="nc" id="L781">                List&lt;Txn&gt; txns = new ArrayList&lt;Txn&gt;();</span>
                //Each op in a multi-op must have the same zxid!
<span class="nc" id="L783">                long zxid = zks.getNextZxid();</span>
<span class="nc" id="L784">                KeeperException ke = null;</span>

                //Store off current pending change records in case we need to rollback
<span class="nc" id="L787">                Map&lt;String, ChangeRecord&gt; pendingChanges = getPendingChanges(multiRequest);</span>

<span class="nc bnc" id="L789" title="All 2 branches missed.">                for(Op op: multiRequest) {</span>
<span class="nc" id="L790">                    Record subrequest = op.toRequestRecord();</span>
                    int type;
                    Record txn;

                    /* If we've already failed one of the ops, don't bother
                     * trying the rest as we know it's going to fail and it
                     * would be confusing in the logfiles.
                     */
<span class="nc bnc" id="L798" title="All 2 branches missed.">                    if (ke != null) {</span>
<span class="nc" id="L799">                        type = OpCode.error;</span>
<span class="nc" id="L800">                        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());</span>
                    }

                    /* Prep the request and convert to a Txn */
                    else {
                        try {
<span class="nc" id="L806">                            pRequest2Txn(op.getType(), zxid, request, subrequest, false);</span>
<span class="nc" id="L807">                            type = request.getHdr().getType();</span>
<span class="nc" id="L808">                            txn = request.getTxn();</span>
<span class="nc" id="L809">                        } catch (KeeperException e) {</span>
<span class="nc" id="L810">                            ke = e;</span>
<span class="nc" id="L811">                            type = OpCode.error;</span>
<span class="nc" id="L812">                            txn = new ErrorTxn(e.code().intValue());</span>

<span class="nc bnc" id="L814" title="All 2 branches missed.">                            if (e.code().intValue() &gt; Code.APIERROR.intValue()) {</span>
<span class="nc" id="L815">                                LOG.info(&quot;Got user-level KeeperException when processing {} aborting&quot; +</span>
                                        &quot; remaining multi ops. Error Path:{} Error:{}&quot;,
<span class="nc" id="L817">                                        request.toString(), e.getPath(), e.getMessage());</span>
                            }

<span class="nc" id="L820">                            request.setException(e);</span>

                            /* Rollback change records from failed multi-op */
<span class="nc" id="L823">                            rollbackPendingChanges(zxid, pendingChanges);</span>
<span class="nc" id="L824">                        }</span>
                    }

                    //FIXME: I don't want to have to serialize it here and then
                    //       immediately deserialize in next processor. But I'm
                    //       not sure how else to get the txn stored into our list.
<span class="nc" id="L830">                    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L831">                    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);</span>
<span class="nc" id="L832">                    txn.serialize(boa, &quot;request&quot;) ;</span>
<span class="nc" id="L833">                    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());</span>

<span class="nc" id="L835">                    txns.add(new Txn(type, bb.array()));</span>
<span class="nc" id="L836">                }</span>

<span class="nc" id="L838">                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,</span>
<span class="nc" id="L839">                        Time.currentWallTime(), request.type));</span>
<span class="nc" id="L840">                request.setTxn(new MultiTxn(txns));</span>

<span class="nc" id="L842">                break;</span>

            //create/close session don't require request record
            case OpCode.createSession:
            case OpCode.closeSession:
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">                if (!request.isLocalSession()) {</span>
<span class="fc" id="L848">                    pRequest2Txn(request.type, zks.getNextZxid(), request,</span>
                                 null, true);
                }
                break;

            //All the rest don't need to create a Txn - just verify session
            case OpCode.sync:
            case OpCode.exists:
            case OpCode.getData:
            case OpCode.getACL:
            case OpCode.getChildren:
            case OpCode.getChildren2:
            case OpCode.ping:
            case OpCode.setWatches:
            case OpCode.checkWatches:
            case OpCode.removeWatches:
<span class="fc" id="L864">                zks.sessionTracker.checkSession(request.sessionId,</span>
<span class="fc" id="L865">                        request.getOwner());</span>
<span class="fc" id="L866">                break;</span>
            default:
<span class="nc" id="L868">                LOG.warn(&quot;unknown type &quot; + request.type);</span>
                break;
            }
<span class="nc" id="L871">        } catch (KeeperException e) {</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">            if (request.getHdr() != null) {</span>
<span class="nc" id="L873">                request.getHdr().setType(OpCode.error);</span>
<span class="nc" id="L874">                request.setTxn(new ErrorTxn(e.code().intValue()));</span>
            }

<span class="nc bnc" id="L877" title="All 2 branches missed.">            if (e.code().intValue() &gt; Code.APIERROR.intValue()) {</span>
<span class="nc" id="L878">                LOG.info(&quot;Got user-level KeeperException when processing {} Error Path:{} Error:{}&quot;,</span>
<span class="nc" id="L879">                        request.toString(), e.getPath(), e.getMessage());</span>
            }
<span class="nc" id="L881">            request.setException(e);</span>
<span class="nc" id="L882">        } catch (Exception e) {</span>
            // log at error level as we are returning a marshalling
            // error to the user
<span class="nc" id="L885">            LOG.error(&quot;Failed to process &quot; + request, e);</span>

<span class="nc" id="L887">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L888">            ByteBuffer bb = request.request;</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">            if(bb != null){</span>
<span class="nc" id="L890">                bb.rewind();</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">                while (bb.hasRemaining()) {</span>
<span class="nc" id="L892">                    sb.append(Integer.toHexString(bb.get() &amp; 0xff));</span>
                }
            } else {
<span class="nc" id="L895">                sb.append(&quot;request buffer is null&quot;);</span>
            }

<span class="nc" id="L898">            LOG.error(&quot;Dumping request buffer: 0x&quot; + sb.toString());</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            if (request.getHdr() != null) {</span>
<span class="nc" id="L900">                request.getHdr().setType(OpCode.error);</span>
<span class="nc" id="L901">                request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));</span>
            }
<span class="pc" id="L903">        }</span>
<span class="fc" id="L904">        request.zxid = zks.getZxid();</span>
<span class="fc" id="L905">        nextProcessor.processRequest(request);</span>
<span class="fc" id="L906">    }</span>

    private List&lt;ACL&gt; removeDuplicates(List&lt;ACL&gt; acl) {

<span class="nc" id="L910">        LinkedList&lt;ACL&gt; retval = new LinkedList&lt;ACL&gt;();</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">        for (ACL a : acl) {</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">            if (!retval.contains(a)) {</span>
<span class="nc" id="L913">                retval.add(a);</span>
            }
<span class="nc" id="L915">        }</span>
<span class="nc" id="L916">        return retval;</span>
    }

    private void validateCreateRequest(String path, CreateMode createMode, Request request, long ttl)
            throws KeeperException {
<span class="nc bnc" id="L921" title="All 4 branches missed.">        if (createMode.isTTL() &amp;&amp; !EphemeralType.extendedEphemeralTypesEnabled()) {</span>
<span class="nc" id="L922">            throw new KeeperException.UnimplementedException();</span>
        }
        try {
<span class="nc" id="L925">            EphemeralType.validateTTL(createMode, ttl);</span>
<span class="nc" id="L926">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L927">            throw new BadArgumentsException(path);</span>
<span class="nc" id="L928">        }</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">        if (createMode.isEphemeral()) {</span>
            // Exception is set when local session failed to upgrade
            // so we just need to report the error
<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (request.getException() != null) {</span>
<span class="nc" id="L933">                throw request.getException();</span>
            }
<span class="nc" id="L935">            zks.sessionTracker.checkGlobalSession(request.sessionId,</span>
<span class="nc" id="L936">                    request.getOwner());</span>
        } else {
<span class="nc" id="L938">            zks.sessionTracker.checkSession(request.sessionId,</span>
<span class="nc" id="L939">                    request.getOwner());</span>
        }
<span class="nc" id="L941">    }</span>

    /**
     * This method checks out the acl making sure it isn't null or empty,
     * it has valid schemes and ids, and expanding any relative ids that
     * depend on the requestor's authentication information.
     *
     * @param authInfo list of ACL IDs associated with the client connection
     * @param acls list of ACLs being assigned to the node (create or setACL operation)
     * @return verified and expanded ACLs
     * @throws KeeperException.InvalidACLException
     */
    private List&lt;ACL&gt; fixupACL(String path, List&lt;Id&gt; authInfo, List&lt;ACL&gt; acls)
        throws KeeperException.InvalidACLException {
        // check for well formed ACLs
        // This resolves https://issues.apache.org/jira/browse/ZOOKEEPER-1877
<span class="nc" id="L957">        List&lt;ACL&gt; uniqacls = removeDuplicates(acls);</span>
<span class="nc" id="L958">        LinkedList&lt;ACL&gt; rv = new LinkedList&lt;ACL&gt;();</span>
<span class="nc bnc" id="L959" title="All 4 branches missed.">        if (uniqacls == null || uniqacls.size() == 0) {</span>
<span class="nc" id="L960">            throw new KeeperException.InvalidACLException(path);</span>
        }
<span class="nc bnc" id="L962" title="All 2 branches missed.">        for (ACL a: uniqacls) {</span>
<span class="nc" id="L963">            LOG.debug(&quot;Processing ACL: {}&quot;, a);</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">            if (a == null) {</span>
<span class="nc" id="L965">                throw new KeeperException.InvalidACLException(path);</span>
            }
<span class="nc" id="L967">            Id id = a.getId();</span>
<span class="nc bnc" id="L968" title="All 4 branches missed.">            if (id == null || id.getScheme() == null) {</span>
<span class="nc" id="L969">                throw new KeeperException.InvalidACLException(path);</span>
            }
<span class="nc bnc" id="L971" title="All 4 branches missed.">            if (id.getScheme().equals(&quot;world&quot;) &amp;&amp; id.getId().equals(&quot;anyone&quot;)) {</span>
<span class="nc" id="L972">                rv.add(a);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">            } else if (id.getScheme().equals(&quot;auth&quot;)) {</span>
                // This is the &quot;auth&quot; id, so we have to expand it to the
                // authenticated ids of the requestor
<span class="nc" id="L976">                boolean authIdValid = false;</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">                for (Id cid : authInfo) {</span>
<span class="nc" id="L978">                    AuthenticationProvider ap =</span>
<span class="nc" id="L979">                        ProviderRegistry.getProvider(cid.getScheme());</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">                    if (ap == null) {</span>
<span class="nc" id="L981">                        LOG.error(&quot;Missing AuthenticationProvider for &quot;</span>
<span class="nc" id="L982">                            + cid.getScheme());</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">                    } else if (ap.isAuthenticated()) {</span>
<span class="nc" id="L984">                        authIdValid = true;</span>
<span class="nc" id="L985">                        rv.add(new ACL(a.getPerms(), cid));</span>
                    }
<span class="nc" id="L987">                }</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">                if (!authIdValid) {</span>
<span class="nc" id="L989">                    throw new KeeperException.InvalidACLException(path);</span>
                }
<span class="nc" id="L991">            } else {</span>
<span class="nc" id="L992">                AuthenticationProvider ap = ProviderRegistry.getProvider(id.getScheme());</span>
<span class="nc bnc" id="L993" title="All 4 branches missed.">                if (ap == null || !ap.isValid(id.getId())) {</span>
<span class="nc" id="L994">                    throw new KeeperException.InvalidACLException(path);</span>
                }
<span class="nc" id="L996">                rv.add(a);</span>
            }
<span class="nc" id="L998">        }</span>
<span class="nc" id="L999">        return rv;</span>
    }

    public void processRequest(Request request) {
<span class="fc" id="L1003">        submittedRequests.add(request);</span>
<span class="fc" id="L1004">    }</span>

    public void shutdown() {
<span class="fc" id="L1007">        LOG.info(&quot;Shutting down&quot;);</span>
<span class="fc" id="L1008">        submittedRequests.clear();</span>
<span class="fc" id="L1009">        submittedRequests.add(Request.requestOfDeath);</span>
<span class="fc" id="L1010">        nextProcessor.shutdown();</span>
<span class="fc" id="L1011">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>