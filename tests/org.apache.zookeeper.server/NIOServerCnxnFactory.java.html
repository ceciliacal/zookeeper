<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NIOServerCnxnFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">parent$MyZookeeperRemoveWatchesTest.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">NIOServerCnxnFactory.java</span></div><h1>NIOServerCnxnFactory.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Queue;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * NIOServerCnxnFactory implements a multi-threaded ServerCnxnFactory using
 * NIO non-blocking socket calls. Communication between threads is handled via
 * queues.
 *
 *   - 1   accept thread, which accepts new connections and assigns to a
 *         selector thread
 *   - 1-N selector threads, each of which selects on 1/N of the connections.
 *         The reason the factory supports more than one selector thread is that
 *         with large numbers of connections, select() itself can become a
 *         performance bottleneck.
 *   - 0-M socket I/O worker threads, which perform basic socket reads and
 *         writes. If configured with 0 worker threads, the selector threads
 *         do the socket I/O directly.
 *   - 1   connection expiration thread, which closes idle connections; this is
 *         necessary to expire connections on which no session is established.
 *
 * Typical (default) thread counts are: on a 32 core machine, 1 accept thread,
 * 1 connection expiration thread, 4 selector threads, and 64 worker threads.
 */
public class NIOServerCnxnFactory extends ServerCnxnFactory {
<span class="fc" id="L66">    private static final Logger LOG = LoggerFactory.getLogger(NIOServerCnxnFactory.class);</span>

    /** Default sessionless connection timeout in ms: 10000 (10s) */
    public static final String ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT =
        &quot;zookeeper.nio.sessionlessCnxnTimeout&quot;;
    /**
     * With 500 connections to an observer with watchers firing on each, is
     * unable to exceed 1GigE rates with only 1 selector.
     * Defaults to using 2 selector threads with 8 cores and 4 with 32 cores.
     * Expressed as sqrt(numCores/2). Must have at least 1 selector thread.
     */
    public static final String ZOOKEEPER_NIO_NUM_SELECTOR_THREADS =
        &quot;zookeeper.nio.numSelectorThreads&quot;;
    /** Default: 2 * numCores */
    public static final String ZOOKEEPER_NIO_NUM_WORKER_THREADS =
        &quot;zookeeper.nio.numWorkerThreads&quot;;
    /** Default: 64kB */
    public static final String ZOOKEEPER_NIO_DIRECT_BUFFER_BYTES =
        &quot;zookeeper.nio.directBufferBytes&quot;;
    /** Default worker pool shutdown timeout in ms: 5000 (5s) */
    public static final String ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT =
        &quot;zookeeper.nio.shutdownTimeout&quot;;

    static {
<span class="fc" id="L90">        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {</span>
                public void uncaughtException(Thread t, Throwable e) {
<span class="nc" id="L92">                    LOG.error(&quot;Thread &quot; + t + &quot; died&quot;, e);</span>
<span class="nc" id="L93">                }</span>
            });
        /**
         * this is to avoid the jvm bug:
         * NullPointerException in Selector.open()
         * http://bugs.sun.com/view_bug.do?bug_id=6427854
         */
        try {
<span class="fc" id="L101">            Selector.open().close();</span>
<span class="nc" id="L102">        } catch(IOException ie) {</span>
<span class="nc" id="L103">            LOG.error(&quot;Selector failed to open&quot;, ie);</span>
<span class="fc" id="L104">        }</span>

        /**
         * Value of 0 disables use of direct buffers and instead uses
         * gathered write call.
         *
         * Default to using 64k direct buffers.
         */
<span class="fc" id="L112">        directBufferBytes = Integer.getInteger(</span>
            ZOOKEEPER_NIO_DIRECT_BUFFER_BYTES, 64 * 1024);
    }

    /**
     * AbstractSelectThread is an abstract base class containing a few bits
     * of code shared by the AcceptThread (which selects on the listen socket)
     * and SelectorThread (which selects on client connections) classes.
     */
    private abstract class AbstractSelectThread extends ZooKeeperThread {
        protected final Selector selector;

<span class="fc" id="L124">        public AbstractSelectThread(String name) throws IOException {</span>
<span class="fc" id="L125">            super(name);</span>
            // Allows the JVM to shutdown even if this thread is still running.
<span class="fc" id="L127">            setDaemon(true);</span>
<span class="fc" id="L128">            this.selector = Selector.open();</span>
<span class="fc" id="L129">        }</span>

        public void wakeupSelector() {
<span class="fc" id="L132">            selector.wakeup();</span>
<span class="fc" id="L133">        }</span>

        /**
         * Close the selector. This should be called when the thread is about to
         * exit and no operation is going to be performed on the Selector or
         * SelectionKey
         */
        protected void closeSelector() {
            try {
<span class="fc" id="L142">                selector.close();</span>
<span class="nc" id="L143">            } catch (IOException e) {</span>
<span class="nc" id="L144">                LOG.warn(&quot;ignored exception during selector close &quot;</span>
<span class="nc" id="L145">                        + e.getMessage());</span>
<span class="fc" id="L146">            }</span>
<span class="fc" id="L147">        }</span>

        protected void cleanupSelectionKey(SelectionKey key) {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">            if (key != null) {</span>
                try {
<span class="fc" id="L152">                    key.cancel();</span>
<span class="nc" id="L153">                } catch (Exception ex) {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L155">                        LOG.debug(&quot;ignoring exception during selectionkey cancel&quot;, ex);</span>
                    }
<span class="fc" id="L157">                }</span>
            }
<span class="fc" id="L159">        }</span>

        protected void fastCloseSock(SocketChannel sc) {
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (sc != null) {</span>
                try {
                    // Hard close immediately, discarding buffers
<span class="nc" id="L165">                    sc.socket().setSoLinger(true, 0);</span>
<span class="nc" id="L166">                } catch (SocketException e) {</span>
<span class="nc" id="L167">                    LOG.warn(&quot;Unable to set socket linger to 0, socket close&quot;</span>
                             + &quot; may stall in CLOSE_WAIT&quot;, e);
<span class="nc" id="L169">                }</span>
<span class="nc" id="L170">                NIOServerCnxn.closeSock(sc);</span>
            }
<span class="nc" id="L172">        }</span>
    }

    /**
     * There is a single AcceptThread which accepts new connections and assigns
     * them to a SelectorThread using a simple round-robin scheme to spread
     * them across the SelectorThreads. It enforces maximum number of
     * connections per IP and attempts to cope with running out of file
     * descriptors by briefly sleeping before retrying.
     */
    private class AcceptThread extends AbstractSelectThread {
        private final ServerSocketChannel acceptSocket;
        private final SelectionKey acceptKey;
<span class="fc" id="L185">        private final RateLogger acceptErrorLogger = new RateLogger(LOG);</span>
        private final Collection&lt;SelectorThread&gt; selectorThreads;
        private Iterator&lt;SelectorThread&gt; selectorIterator;
<span class="fc" id="L188">        private volatile boolean reconfiguring = false;</span>
        
        public AcceptThread(ServerSocketChannel ss, InetSocketAddress addr,
<span class="fc" id="L191">                Set&lt;SelectorThread&gt; selectorThreads) throws IOException {</span>
<span class="fc" id="L192">            super(&quot;NIOServerCxnFactory.AcceptThread:&quot; + addr);</span>
<span class="fc" id="L193">            this.acceptSocket = ss;</span>
<span class="fc" id="L194">            this.acceptKey =</span>
<span class="fc" id="L195">                acceptSocket.register(selector, SelectionKey.OP_ACCEPT);</span>
<span class="fc" id="L196">            this.selectorThreads = Collections.unmodifiableList(</span>
                new ArrayList&lt;SelectorThread&gt;(selectorThreads));
<span class="fc" id="L198">            selectorIterator = this.selectorThreads.iterator();</span>
<span class="fc" id="L199">        }</span>

        public void run() {
            try {
<span class="pc bpc" id="L203" title="1 of 4 branches missed.">                while (!stopped &amp;&amp; !acceptSocket.socket().isClosed()) {</span>
                    try {
<span class="fc" id="L205">                        select();</span>
<span class="nc" id="L206">                    } catch (RuntimeException e) {</span>
<span class="nc" id="L207">                        LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);</span>
<span class="nc" id="L208">                    } catch (Exception e) {</span>
<span class="nc" id="L209">                        LOG.warn(&quot;Ignoring unexpected exception&quot;, e);</span>
<span class="pc" id="L210">                    }</span>
                }
            } finally {
<span class="fc" id="L213">                closeSelector();</span>
                // This will wake up the selector threads, and tell the
                // worker thread pool to begin shutdown.
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            	if (!reconfiguring) {                    </span>
<span class="fc" id="L217">                    NIOServerCnxnFactory.this.stop();</span>
                }
<span class="fc" id="L219">                LOG.info(&quot;accept thread exitted run method&quot;);</span>
            }
<span class="fc" id="L221">        }</span>
        
        public void setReconfiguring() {
<span class="nc" id="L224">        	reconfiguring = true;</span>
<span class="nc" id="L225">        }</span>

        private void select() {
            try {
<span class="fc" id="L229">                selector.select();</span>

<span class="fc" id="L231">                Iterator&lt;SelectionKey&gt; selectedKeys =</span>
<span class="fc" id="L232">                    selector.selectedKeys().iterator();</span>
<span class="fc bfc" id="L233" title="All 4 branches covered.">                while (!stopped &amp;&amp; selectedKeys.hasNext()) {</span>
<span class="fc" id="L234">                    SelectionKey key = selectedKeys.next();</span>
<span class="fc" id="L235">                    selectedKeys.remove();</span>

<span class="pc bpc" id="L237" title="1 of 2 branches missed.">                    if (!key.isValid()) {</span>
<span class="nc" id="L238">                        continue;</span>
                    }
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">                    if (key.isAcceptable()) {</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">                        if (!doAccept()) {</span>
                            // If unable to pull a new connection off the accept
                            // queue, pause accepting to give us time to free
                            // up file descriptors and so the accept thread
                            // doesn't spin in a tight loop.
<span class="nc" id="L246">                            pauseAccept(10);</span>
                        }
                    } else {
<span class="nc" id="L249">                        LOG.warn(&quot;Unexpected ops in accept select &quot;</span>
<span class="nc" id="L250">                                 + key.readyOps());</span>
                    }
<span class="fc" id="L252">                }</span>
<span class="nc" id="L253">            } catch (IOException e) {</span>
<span class="nc" id="L254">                LOG.warn(&quot;Ignoring IOException while selecting&quot;, e);</span>
<span class="fc" id="L255">            }</span>
<span class="fc" id="L256">        }</span>

        /**
         * Mask off the listen socket interest ops and use select() to sleep
         * so that other threads can wake us up by calling wakeup() on the
         * selector.
         */
        private void pauseAccept(long millisecs) {
<span class="nc" id="L264">            acceptKey.interestOps(0);</span>
            try {
<span class="nc" id="L266">                selector.select(millisecs);</span>
<span class="nc" id="L267">            } catch (IOException e) {</span>
                // ignore
            } finally {
<span class="nc" id="L270">                acceptKey.interestOps(SelectionKey.OP_ACCEPT);</span>
            }
<span class="nc" id="L272">        }</span>

        /**
         * Accept new socket connections. Enforces maximum number of connections
         * per client IP address. Round-robin assigns to selector thread for
         * handling. Returns whether pulled a connection off the accept queue
         * or not. If encounters an error attempts to fast close the socket.
         *
         * @return whether was able to accept a connection or not
         */
        private boolean doAccept() {
<span class="fc" id="L283">            boolean accepted = false;</span>
<span class="fc" id="L284">            SocketChannel sc = null;</span>
            try {
<span class="fc" id="L286">                sc = acceptSocket.accept();</span>
<span class="fc" id="L287">                accepted = true;</span>
<span class="fc" id="L288">                InetAddress ia = sc.socket().getInetAddress();</span>
<span class="fc" id="L289">                int cnxncount = getClientCnxnCount(ia);</span>

<span class="pc bpc" id="L291" title="3 of 4 branches missed.">                if (maxClientCnxns &gt; 0 &amp;&amp; cnxncount &gt;= maxClientCnxns){</span>
<span class="nc" id="L292">                    throw new IOException(&quot;Too many connections from &quot; + ia</span>
                                          + &quot; - max is &quot; + maxClientCnxns );
                }

<span class="fc" id="L296">                LOG.debug(&quot;Accepted socket connection from &quot;</span>
<span class="fc" id="L297">                         + sc.socket().getRemoteSocketAddress());</span>
<span class="fc" id="L298">                sc.configureBlocking(false);</span>

                // Round-robin assign this connection to a selector thread
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">                if (!selectorIterator.hasNext()) {</span>
<span class="nc" id="L302">                    selectorIterator = selectorThreads.iterator();</span>
                }
<span class="fc" id="L304">                SelectorThread selectorThread = selectorIterator.next();</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">                if (!selectorThread.addAcceptedConnection(sc)) {</span>
<span class="nc" id="L306">                    throw new IOException(</span>
                        &quot;Unable to add connection to selector queue&quot;
<span class="nc bnc" id="L308" title="All 2 branches missed.">                        + (stopped ? &quot; (shutdown in progress)&quot; : &quot;&quot;));</span>
                }
<span class="fc" id="L310">                acceptErrorLogger.flush();</span>
<span class="nc" id="L311">            } catch (IOException e) {</span>
                // accept, maxClientCnxns, configureBlocking
<span class="nc" id="L313">                acceptErrorLogger.rateLimitLog(</span>
<span class="nc" id="L314">                    &quot;Error accepting new connection: &quot; + e.getMessage());</span>
<span class="nc" id="L315">                fastCloseSock(sc);</span>
<span class="fc" id="L316">            }</span>
<span class="fc" id="L317">            return accepted;</span>
        }
    }

    /**
     * The SelectorThread receives newly accepted connections from the
     * AcceptThread and is responsible for selecting for I/O readiness
     * across the connections. This thread is the only thread that performs
     * any non-threadsafe or potentially blocking calls on the selector
     * (registering new connections and reading/writing interest ops).
     *
     * Assignment of a connection to a SelectorThread is permanent and only
     * one SelectorThread will ever interact with the connection. There are
     * 1-N SelectorThreads, with connections evenly apportioned between the
     * SelectorThreads.
     *
     * If there is a worker thread pool, when a connection has I/O to perform
     * the SelectorThread removes it from selection by clearing its interest
     * ops and schedules the I/O for processing by a worker thread. When the
     * work is complete, the connection is placed on the ready queue to have
     * its interest ops restored and resume selection.
     *
     * If there is no worker thread pool, the SelectorThread performs the I/O
     * directly.
     */
    class SelectorThread extends AbstractSelectThread {
        private final int id;
        private final Queue&lt;SocketChannel&gt; acceptedQueue;
        private final Queue&lt;SelectionKey&gt; updateQueue;

<span class="fc" id="L347">        public SelectorThread(int id) throws IOException {</span>
<span class="fc" id="L348">            super(&quot;NIOServerCxnFactory.SelectorThread-&quot; + id);</span>
<span class="fc" id="L349">            this.id = id;</span>
<span class="fc" id="L350">            acceptedQueue = new LinkedBlockingQueue&lt;SocketChannel&gt;();</span>
<span class="fc" id="L351">            updateQueue = new LinkedBlockingQueue&lt;SelectionKey&gt;();</span>
<span class="fc" id="L352">        }</span>

        /**
         * Place new accepted connection onto a queue for adding. Do this
         * so only the selector thread modifies what keys are registered
         * with the selector.
         */
        public boolean addAcceptedConnection(SocketChannel accepted) {
<span class="pc bpc" id="L360" title="2 of 4 branches missed.">            if (stopped || !acceptedQueue.offer(accepted)) {</span>
<span class="nc" id="L361">                return false;</span>
            }
<span class="fc" id="L363">            wakeupSelector();</span>
<span class="fc" id="L364">            return true;</span>
        }

        /**
         * Place interest op update requests onto a queue so that only the
         * selector thread modifies interest ops, because interest ops
         * reads/sets are potentially blocking operations if other select
         * operations are happening.
         */
        public boolean addInterestOpsUpdateRequest(SelectionKey sk) {
<span class="pc bpc" id="L374" title="2 of 4 branches missed.">            if (stopped || !updateQueue.offer(sk)) {</span>
<span class="nc" id="L375">                return false;</span>
            }
<span class="fc" id="L377">            wakeupSelector();</span>
<span class="fc" id="L378">            return true;</span>
        }

        /**
         * The main loop for the thread selects() on the connections and
         * dispatches ready I/O work requests, then registers all pending
         * newly accepted connections and updates any interest ops on the
         * queue.
         */
        public void run() {
            try {
<span class="fc bfc" id="L389" title="All 2 branches covered.">                while (!stopped) {</span>
                    try {
<span class="fc" id="L391">                        select();</span>
<span class="fc" id="L392">                        processAcceptedConnections();</span>
<span class="fc" id="L393">                        processInterestOpsUpdateRequests();</span>
<span class="nc" id="L394">                    } catch (RuntimeException e) {</span>
<span class="nc" id="L395">                        LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);</span>
<span class="nc" id="L396">                    } catch (Exception e) {</span>
<span class="nc" id="L397">                        LOG.warn(&quot;Ignoring unexpected exception&quot;, e);</span>
<span class="pc" id="L398">                    }</span>
                }

                // Close connections still pending on the selector. Any others
                // with in-flight work, let drain out of the work queue.
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">                for (SelectionKey key : selector.keys()) {</span>
<span class="nc" id="L404">                    NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                    if (cnxn.isSelectable()) {</span>
<span class="nc" id="L406">                        cnxn.close();</span>
                    }
<span class="nc" id="L408">                    cleanupSelectionKey(key);</span>
<span class="nc" id="L409">                }</span>
                SocketChannel accepted;
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">                while ((accepted = acceptedQueue.poll()) != null) {</span>
<span class="nc" id="L412">                    fastCloseSock(accepted);</span>
                }
<span class="fc" id="L414">                updateQueue.clear();</span>
            } finally {
<span class="fc" id="L416">                closeSelector();</span>
                // This will wake up the accept thread and the other selector
                // threads, and tell the worker thread pool to begin shutdown.
<span class="fc" id="L419">                NIOServerCnxnFactory.this.stop();</span>
<span class="fc" id="L420">                LOG.info(&quot;selector thread exitted run method&quot;);</span>
            }
<span class="fc" id="L422">        }</span>

        private void select() {
            try {
<span class="fc" id="L426">                selector.select();</span>

<span class="fc" id="L428">                Set&lt;SelectionKey&gt; selected = selector.selectedKeys();</span>
<span class="fc" id="L429">                ArrayList&lt;SelectionKey&gt; selectedList =</span>
                    new ArrayList&lt;SelectionKey&gt;(selected);
<span class="fc" id="L431">                Collections.shuffle(selectedList);</span>
<span class="fc" id="L432">                Iterator&lt;SelectionKey&gt; selectedKeys = selectedList.iterator();</span>
<span class="fc bfc" id="L433" title="All 4 branches covered.">                while(!stopped &amp;&amp; selectedKeys.hasNext()) {</span>
<span class="fc" id="L434">                    SelectionKey key = selectedKeys.next();</span>
<span class="fc" id="L435">                    selected.remove(key);</span>

<span class="pc bpc" id="L437" title="1 of 2 branches missed.">                    if (!key.isValid()) {</span>
<span class="nc" id="L438">                        cleanupSelectionKey(key);</span>
<span class="nc" id="L439">                        continue;</span>
                    }
<span class="pc bpc" id="L441" title="1 of 4 branches missed.">                    if (key.isReadable() || key.isWritable()) {</span>
<span class="fc" id="L442">                        handleIO(key);</span>
                    } else {
<span class="nc" id="L444">                        LOG.warn(&quot;Unexpected ops in select &quot; + key.readyOps());</span>
                    }
<span class="fc" id="L446">                }</span>
<span class="nc" id="L447">            } catch (IOException e) {</span>
<span class="nc" id="L448">                LOG.warn(&quot;Ignoring IOException while selecting&quot;, e);</span>
<span class="fc" id="L449">            }</span>
<span class="fc" id="L450">        }</span>

        /**
         * Schedule I/O for processing on the connection associated with
         * the given SelectionKey. If a worker thread pool is not being used,
         * I/O is run directly by this thread.
         */
        private void handleIO(SelectionKey key) {
<span class="fc" id="L458">            IOWorkRequest workRequest = new IOWorkRequest(this, key);</span>
<span class="fc" id="L459">            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span>

            // Stop selecting this key while processing on its
            // connection
<span class="fc" id="L463">            cnxn.disableSelectable();</span>
<span class="fc" id="L464">            key.interestOps(0);</span>
<span class="fc" id="L465">            touchCnxn(cnxn);</span>
<span class="fc" id="L466">            workerPool.schedule(workRequest);</span>
<span class="fc" id="L467">        }</span>

        /**
         * Iterate over the queue of accepted connections that have been
         * assigned to this thread but not yet placed on the selector.
         */
        private void processAcceptedConnections() {
            SocketChannel accepted;
<span class="fc bfc" id="L475" title="All 4 branches covered.">            while (!stopped &amp;&amp; (accepted = acceptedQueue.poll()) != null) {</span>
<span class="fc" id="L476">                SelectionKey key = null;</span>
                try {
<span class="fc" id="L478">                    key = accepted.register(selector, SelectionKey.OP_READ);</span>
<span class="fc" id="L479">                    NIOServerCnxn cnxn = createConnection(accepted, key, this);</span>
<span class="fc" id="L480">                    key.attach(cnxn);</span>
<span class="fc" id="L481">                    addCnxn(cnxn);</span>
<span class="nc" id="L482">                } catch (IOException e) {</span>
                    // register, createConnection
<span class="nc" id="L484">                    cleanupSelectionKey(key);</span>
<span class="nc" id="L485">                    fastCloseSock(accepted);</span>
<span class="fc" id="L486">                }</span>
<span class="fc" id="L487">            }</span>
<span class="fc" id="L488">        }</span>

        /**
         * Iterate over the queue of connections ready to resume selection,
         * and restore their interest ops selection mask.
         */
        private void processInterestOpsUpdateRequests() {
            SelectionKey key;
<span class="fc bfc" id="L496" title="All 4 branches covered.">            while (!stopped &amp;&amp; (key = updateQueue.poll()) != null) {</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">                if (!key.isValid()) {</span>
<span class="nc" id="L498">                    cleanupSelectionKey(key);</span>
                }
<span class="fc" id="L500">                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">                if (cnxn.isSelectable()) {</span>
<span class="fc" id="L502">                    key.interestOps(cnxn.getInterestOps());</span>
                }
<span class="fc" id="L504">            }</span>
<span class="fc" id="L505">        }</span>
    }

    /**
     * IOWorkRequest is a small wrapper class to allow doIO() calls to be
     * run on a connection using a WorkerService.
     */
    private class IOWorkRequest extends WorkerService.WorkRequest {
        private final SelectorThread selectorThread;
        private final SelectionKey key;
        private final NIOServerCnxn cnxn;

<span class="fc" id="L517">        IOWorkRequest(SelectorThread selectorThread, SelectionKey key) {</span>
<span class="fc" id="L518">            this.selectorThread = selectorThread;</span>
<span class="fc" id="L519">            this.key = key;</span>
<span class="fc" id="L520">            this.cnxn = (NIOServerCnxn) key.attachment();</span>
<span class="fc" id="L521">        }</span>

        public void doWork() throws InterruptedException {
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">            if (!key.isValid()) {</span>
<span class="nc" id="L525">                selectorThread.cleanupSelectionKey(key);</span>
<span class="nc" id="L526">                return;</span>
            }

<span class="pc bpc" id="L529" title="1 of 4 branches missed.">            if (key.isReadable() || key.isWritable()) {</span>
<span class="fc" id="L530">                cnxn.doIO(key);</span>

                // Check if we shutdown or doIO() closed this connection
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">                if (stopped) {</span>
<span class="nc" id="L534">                    cnxn.close();</span>
<span class="nc" id="L535">                    return;</span>
                }
<span class="fc bfc" id="L537" title="All 2 branches covered.">                if (!key.isValid()) {</span>
<span class="fc" id="L538">                    selectorThread.cleanupSelectionKey(key);</span>
<span class="fc" id="L539">                    return;</span>
                }
<span class="fc" id="L541">                touchCnxn(cnxn);</span>
            }

            // Mark this connection as once again ready for selection
<span class="fc" id="L545">            cnxn.enableSelectable();</span>
            // Push an update request on the queue to resume selecting
            // on the current set of interest ops, which may have changed
            // as a result of the I/O operations we just performed.
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">            if (!selectorThread.addInterestOpsUpdateRequest(key)) {</span>
<span class="nc" id="L550">                cnxn.close();</span>
            }
<span class="fc" id="L552">        }</span>

        @Override
        public void cleanup() {
<span class="nc" id="L556">            cnxn.close();</span>
<span class="nc" id="L557">        }</span>
    }

    /**
     * This thread is responsible for closing stale connections so that
     * connections on which no session is established are properly expired.
     */
    private class ConnectionExpirerThread extends ZooKeeperThread {
<span class="fc" id="L565">        ConnectionExpirerThread() {</span>
<span class="fc" id="L566">            super(&quot;ConnnectionExpirer&quot;);</span>
<span class="fc" id="L567">        }</span>

        public void run() {
            try {
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">                while (!stopped) {</span>
<span class="fc" id="L572">                    long waitTime = cnxnExpiryQueue.getWaitTime();</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">                    if (waitTime &gt; 0) {</span>
<span class="fc" id="L574">                        Thread.sleep(waitTime);</span>
<span class="fc" id="L575">                        continue;</span>
                    }
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">                    for (NIOServerCnxn conn : cnxnExpiryQueue.poll()) {</span>
<span class="nc" id="L578">                        conn.close();</span>
<span class="nc" id="L579">                    }</span>
<span class="fc" id="L580">                }</span>

<span class="fc" id="L582">            } catch (InterruptedException e) {</span>
<span class="fc" id="L583">                  LOG.info(&quot;ConnnectionExpirerThread interrupted&quot;);</span>
<span class="nc" id="L584">            }</span>
<span class="fc" id="L585">        }</span>
    }

    ServerSocketChannel ss;

    /**
     * We use this buffer to do efficient socket I/O. Because I/O is handled
     * by the worker threads (or the selector threads directly, if no worker
     * thread pool is created), we can create a fixed set of these to be
     * shared by connections.
     */
<span class="fc" id="L596">    private static final ThreadLocal&lt;ByteBuffer&gt; directBuffer =</span>
<span class="fc" id="L597">        new ThreadLocal&lt;ByteBuffer&gt;() {</span>
            @Override protected ByteBuffer initialValue() {
<span class="fc" id="L599">                return ByteBuffer.allocateDirect(directBufferBytes);</span>
            }
        };

    public static ByteBuffer getDirectBuffer() {
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        return directBufferBytes &gt; 0 ? directBuffer.get() : null;</span>
    }

    // sessionMap is used by closeSession()
<span class="fc" id="L608">    private final ConcurrentHashMap&lt;Long, NIOServerCnxn&gt; sessionMap =</span>
        new ConcurrentHashMap&lt;Long, NIOServerCnxn&gt;();
    // ipMap is used to limit connections per IP
<span class="fc" id="L611">    private final ConcurrentHashMap&lt;InetAddress, Set&lt;NIOServerCnxn&gt;&gt; ipMap =</span>
        new ConcurrentHashMap&lt;InetAddress, Set&lt;NIOServerCnxn&gt;&gt;( );

<span class="fc" id="L614">    protected int maxClientCnxns = 60;</span>

    int sessionlessCnxnTimeout;
    private ExpiryQueue&lt;NIOServerCnxn&gt; cnxnExpiryQueue;


    protected WorkerService workerPool;

    private static int directBufferBytes;
    private int numSelectorThreads;
    private int numWorkerThreads;
    private long workerShutdownTimeoutMS;

    /**
     * Construct a new server connection factory which will accept an unlimited number
     * of concurrent connections from each client (up to the file descriptor
     * limits of the operating system). startup(zks) must be called subsequently.
     */
<span class="fc" id="L632">    public NIOServerCnxnFactory() {</span>
<span class="fc" id="L633">    }</span>

<span class="fc" id="L635">    private volatile boolean stopped = true;</span>
    private ConnectionExpirerThread expirerThread;
    private AcceptThread acceptThread;
<span class="fc" id="L638">    private final Set&lt;SelectorThread&gt; selectorThreads =</span>
        new HashSet&lt;SelectorThread&gt;();

    @Override
    public void configure(InetSocketAddress addr, int maxcc, boolean secure) throws IOException {
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">        if (secure) {</span>
<span class="nc" id="L644">            throw new UnsupportedOperationException(&quot;SSL isn't supported in NIOServerCnxn&quot;);</span>
        }
<span class="fc" id="L646">        configureSaslLogin();</span>

<span class="fc" id="L648">        maxClientCnxns = maxcc;</span>
<span class="fc" id="L649">        sessionlessCnxnTimeout = Integer.getInteger(</span>
            ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);
        // We also use the sessionlessCnxnTimeout as expiring interval for
        // cnxnExpiryQueue. These don't need to be the same, but the expiring
        // interval passed into the ExpiryQueue() constructor below should be
        // less than or equal to the timeout.
<span class="fc" id="L655">        cnxnExpiryQueue =</span>
            new ExpiryQueue&lt;NIOServerCnxn&gt;(sessionlessCnxnTimeout);
<span class="fc" id="L657">        expirerThread = new ConnectionExpirerThread();</span>

<span class="fc" id="L659">        int numCores = Runtime.getRuntime().availableProcessors();</span>
        // 32 cores sweet spot seems to be 4 selector threads
<span class="fc" id="L661">        numSelectorThreads = Integer.getInteger(</span>
            ZOOKEEPER_NIO_NUM_SELECTOR_THREADS,
<span class="fc" id="L663">            Math.max((int) Math.sqrt((float) numCores/2), 1));</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">        if (numSelectorThreads &lt; 1) {</span>
<span class="nc" id="L665">            throw new IOException(&quot;numSelectorThreads must be at least 1&quot;);</span>
        }

<span class="fc" id="L668">        numWorkerThreads = Integer.getInteger(</span>
            ZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);
<span class="fc" id="L670">        workerShutdownTimeoutMS = Long.getLong(</span>
            ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);

<span class="fc" id="L673">        LOG.info(&quot;Configuring NIO connection handler with &quot;</span>
                 + (sessionlessCnxnTimeout/1000) + &quot;s sessionless connection&quot;
                 + &quot; timeout, &quot; + numSelectorThreads + &quot; selector thread(s), &quot;
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">                 + (numWorkerThreads &gt; 0 ? numWorkerThreads : &quot;no&quot;)</span>
                 + &quot; worker threads, and &quot;
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                 + (directBufferBytes == 0 ? &quot;gathered writes.&quot; :</span>
<span class="fc" id="L679">                    (&quot;&quot; + (directBufferBytes/1024) + &quot; kB direct buffers.&quot;)));</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">        for(int i=0; i&lt;numSelectorThreads; ++i) {</span>
<span class="fc" id="L681">            selectorThreads.add(new SelectorThread(i));</span>
        }

<span class="fc" id="L684">        this.ss = ServerSocketChannel.open();</span>
<span class="fc" id="L685">        ss.socket().setReuseAddress(true);</span>
<span class="fc" id="L686">        LOG.info(&quot;binding to port &quot; + addr);</span>
<span class="fc" id="L687">        ss.socket().bind(addr);</span>
<span class="fc" id="L688">        ss.configureBlocking(false);</span>
<span class="fc" id="L689">        acceptThread = new AcceptThread(ss, addr, selectorThreads);</span>
<span class="fc" id="L690">    }</span>

    private void tryClose(ServerSocketChannel s) {
        try {
<span class="nc" id="L694">            s.close();</span>
<span class="nc" id="L695">        } catch (IOException sse) {</span>
<span class="nc" id="L696">            LOG.error(&quot;Error while closing server socket.&quot;, sse);</span>
<span class="nc" id="L697">        }</span>
<span class="nc" id="L698">    }</span>

    @Override
    public void reconfigure(InetSocketAddress addr) {
<span class="nc" id="L702">        ServerSocketChannel oldSS = ss;        </span>
        try {
<span class="nc" id="L704">            acceptThread.setReconfiguring();</span>
<span class="nc" id="L705">            tryClose(oldSS);</span>
<span class="nc" id="L706">            acceptThread.wakeupSelector();</span>
            try {
<span class="nc" id="L708">                acceptThread.join();</span>
<span class="nc" id="L709">            } catch (InterruptedException e) {</span>
<span class="nc" id="L710">                LOG.error(&quot;Error joining old acceptThread when reconfiguring client port {}&quot;,</span>
<span class="nc" id="L711">                            e.getMessage());</span>
<span class="nc" id="L712">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L713">            }</span>
<span class="nc" id="L714">            this.ss = ServerSocketChannel.open();</span>
<span class="nc" id="L715">            ss.socket().setReuseAddress(true);</span>
<span class="nc" id="L716">            LOG.info(&quot;binding to port &quot; + addr);</span>
<span class="nc" id="L717">            ss.socket().bind(addr);</span>
<span class="nc" id="L718">            ss.configureBlocking(false);</span>
<span class="nc" id="L719">            acceptThread = new AcceptThread(ss, addr, selectorThreads);</span>
<span class="nc" id="L720">            acceptThread.start();</span>
<span class="nc" id="L721">        } catch(IOException e) {</span>
<span class="nc" id="L722">            LOG.error(&quot;Error reconfiguring client port to {} {}&quot;, addr, e.getMessage());</span>
<span class="nc" id="L723">            tryClose(oldSS);</span>
<span class="nc" id="L724">        }</span>
<span class="nc" id="L725">    }</span>

    /** {@inheritDoc} */
    public int getMaxClientCnxnsPerHost() {
<span class="nc" id="L729">        return maxClientCnxns;</span>
    }

    /** {@inheritDoc} */
    public void setMaxClientCnxnsPerHost(int max) {
<span class="nc" id="L734">        maxClientCnxns = max;</span>
<span class="nc" id="L735">    }</span>

    @Override
    public void start() {
<span class="fc" id="L739">        stopped = false;</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">        if (workerPool == null) {</span>
<span class="fc" id="L741">            workerPool = new WorkerService(</span>
                &quot;NIOWorker&quot;, numWorkerThreads, false);
        }
<span class="fc bfc" id="L744" title="All 2 branches covered.">        for(SelectorThread thread : selectorThreads) {</span>
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">            if (thread.getState() == Thread.State.NEW) {</span>
<span class="fc" id="L746">                thread.start();</span>
            }
<span class="fc" id="L748">        }</span>
        // ensure thread is started once and only once
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">        if (acceptThread.getState() == Thread.State.NEW) {</span>
<span class="fc" id="L751">            acceptThread.start();</span>
        }
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">        if (expirerThread.getState() == Thread.State.NEW) {</span>
<span class="fc" id="L754">            expirerThread.start();</span>
        }
<span class="fc" id="L756">    }</span>

    @Override
    public void startup(ZooKeeperServer zks, boolean startServer)
            throws IOException, InterruptedException {
<span class="fc" id="L761">        start();</span>
<span class="fc" id="L762">        setZooKeeperServer(zks);</span>
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">        if (startServer) {</span>
<span class="fc" id="L764">            zks.startdata();</span>
<span class="fc" id="L765">            zks.startup();</span>
        }
<span class="fc" id="L767">    }</span>

    @Override
    public InetSocketAddress getLocalAddress(){
<span class="nc" id="L771">        return (InetSocketAddress)ss.socket().getLocalSocketAddress();</span>
    }

    @Override
    public int getLocalPort(){
<span class="fc" id="L776">        return ss.socket().getLocalPort();</span>
    }

    /**
     * De-registers the connection from the various mappings maintained
     * by the factory.
     */
    public boolean removeCnxn(NIOServerCnxn cnxn) {
        // If the connection is not in the master list it's already been closed
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        if (!cnxns.remove(cnxn)) {</span>
<span class="nc" id="L786">            return false;</span>
        }
<span class="fc" id="L788">        cnxnExpiryQueue.remove(cnxn);</span>

<span class="fc" id="L790">        long sessionId = cnxn.getSessionId();</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">        if (sessionId != 0) {</span>
<span class="fc" id="L792">            sessionMap.remove(sessionId);</span>
        }

<span class="fc" id="L795">        InetAddress addr = cnxn.getSocketAddress();</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">        if (addr != null) {</span>
<span class="fc" id="L797">            Set&lt;NIOServerCnxn&gt; set = ipMap.get(addr);</span>
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">            if (set != null) {</span>
<span class="fc" id="L799">                set.remove(cnxn);</span>
                // Note that we make no effort here to remove empty mappings
                // from ipMap.
            }
        }

        // unregister from JMX
<span class="fc" id="L806">        unregisterConnection(cnxn);</span>
<span class="fc" id="L807">        return true;</span>
    }

    /**
     * Add or update cnxn in our cnxnExpiryQueue
     * @param cnxn
     */
    public void touchCnxn(NIOServerCnxn cnxn) {
<span class="fc" id="L815">        cnxnExpiryQueue.update(cnxn, cnxn.getSessionTimeout());</span>
<span class="fc" id="L816">    }</span>

    private void addCnxn(NIOServerCnxn cnxn) throws IOException {
<span class="fc" id="L819">        InetAddress addr = cnxn.getSocketAddress();</span>
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">        if (addr == null) {</span>
<span class="nc" id="L821">            throw new IOException(&quot;Socket of &quot; + cnxn + &quot; has been closed&quot;);</span>
        }
<span class="fc" id="L823">        Set&lt;NIOServerCnxn&gt; set = ipMap.get(addr);</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">        if (set == null) {</span>
            // in general we will see 1 connection from each
            // host, setting the initial cap to 2 allows us
            // to minimize mem usage in the common case
            // of 1 entry --  we need to set the initial cap
            // to 2 to avoid rehash when the first entry is added
            // Construct a ConcurrentHashSet using a ConcurrentHashMap
<span class="fc" id="L831">            set = Collections.newSetFromMap(</span>
                new ConcurrentHashMap&lt;NIOServerCnxn, Boolean&gt;(2));
            // Put the new set in the map, but only if another thread
            // hasn't beaten us to it
<span class="fc" id="L835">            Set&lt;NIOServerCnxn&gt; existingSet = ipMap.putIfAbsent(addr, set);</span>
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">            if (existingSet != null) {</span>
<span class="nc" id="L837">                set = existingSet;</span>
            }
        }
<span class="fc" id="L840">        set.add(cnxn);</span>

<span class="fc" id="L842">        cnxns.add(cnxn);</span>
<span class="fc" id="L843">        touchCnxn(cnxn);</span>
<span class="fc" id="L844">    }</span>

    protected NIOServerCnxn createConnection(SocketChannel sock,
            SelectionKey sk, SelectorThread selectorThread) throws IOException {
<span class="fc" id="L848">        return new NIOServerCnxn(zkServer, sock, sk, this, selectorThread);</span>
    }

    private int getClientCnxnCount(InetAddress cl) {
<span class="fc" id="L852">        Set&lt;NIOServerCnxn&gt; s = ipMap.get(cl);</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">        if (s == null) return 0;</span>
<span class="fc" id="L854">        return s.size();</span>
    }

    /**
     * clear all the connections in the selector
     *
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void closeAll() {
        // clear all the connections on which we are selecting
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">        for (ServerCnxn cnxn : cnxns) {</span>
            try {
                // This will remove the cnxn from cnxns
<span class="nc" id="L868">                cnxn.close();</span>
<span class="nc" id="L869">            } catch (Exception e) {</span>
<span class="nc" id="L870">                LOG.warn(&quot;Ignoring exception closing cnxn sessionid 0x&quot;</span>
<span class="nc" id="L871">                         + Long.toHexString(cnxn.getSessionId()), e);</span>
<span class="nc" id="L872">            }</span>
<span class="nc" id="L873">        }</span>
<span class="fc" id="L874">    }</span>

    public void stop() {
<span class="fc" id="L877">        stopped = true;</span>

        // Stop queuing connection attempts
        try {
<span class="fc" id="L881">            ss.close();</span>
<span class="nc" id="L882">        } catch (IOException e) {</span>
<span class="nc" id="L883">            LOG.warn(&quot;Error closing listen socket&quot;, e);</span>
<span class="fc" id="L884">        }</span>

<span class="pc bpc" id="L886" title="1 of 2 branches missed.">        if (acceptThread != null) {</span>
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">            if (acceptThread.isAlive()) {</span>
<span class="fc" id="L888">                acceptThread.wakeupSelector();</span>
            } else {
<span class="nc" id="L890">                acceptThread.closeSelector();</span>
            }
        }
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">        if (expirerThread != null) {</span>
<span class="fc" id="L894">            expirerThread.interrupt();</span>
        }
<span class="fc bfc" id="L896" title="All 2 branches covered.">        for (SelectorThread thread : selectorThreads) {</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">            if (thread.isAlive()) {</span>
<span class="fc" id="L898">                thread.wakeupSelector();</span>
            } else {
<span class="fc" id="L900">                thread.closeSelector();</span>
            }
<span class="fc" id="L902">        }</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">        if (workerPool != null) {</span>
<span class="fc" id="L904">            workerPool.stop();</span>
        }
<span class="fc" id="L906">    }</span>

    public void shutdown() {
        try {
            // close listen socket and signal selector threads to stop
<span class="fc" id="L911">            stop();</span>

            // wait for selector and worker threads to shutdown
<span class="fc" id="L914">            join();</span>

            // close all open connections
<span class="fc" id="L917">            closeAll();</span>

<span class="pc bpc" id="L919" title="1 of 2 branches missed.">            if (login != null) {</span>
<span class="nc" id="L920">                login.shutdown();</span>
            }
<span class="nc" id="L922">        } catch (InterruptedException e) {</span>
<span class="nc" id="L923">            LOG.warn(&quot;Ignoring interrupted exception during shutdown&quot;, e);</span>
<span class="nc" id="L924">        } catch (Exception e) {</span>
<span class="nc" id="L925">            LOG.warn(&quot;Ignoring unexpected exception during shutdown&quot;, e);</span>
<span class="pc" id="L926">        }</span>

<span class="pc bpc" id="L928" title="1 of 2 branches missed.">        if (zkServer != null) {</span>
<span class="fc" id="L929">            zkServer.shutdown();</span>
        }
<span class="fc" id="L931">    }</span>

    public void addSession(long sessionId, NIOServerCnxn cnxn) {
<span class="fc" id="L934">        sessionMap.put(sessionId, cnxn);</span>
<span class="fc" id="L935">    }</span>

    @Override
    public boolean closeSession(long sessionId) {
<span class="nc" id="L939">        NIOServerCnxn cnxn = sessionMap.remove(sessionId);</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">        if (cnxn != null) {</span>
<span class="nc" id="L941">            cnxn.close();</span>
<span class="nc" id="L942">            return true;</span>
        }
<span class="nc" id="L944">        return false;</span>
    }

    @Override
    public void join() throws InterruptedException {
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">        if (acceptThread != null) {</span>
<span class="fc" id="L950">            acceptThread.join();</span>
        }
<span class="fc bfc" id="L952" title="All 2 branches covered.">        for (SelectorThread thread : selectorThreads) {</span>
<span class="fc" id="L953">            thread.join();</span>
<span class="fc" id="L954">        }</span>
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">        if (workerPool != null) {</span>
<span class="fc" id="L956">            workerPool.join(workerShutdownTimeoutMS);</span>
        }
<span class="fc" id="L958">    }</span>

    @Override
    public Iterable&lt;ServerCnxn&gt; getConnections() {
<span class="fc" id="L962">        return cnxns;</span>
    }

    public void dumpConnections(PrintWriter pwriter) {
<span class="nc" id="L966">        pwriter.print(&quot;Connections &quot;);</span>
<span class="nc" id="L967">        cnxnExpiryQueue.dump(pwriter);</span>
<span class="nc" id="L968">    }</span>

    @Override
    public void resetAllConnectionStats() {
        // No need to synchronize since cnxns is backed by a ConcurrentHashMap
<span class="nc bnc" id="L973" title="All 2 branches missed.">        for(ServerCnxn c : cnxns){</span>
<span class="nc" id="L974">            c.resetStats();</span>
<span class="nc" id="L975">        }</span>
<span class="nc" id="L976">    }</span>

    @Override
    public Iterable&lt;Map&lt;String, Object&gt;&gt; getAllConnectionInfo(boolean brief) {
<span class="nc" id="L980">        HashSet&lt;Map&lt;String,Object&gt;&gt; info = new HashSet&lt;Map&lt;String,Object&gt;&gt;();</span>
        // No need to synchronize since cnxns is backed by a ConcurrentHashMap
<span class="nc bnc" id="L982" title="All 2 branches missed.">        for (ServerCnxn c : cnxns) {</span>
<span class="nc" id="L983">            info.add(c.getConnectionInfo(brief));</span>
<span class="nc" id="L984">        }</span>
<span class="nc" id="L985">        return info;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>