<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ZooKeeperServer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">parent$MyZookeeperRemoveWatchesTest.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.zookeeper.server</a> &gt; <span class="el_source">ZooKeeperServer.java</span></div><h1>ZooKeeperServer.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.zookeeper.server;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.nio.ByteBuffer;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import javax.security.sasl.SaslException;

import org.apache.jute.BinaryInputArchive;
import org.apache.jute.BinaryOutputArchive;
import org.apache.jute.Record;
import org.apache.zookeeper.Environment;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.KeeperException.Code;
import org.apache.zookeeper.KeeperException.SessionExpiredException;
import org.apache.zookeeper.ZooDefs.OpCode;
import org.apache.zookeeper.data.ACL;
import org.apache.zookeeper.data.Id;
import org.apache.zookeeper.data.StatPersisted;
import org.apache.zookeeper.jmx.MBeanRegistry;
import org.apache.zookeeper.proto.AuthPacket;
import org.apache.zookeeper.proto.ConnectRequest;
import org.apache.zookeeper.proto.ConnectResponse;
import org.apache.zookeeper.proto.GetSASLRequest;
import org.apache.zookeeper.proto.ReplyHeader;
import org.apache.zookeeper.proto.RequestHeader;
import org.apache.zookeeper.proto.SetSASLResponse;
import org.apache.zookeeper.server.DataTree.ProcessTxnResult;
import org.apache.zookeeper.server.RequestProcessor.RequestProcessorException;
import org.apache.zookeeper.server.ServerCnxn.CloseRequestException;
import org.apache.zookeeper.server.SessionTracker.Session;
import org.apache.zookeeper.server.SessionTracker.SessionExpirer;
import org.apache.zookeeper.server.auth.AuthenticationProvider;
import org.apache.zookeeper.server.auth.ProviderRegistry;
import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
import org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer;
import org.apache.zookeeper.txn.CreateSessionTxn;
import org.apache.zookeeper.txn.TxnHeader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * This class implements a simple standalone ZooKeeperServer. It sets up the
 * following chain of RequestProcessors to process requests:
 * PrepRequestProcessor -&gt; SyncRequestProcessor -&gt; FinalRequestProcessor
 */
public class ZooKeeperServer implements SessionExpirer, ServerStats.Provider {
    protected static final Logger LOG;

    static {
<span class="fc" id="L86">        LOG = LoggerFactory.getLogger(ZooKeeperServer.class);</span>

<span class="fc" id="L88">        Environment.logEnv(&quot;Server environment:&quot;, LOG);</span>
    }

    protected ZooKeeperServerBean jmxServerBean;
    protected DataTreeBean jmxDataTreeBean;

    public static final int DEFAULT_TICK_TIME = 3000;
<span class="pc" id="L95">    protected int tickTime = DEFAULT_TICK_TIME;</span>
    /** value of -1 indicates unset, use default */
<span class="pc" id="L97">    protected int minSessionTimeout = -1;</span>
    /** value of -1 indicates unset, use default */
<span class="pc" id="L99">    protected int maxSessionTimeout = -1;</span>
    protected SessionTracker sessionTracker;
<span class="pc" id="L101">    private FileTxnSnapLog txnLogFactory = null;</span>
    private ZKDatabase zkDb;
<span class="pc" id="L103">    private final AtomicLong hzxid = new AtomicLong(0);</span>
<span class="fc" id="L104">    public final static Exception ok = new Exception(&quot;No prob&quot;);</span>
    protected RequestProcessor firstProcessor;
<span class="pc" id="L106">    protected volatile State state = State.INITIAL;</span>

<span class="fc" id="L108">    protected enum State {</span>
<span class="fc" id="L109">        INITIAL, RUNNING, SHUTDOWN, ERROR</span>
    }

    /**
     * This is the secret that we use to generate passwords. For the moment,
     * it's more of a checksum that's used in reconnection, which carries no
     * security weight, and is treated internally as if it carries no
     * security weight.
     */
    static final private long superSecret = 0XB3415C00L;

<span class="pc" id="L120">    private final AtomicInteger requestsInProcess = new AtomicInteger(0);</span>
<span class="pc" id="L121">    final Deque&lt;ChangeRecord&gt; outstandingChanges = new ArrayDeque&lt;&gt;();</span>
    // this data structure must be accessed under the outstandingChanges lock
<span class="pc" id="L123">    final HashMap&lt;String, ChangeRecord&gt; outstandingChangesForPath =</span>
        new HashMap&lt;String, ChangeRecord&gt;();

    protected ServerCnxnFactory serverCnxnFactory;
    protected ServerCnxnFactory secureServerCnxnFactory;

    private final ServerStats serverStats;
    private final ZooKeeperServerListener listener;
    private ZooKeeperServerShutdownHandler zkShutdownHandler;
<span class="pc" id="L132">    private volatile int createSessionTrackerServerId = 1;</span>

    void removeCnxn(ServerCnxn cnxn) {
<span class="fc" id="L135">        zkDb.removeCnxn(cnxn);</span>
<span class="fc" id="L136">    }</span>

    /**
     * Creates a ZooKeeperServer instance. Nothing is setup, use the setX
     * methods to prepare the instance (eg datadir, datalogdir, ticktime,
     * builder, etc...)
     *
     * @throws IOException
     */
<span class="nc" id="L145">    public ZooKeeperServer() {</span>
<span class="nc" id="L146">        serverStats = new ServerStats(this);</span>
<span class="nc" id="L147">        listener = new ZooKeeperServerListenerImpl(this);</span>
<span class="nc" id="L148">    }</span>

    /**
     * Creates a ZooKeeperServer instance. It sets everything up, but doesn't
     * actually start listening for clients until run() is invoked.
     *
     * @param dataDir the directory to put the data
     */
    public ZooKeeperServer(FileTxnSnapLog txnLogFactory, int tickTime,
<span class="fc" id="L157">            int minSessionTimeout, int maxSessionTimeout, ZKDatabase zkDb) {</span>
<span class="fc" id="L158">        serverStats = new ServerStats(this);</span>
<span class="fc" id="L159">        this.txnLogFactory = txnLogFactory;</span>
<span class="fc" id="L160">        this.txnLogFactory.setServerStats(this.serverStats);</span>
<span class="fc" id="L161">        this.zkDb = zkDb;</span>
<span class="fc" id="L162">        this.tickTime = tickTime;</span>
<span class="fc" id="L163">        setMinSessionTimeout(minSessionTimeout);</span>
<span class="fc" id="L164">        setMaxSessionTimeout(maxSessionTimeout);</span>
<span class="fc" id="L165">        listener = new ZooKeeperServerListenerImpl(this);</span>
<span class="fc" id="L166">        LOG.info(&quot;Created server with tickTime &quot; + tickTime</span>
<span class="fc" id="L167">                + &quot; minSessionTimeout &quot; + getMinSessionTimeout()</span>
<span class="fc" id="L168">                + &quot; maxSessionTimeout &quot; + getMaxSessionTimeout()</span>
<span class="fc" id="L169">                + &quot; datadir &quot; + txnLogFactory.getDataDir()</span>
<span class="fc" id="L170">                + &quot; snapdir &quot; + txnLogFactory.getSnapDir());</span>
<span class="fc" id="L171">    }</span>

    /**
     * creates a zookeeperserver instance.
     * @param txnLogFactory the file transaction snapshot logging class
     * @param tickTime the ticktime for the server
     * @throws IOException
     */
    public ZooKeeperServer(FileTxnSnapLog txnLogFactory, int tickTime)
            throws IOException {
<span class="fc" id="L181">        this(txnLogFactory, tickTime, -1, -1, new ZKDatabase(txnLogFactory));</span>
<span class="fc" id="L182">    }</span>

    public ServerStats serverStats() {
<span class="fc" id="L185">        return serverStats;</span>
    }

    public void dumpConf(PrintWriter pwriter) {
<span class="nc" id="L189">        pwriter.print(&quot;clientPort=&quot;);</span>
<span class="nc" id="L190">        pwriter.println(getClientPort());</span>
<span class="nc" id="L191">        pwriter.print(&quot;secureClientPort=&quot;);</span>
<span class="nc" id="L192">        pwriter.println(getSecureClientPort());</span>
<span class="nc" id="L193">        pwriter.print(&quot;dataDir=&quot;);</span>
<span class="nc" id="L194">        pwriter.println(zkDb.snapLog.getSnapDir().getAbsolutePath());</span>
<span class="nc" id="L195">        pwriter.print(&quot;dataDirSize=&quot;);</span>
<span class="nc" id="L196">        pwriter.println(getDataDirSize());</span>
<span class="nc" id="L197">        pwriter.print(&quot;dataLogDir=&quot;);</span>
<span class="nc" id="L198">        pwriter.println(zkDb.snapLog.getDataDir().getAbsolutePath());</span>
<span class="nc" id="L199">        pwriter.print(&quot;dataLogSize=&quot;);</span>
<span class="nc" id="L200">        pwriter.println(getLogDirSize());</span>
<span class="nc" id="L201">        pwriter.print(&quot;tickTime=&quot;);</span>
<span class="nc" id="L202">        pwriter.println(getTickTime());</span>
<span class="nc" id="L203">        pwriter.print(&quot;maxClientCnxns=&quot;);</span>
<span class="nc" id="L204">        pwriter.println(getMaxClientCnxnsPerHost());</span>
<span class="nc" id="L205">        pwriter.print(&quot;minSessionTimeout=&quot;);</span>
<span class="nc" id="L206">        pwriter.println(getMinSessionTimeout());</span>
<span class="nc" id="L207">        pwriter.print(&quot;maxSessionTimeout=&quot;);</span>
<span class="nc" id="L208">        pwriter.println(getMaxSessionTimeout());</span>

<span class="nc" id="L210">        pwriter.print(&quot;serverId=&quot;);</span>
<span class="nc" id="L211">        pwriter.println(getServerId());</span>
<span class="nc" id="L212">    }</span>

    public ZooKeeperServerConf getConf() {
<span class="nc" id="L215">        return new ZooKeeperServerConf</span>
<span class="nc" id="L216">            (getClientPort(),</span>
<span class="nc" id="L217">             zkDb.snapLog.getSnapDir().getAbsolutePath(),</span>
<span class="nc" id="L218">             zkDb.snapLog.getDataDir().getAbsolutePath(),</span>
<span class="nc" id="L219">             getTickTime(),</span>
<span class="nc" id="L220">             getMaxClientCnxnsPerHost(),</span>
<span class="nc" id="L221">             getMinSessionTimeout(),</span>
<span class="nc" id="L222">             getMaxSessionTimeout(),</span>
<span class="nc" id="L223">             getServerId());</span>
    }

    /**
     * This constructor is for backward compatibility with the existing unit
     * test code.
     * It defaults to FileLogProvider persistence provider.
     */
    public ZooKeeperServer(File snapDir, File logDir, int tickTime)
            throws IOException {
<span class="fc" id="L233">        this( new FileTxnSnapLog(snapDir, logDir),</span>
                tickTime);
<span class="fc" id="L235">    }</span>

    /**
     * Default constructor, relies on the config for its argument values
     *
     * @throws IOException
     */
    public ZooKeeperServer(FileTxnSnapLog txnLogFactory)
        throws IOException
    {
<span class="nc" id="L245">        this(txnLogFactory, DEFAULT_TICK_TIME, -1, -1, new ZKDatabase(txnLogFactory));</span>
<span class="nc" id="L246">    }</span>

    /**
     * get the zookeeper database for this server
     * @return the zookeeper database for this server
     */
    public ZKDatabase getZKDatabase() {
<span class="fc" id="L253">        return this.zkDb;</span>
    }

    /**
     * set the zkdatabase for this zookeeper server
     * @param zkDb
     */
    public void setZKDatabase(ZKDatabase zkDb) {
<span class="nc" id="L261">       this.zkDb = zkDb;</span>
<span class="nc" id="L262">    }</span>

    /**
     *  Restore sessions and data
     */
    public void loadData() throws IOException, InterruptedException {
        /*
         * When a new leader starts executing Leader#lead, it 
         * invokes this method. The database, however, has been
         * initialized before running leader election so that
         * the server could pick its zxid for its initial vote.
         * It does it by invoking QuorumPeer#getLastLoggedZxid.
         * Consequently, we don't need to initialize it once more
         * and avoid the penalty of loading it a second time. Not 
         * reloading it is particularly important for applications
         * that host a large database.
         * 
         * The following if block checks whether the database has
         * been initialized or not. Note that this method is
         * invoked by at least one other method: 
         * ZooKeeperServer#startdata.
         *  
         * See ZOOKEEPER-1642 for more detail.
         */
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if(zkDb.isInitialized()){</span>
<span class="nc" id="L287">            setZxid(zkDb.getDataTreeLastProcessedZxid());</span>
        }
        else {
<span class="fc" id="L290">            setZxid(zkDb.loadDataBase());</span>
        }
        
        // Clean up dead sessions
<span class="fc" id="L294">        LinkedList&lt;Long&gt; deadSessions = new LinkedList&lt;Long&gt;();</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        for (Long session : zkDb.getSessions()) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">            if (zkDb.getSessionWithTimeOuts().get(session) == null) {</span>
<span class="nc" id="L297">                deadSessions.add(session);</span>
            }
<span class="nc" id="L299">        }</span>

<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        for (long session : deadSessions) {</span>
            // XXX: Is lastProcessedZxid really the best thing to use?
<span class="nc" id="L303">            killSession(session, zkDb.getDataTreeLastProcessedZxid());</span>
<span class="nc" id="L304">        }</span>

        // Make a clean snapshot
<span class="fc" id="L307">        takeSnapshot();</span>
<span class="fc" id="L308">    }</span>

    public void takeSnapshot(){
        try {
<span class="fc" id="L312">            txnLogFactory.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts());</span>
<span class="nc" id="L313">        } catch (IOException e) {</span>
<span class="nc" id="L314">            LOG.error(&quot;Severe unrecoverable error, exiting&quot;, e);</span>
            // This is a severe error that we cannot recover from,
            // so we need to exit
<span class="nc" id="L317">            System.exit(10);</span>
<span class="fc" id="L318">        }</span>
<span class="fc" id="L319">    }</span>

    @Override
    public long getDataDirSize() {
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (zkDb == null) {</span>
<span class="nc" id="L324">            return 0L;</span>
        }
<span class="nc" id="L326">        File path = zkDb.snapLog.getDataDir();</span>
<span class="nc" id="L327">        return getDirSize(path);</span>
    }

    @Override
    public long getLogDirSize() {
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (zkDb == null) {</span>
<span class="nc" id="L333">            return 0L;</span>
        }
<span class="nc" id="L335">        File path = zkDb.snapLog.getSnapDir();</span>
<span class="nc" id="L336">        return getDirSize(path);</span>
    }

    private long getDirSize(File file) {
<span class="nc" id="L340">        long size = 0L;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (file.isDirectory()) {</span>
<span class="nc" id="L342">            File[] files = file.listFiles();</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            if (files != null) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                for (File f : files) {</span>
<span class="nc" id="L345">                    size += getDirSize(f);</span>
                }
            }
<span class="nc" id="L348">        } else {</span>
<span class="nc" id="L349">            size = file.length();</span>
        }
<span class="nc" id="L351">        return size;</span>
    }

    public long getZxid() {
<span class="fc" id="L355">        return hzxid.get();</span>
    }

    public SessionTracker getSessionTracker() {
<span class="nc" id="L359">        return sessionTracker;</span>
    }
    
    long getNextZxid() {
<span class="fc" id="L363">        return hzxid.incrementAndGet();</span>
    }

    public void setZxid(long zxid) {
<span class="fc" id="L367">        hzxid.set(zxid);</span>
<span class="fc" id="L368">    }</span>

    private void close(long sessionId) {
<span class="nc" id="L371">        Request si = new Request(null, sessionId, 0, OpCode.closeSession, null, null);</span>
<span class="nc" id="L372">        setLocalSessionFlag(si);</span>
<span class="nc" id="L373">        submitRequest(si);</span>
<span class="nc" id="L374">    }</span>

    public void closeSession(long sessionId) {
<span class="nc" id="L377">        LOG.info(&quot;Closing session 0x&quot; + Long.toHexString(sessionId));</span>

        // we do not want to wait for a session close. send it as soon as we
        // detect it!
<span class="nc" id="L381">        close(sessionId);</span>
<span class="nc" id="L382">    }</span>

    protected void killSession(long sessionId, long zxid) {
<span class="nc" id="L385">        zkDb.killSession(sessionId, zxid);</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L387">            ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,</span>
                                         &quot;ZooKeeperServer --- killSession: 0x&quot;
<span class="nc" id="L389">                    + Long.toHexString(sessionId));</span>
        }
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (sessionTracker != null) {</span>
<span class="nc" id="L392">            sessionTracker.removeSession(sessionId);</span>
        }
<span class="nc" id="L394">    }</span>

    public void expire(Session session) {
<span class="nc" id="L397">        long sessionId = session.getSessionId();</span>
<span class="nc" id="L398">        LOG.info(&quot;Expiring session 0x&quot; + Long.toHexString(sessionId)</span>
<span class="nc" id="L399">                + &quot;, timeout of &quot; + session.getTimeout() + &quot;ms exceeded&quot;);</span>
<span class="nc" id="L400">        close(sessionId);</span>
<span class="nc" id="L401">    }</span>

    public static class MissingSessionException extends IOException {
        private static final long serialVersionUID = 7467414635467261007L;

        public MissingSessionException(String msg) {
<span class="nc" id="L407">            super(msg);</span>
<span class="nc" id="L408">        }</span>
    }

    void touch(ServerCnxn cnxn) throws MissingSessionException {
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if (cnxn == null) {</span>
<span class="nc" id="L413">            return;</span>
        }
<span class="fc" id="L415">        long id = cnxn.getSessionId();</span>
<span class="fc" id="L416">        int to = cnxn.getSessionTimeout();</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">        if (!sessionTracker.touchSession(id, to)) {</span>
<span class="nc" id="L418">            throw new MissingSessionException(</span>
<span class="nc" id="L419">                    &quot;No session with sessionid 0x&quot; + Long.toHexString(id)</span>
                    + &quot; exists, probably expired and removed&quot;);
        }
<span class="fc" id="L422">    }</span>

    protected void registerJMX() {
        // register with JMX
        try {
<span class="fc" id="L427">            jmxServerBean = new ZooKeeperServerBean(this);</span>
<span class="fc" id="L428">            MBeanRegistry.getInstance().register(jmxServerBean, null);</span>

            try {
<span class="fc" id="L431">                jmxDataTreeBean = new DataTreeBean(zkDb.getDataTree());</span>
<span class="fc" id="L432">                MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);</span>
<span class="nc" id="L433">            } catch (Exception e) {</span>
<span class="nc" id="L434">                LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="nc" id="L435">                jmxDataTreeBean = null;</span>
<span class="fc" id="L436">            }</span>
<span class="nc" id="L437">        } catch (Exception e) {</span>
<span class="nc" id="L438">            LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="nc" id="L439">            jmxServerBean = null;</span>
<span class="fc" id="L440">        }</span>
<span class="fc" id="L441">    }</span>

    public void startdata()
    throws IOException, InterruptedException {
        //check to see if zkDb is not null
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (zkDb == null) {</span>
<span class="nc" id="L447">            zkDb = new ZKDatabase(this.txnLogFactory);</span>
        }
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        if (!zkDb.isInitialized()) {</span>
<span class="fc" id="L450">            loadData();</span>
        }
<span class="fc" id="L452">    }</span>

    public synchronized void startup() {
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (sessionTracker == null) {</span>
<span class="fc" id="L456">            createSessionTracker();</span>
        }
<span class="fc" id="L458">        startSessionTracker();</span>
<span class="fc" id="L459">        setupRequestProcessors();</span>

<span class="fc" id="L461">        registerJMX();</span>

<span class="fc" id="L463">        setState(State.RUNNING);</span>
<span class="fc" id="L464">        notifyAll();</span>
<span class="fc" id="L465">    }</span>

    protected void setupRequestProcessors() {
<span class="fc" id="L468">        RequestProcessor finalProcessor = new FinalRequestProcessor(this);</span>
<span class="fc" id="L469">        RequestProcessor syncProcessor = new SyncRequestProcessor(this,</span>
                finalProcessor);
<span class="fc" id="L471">        ((SyncRequestProcessor)syncProcessor).start();</span>
<span class="fc" id="L472">        firstProcessor = new PrepRequestProcessor(this, syncProcessor);</span>
<span class="fc" id="L473">        ((PrepRequestProcessor)firstProcessor).start();</span>
<span class="fc" id="L474">    }</span>

    public ZooKeeperServerListener getZooKeeperServerListener() {
<span class="fc" id="L477">        return listener;</span>
    }

    /**
     * Change the server ID used by {@link #createSessionTracker()}. Must be called prior to
     * {@link #startup()} being called
     *
     * @param newId ID to use
     */
    public void setCreateSessionTrackerServerId(int newId) {
<span class="fc" id="L487">        createSessionTrackerServerId = newId;</span>
<span class="fc" id="L488">    }</span>

    protected void createSessionTracker() {
<span class="fc" id="L491">        sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(),</span>
<span class="fc" id="L492">                tickTime, createSessionTrackerServerId, getZooKeeperServerListener());</span>
<span class="fc" id="L493">    }</span>

    protected void startSessionTracker() {
<span class="fc" id="L496">        ((SessionTrackerImpl)sessionTracker).start();</span>
<span class="fc" id="L497">    }</span>

    /**
     * Sets the state of ZooKeeper server. After changing the state, it notifies
     * the server state change to a registered shutdown handler, if any.
     * &lt;p&gt;
     * The following are the server state transitions:
     * &lt;li&gt;During startup the server will be in the INITIAL state.&lt;/li&gt;
     * &lt;li&gt;After successfully starting, the server sets the state to RUNNING.
     * &lt;/li&gt;
     * &lt;li&gt;The server transitions to the ERROR state if it hits an internal
     * error. {@link ZooKeeperServerListenerImpl} notifies any critical resource
     * error events, e.g., SyncRequestProcessor not being able to write a txn to
     * disk.&lt;/li&gt;
     * &lt;li&gt;During shutdown the server sets the state to SHUTDOWN, which
     * corresponds to the server not running.&lt;/li&gt;
     *
     * @param state new server state.
     */
    protected void setState(State state) {
<span class="fc" id="L517">        this.state = state;</span>
        // Notify server state changes to the registered shutdown handler, if any.
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">        if (zkShutdownHandler != null) {</span>
<span class="nc" id="L520">            zkShutdownHandler.handle(state);</span>
        } else {
<span class="fc" id="L522">            LOG.debug(&quot;ZKShutdownHandler is not registered, so ZooKeeper server &quot;</span>
                    + &quot;won't take any action on ERROR or SHUTDOWN server state changes&quot;);
        }
<span class="fc" id="L525">    }</span>

    /**
     * This can be used while shutting down the server to see whether the server
     * is already shutdown or not.
     *
     * @return true if the server is running or server hits an error, false
     *         otherwise.
     */
    protected boolean canShutdown() {
<span class="pc bpc" id="L535" title="3 of 4 branches missed.">        return state == State.RUNNING || state == State.ERROR;</span>
    }

    /**
     * @return true if the server is running, false otherwise.
     */
    public boolean isRunning() {
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        return state == State.RUNNING;</span>
    }

    public void shutdown() {
<span class="fc" id="L546">        shutdown(false);</span>
<span class="fc" id="L547">    }</span>

    /**
     * Shut down the server instance
     * @param fullyShutDown true if another server using the same database will not replace this one in the same process
     */
    public synchronized void shutdown(boolean fullyShutDown) {
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        if (!canShutdown()) {</span>
<span class="nc" id="L555">            LOG.debug(&quot;ZooKeeper server is not running, so not proceeding to shutdown!&quot;);</span>
<span class="nc" id="L556">            return;</span>
        }
<span class="fc" id="L558">        LOG.info(&quot;shutting down&quot;);</span>

        // new RuntimeException(&quot;Calling shutdown&quot;).printStackTrace();
<span class="fc" id="L561">        setState(State.SHUTDOWN);</span>
        // Since sessionTracker and syncThreads poll we just have to
        // set running to false and they will detect it during the poll
        // interval.
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">        if (sessionTracker != null) {</span>
<span class="fc" id="L566">            sessionTracker.shutdown();</span>
        }
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">        if (firstProcessor != null) {</span>
<span class="fc" id="L569">            firstProcessor.shutdown();</span>
        }

<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        if (zkDb != null) {</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">            if (fullyShutDown) {</span>
<span class="nc" id="L574">                zkDb.clear();</span>
            } else {
                // else there is no need to clear the database
                //  * When a new quorum is established we can still apply the diff
                //    on top of the same zkDb data
                //  * If we fetch a new snapshot from leader, the zkDb will be
                //    cleared anyway before loading the snapshot
                try {
                    //This will fast forward the database to the latest recorded transactions
<span class="fc" id="L583">                    zkDb.fastForwardDataBase();</span>
<span class="nc" id="L584">                } catch (IOException e) {</span>
<span class="nc" id="L585">                    LOG.error(&quot;Error updating DB&quot;, e);</span>
<span class="nc" id="L586">                    zkDb.clear();</span>
<span class="fc" id="L587">                }</span>
            }
        }

<span class="fc" id="L591">        unregisterJMX();</span>
<span class="fc" id="L592">    }</span>

    protected void unregisterJMX() {
        // unregister from JMX
        try {
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">            if (jmxDataTreeBean != null) {</span>
<span class="fc" id="L598">                MBeanRegistry.getInstance().unregister(jmxDataTreeBean);</span>
            }
<span class="nc" id="L600">        } catch (Exception e) {</span>
<span class="nc" id="L601">            LOG.warn(&quot;Failed to unregister with JMX&quot;, e);</span>
<span class="fc" id="L602">        }</span>
        try {
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">            if (jmxServerBean != null) {</span>
<span class="fc" id="L605">                MBeanRegistry.getInstance().unregister(jmxServerBean);</span>
            }
<span class="nc" id="L607">        } catch (Exception e) {</span>
<span class="nc" id="L608">            LOG.warn(&quot;Failed to unregister with JMX&quot;, e);</span>
<span class="fc" id="L609">        }</span>
<span class="fc" id="L610">        jmxServerBean = null;</span>
<span class="fc" id="L611">        jmxDataTreeBean = null;</span>
<span class="fc" id="L612">    }</span>

    public void incInProcess() {
<span class="fc" id="L615">        requestsInProcess.incrementAndGet();</span>
<span class="fc" id="L616">    }</span>

    public void decInProcess() {
<span class="fc" id="L619">        requestsInProcess.decrementAndGet();</span>
<span class="fc" id="L620">    }</span>

    public int getInProcess() {
<span class="fc" id="L623">        return requestsInProcess.get();</span>
    }

    /**
     * This structure is used to facilitate information sharing between PrepRP
     * and FinalRP.
     */
    static class ChangeRecord {
        ChangeRecord(long zxid, String path, StatPersisted stat, int childCount,
<span class="nc" id="L632">                List&lt;ACL&gt; acl) {</span>
<span class="nc" id="L633">            this.zxid = zxid;</span>
<span class="nc" id="L634">            this.path = path;</span>
<span class="nc" id="L635">            this.stat = stat;</span>
<span class="nc" id="L636">            this.childCount = childCount;</span>
<span class="nc" id="L637">            this.acl = acl;</span>
<span class="nc" id="L638">        }</span>

        long zxid;

        String path;

        StatPersisted stat; /* Make sure to create a new object when changing */

        int childCount;

        List&lt;ACL&gt; acl; /* Make sure to create a new object when changing */

        ChangeRecord duplicate(long zxid) {
<span class="nc" id="L651">            StatPersisted stat = new StatPersisted();</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (this.stat != null) {</span>
<span class="nc" id="L653">                DataTree.copyStatPersisted(this.stat, stat);</span>
            }
<span class="nc" id="L655">            return new ChangeRecord(zxid, path, stat, childCount,</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                    acl == null ? new ArrayList&lt;ACL&gt;() : new ArrayList&lt;ACL&gt;(acl));</span>
        }
    }

    byte[] generatePasswd(long id) {
<span class="fc" id="L661">        Random r = new Random(id ^ superSecret);</span>
<span class="fc" id="L662">        byte p[] = new byte[16];</span>
<span class="fc" id="L663">        r.nextBytes(p);</span>
<span class="fc" id="L664">        return p;</span>
    }

    protected boolean checkPasswd(long sessionId, byte[] passwd) {
<span class="nc bnc" id="L668" title="All 2 branches missed.">        return sessionId != 0</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">                &amp;&amp; Arrays.equals(passwd, generatePasswd(sessionId));</span>
    }

    long createSession(ServerCnxn cnxn, byte passwd[], int timeout) {
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">        if (passwd == null) {</span>
            // Possible since it's just deserialized from a packet on the wire.
<span class="nc" id="L675">            passwd = new byte[0];</span>
        }
<span class="fc" id="L677">        long sessionId = sessionTracker.createSession(timeout);</span>
<span class="fc" id="L678">        Random r = new Random(sessionId ^ superSecret);</span>
<span class="fc" id="L679">        r.nextBytes(passwd);</span>
<span class="fc" id="L680">        ByteBuffer to = ByteBuffer.allocate(4);</span>
<span class="fc" id="L681">        to.putInt(timeout);</span>
<span class="fc" id="L682">        cnxn.setSessionId(sessionId);</span>
<span class="fc" id="L683">        Request si = new Request(cnxn, sessionId, 0, OpCode.createSession, to, null);</span>
<span class="fc" id="L684">        setLocalSessionFlag(si);</span>
<span class="fc" id="L685">        submitRequest(si);</span>
<span class="fc" id="L686">        return sessionId;</span>
    }

    /**
     * set the owner of this session as owner
     * @param id the session id
     * @param owner the owner of the session
     * @throws SessionExpiredException
     */
    public void setOwner(long id, Object owner) throws SessionExpiredException {
<span class="fc" id="L696">        sessionTracker.setOwner(id, owner);</span>
<span class="fc" id="L697">    }</span>

    protected void revalidateSession(ServerCnxn cnxn, long sessionId,
            int sessionTimeout) throws IOException {
<span class="nc" id="L701">        boolean rc = sessionTracker.touchSession(sessionId, sessionTimeout);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L703">            ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,</span>
<span class="nc" id="L704">                    &quot;Session 0x&quot; + Long.toHexString(sessionId) +</span>
                            &quot; is valid: &quot; + rc);
        }
<span class="nc" id="L707">        finishSessionInit(cnxn, rc);</span>
<span class="nc" id="L708">    }</span>

    public void reopenSession(ServerCnxn cnxn, long sessionId, byte[] passwd,
            int sessionTimeout) throws IOException {
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (checkPasswd(sessionId, passwd)) {</span>
<span class="nc" id="L713">            revalidateSession(cnxn, sessionId, sessionTimeout);</span>
        } else {
<span class="nc" id="L715">            LOG.warn(&quot;Incorrect password from &quot; + cnxn.getRemoteSocketAddress()</span>
<span class="nc" id="L716">                    + &quot; for session 0x&quot; + Long.toHexString(sessionId));</span>
<span class="nc" id="L717">            finishSessionInit(cnxn, false);</span>
        }
<span class="nc" id="L719">    }</span>

    public void finishSessionInit(ServerCnxn cnxn, boolean valid) {
        // register with JMX
        try {
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">            if (valid) {</span>
<span class="pc bpc" id="L725" title="2 of 4 branches missed.">                if (serverCnxnFactory != null &amp;&amp; serverCnxnFactory.cnxns.contains(cnxn)) {</span>
<span class="fc" id="L726">                    serverCnxnFactory.registerConnection(cnxn);</span>
<span class="nc bnc" id="L727" title="All 4 branches missed.">                } else if (secureServerCnxnFactory != null &amp;&amp; secureServerCnxnFactory.cnxns.contains(cnxn)) {</span>
<span class="nc" id="L728">                    secureServerCnxnFactory.registerConnection(cnxn);</span>
                }
            }
<span class="nc" id="L731">        } catch (Exception e) {</span>
<span class="nc" id="L732">            LOG.warn(&quot;Failed to register with JMX&quot;, e);</span>
<span class="fc" id="L733">        }</span>

        try {
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">            ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout()</span>
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">                    : 0, valid ? cnxn.getSessionId() : 0, // send 0 if session is no</span>
                            // longer valid
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">                            valid ? generatePasswd(cnxn.getSessionId()) : new byte[16]);</span>
<span class="fc" id="L740">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L741">            BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);</span>
<span class="fc" id="L742">            bos.writeInt(-1, &quot;len&quot;);</span>
<span class="fc" id="L743">            rsp.serialize(bos, &quot;connect&quot;);</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">            if (!cnxn.isOldClient) {</span>
<span class="fc" id="L745">                bos.writeBool(</span>
                        this instanceof ReadOnlyZooKeeperServer, &quot;readOnly&quot;);
            }
<span class="fc" id="L748">            baos.close();</span>
<span class="fc" id="L749">            ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());</span>
<span class="fc" id="L750">            bb.putInt(bb.remaining() - 4).rewind();</span>
<span class="fc" id="L751">            cnxn.sendBuffer(bb);</span>

<span class="pc bpc" id="L753" title="1 of 2 branches missed.">            if (valid) {</span>
<span class="fc" id="L754">                LOG.debug(&quot;Established session 0x&quot;</span>
<span class="fc" id="L755">                        + Long.toHexString(cnxn.getSessionId())</span>
<span class="fc" id="L756">                        + &quot; with negotiated timeout &quot; + cnxn.getSessionTimeout()</span>
                        + &quot; for client &quot;
<span class="fc" id="L758">                        + cnxn.getRemoteSocketAddress());</span>
<span class="fc" id="L759">                cnxn.enableRecv();</span>
            } else {

<span class="nc" id="L762">                LOG.info(&quot;Invalid session 0x&quot;</span>
<span class="nc" id="L763">                        + Long.toHexString(cnxn.getSessionId())</span>
                        + &quot; for client &quot;
<span class="nc" id="L765">                        + cnxn.getRemoteSocketAddress()</span>
                        + &quot;, probably expired&quot;);
<span class="nc" id="L767">                cnxn.sendBuffer(ServerCnxnFactory.closeConn);</span>
            }

<span class="nc" id="L770">        } catch (Exception e) {</span>
<span class="nc" id="L771">            LOG.warn(&quot;Exception while establishing session, closing&quot;, e);</span>
<span class="nc" id="L772">            cnxn.close();</span>
<span class="fc" id="L773">        }</span>
<span class="fc" id="L774">    }</span>

    public void closeSession(ServerCnxn cnxn, RequestHeader requestHeader) {
<span class="nc" id="L777">        closeSession(cnxn.getSessionId());</span>
<span class="nc" id="L778">    }</span>

    public long getServerId() {
<span class="fc" id="L781">        return 0;</span>
    }

    /**
     * If the underlying Zookeeper server support local session, this method
     * will set a isLocalSession to true if a request is associated with
     * a local session.
     *
     * @param si
     */
    protected void setLocalSessionFlag(Request si) {
<span class="fc" id="L792">    }</span>

    public void submitRequest(Request si) {
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">        if (firstProcessor == null) {</span>
<span class="nc" id="L796">            synchronized (this) {</span>
                try {
                    // Since all requests are passed to the request
                    // processor it should wait for setting up the request
                    // processor chain. The state will be updated to RUNNING
                    // after the setup.
<span class="nc bnc" id="L802" title="All 2 branches missed.">                    while (state == State.INITIAL) {</span>
<span class="nc" id="L803">                        wait(1000);</span>
                    }
<span class="nc" id="L805">                } catch (InterruptedException e) {</span>
<span class="nc" id="L806">                    LOG.warn(&quot;Unexpected interruption&quot;, e);</span>
<span class="nc" id="L807">                }</span>
<span class="nc bnc" id="L808" title="All 4 branches missed.">                if (firstProcessor == null || state != State.RUNNING) {</span>
<span class="nc" id="L809">                    throw new RuntimeException(&quot;Not started&quot;);</span>
                }
<span class="nc" id="L811">            }</span>
        }
        try {
<span class="fc" id="L814">            touch(si.cnxn);</span>
<span class="fc" id="L815">            boolean validpacket = Request.isValid(si.type);</span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">            if (validpacket) {</span>
<span class="fc" id="L817">                firstProcessor.processRequest(si);</span>
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">                if (si.cnxn != null) {</span>
<span class="fc" id="L819">                    incInProcess();</span>
                }
            } else {
<span class="nc" id="L822">                LOG.warn(&quot;Received packet at server of unknown type &quot; + si.type);</span>
<span class="nc" id="L823">                new UnimplementedRequestProcessor().processRequest(si);</span>
            }
<span class="nc" id="L825">        } catch (MissingSessionException e) {</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L827">                LOG.debug(&quot;Dropping request: &quot; + e.getMessage());</span>
            }
<span class="nc" id="L829">        } catch (RequestProcessorException e) {</span>
<span class="nc" id="L830">            LOG.error(&quot;Unable to process request:&quot; + e.getMessage(), e);</span>
<span class="pc" id="L831">        }</span>
<span class="fc" id="L832">    }</span>

    public static int getSnapCount() {
<span class="fc" id="L835">        String sc = System.getProperty(&quot;zookeeper.snapCount&quot;);</span>
        try {
<span class="nc" id="L837">            int snapCount = Integer.parseInt(sc);</span>

            // snapCount must be 2 or more. See org.apache.zookeeper.server.SyncRequestProcessor
<span class="nc bnc" id="L840" title="All 2 branches missed.">            if( snapCount &lt; 2 ) {</span>
<span class="nc" id="L841">                LOG.warn(&quot;SnapCount should be 2 or more. Now, snapCount is reset to 2&quot;);</span>
<span class="nc" id="L842">                snapCount = 2;</span>
            }
<span class="nc" id="L844">            return snapCount;</span>
<span class="fc" id="L845">        } catch (Exception e) {</span>
<span class="fc" id="L846">            return 100000;</span>
        }
    }

    public int getGlobalOutstandingLimit() {
<span class="fc" id="L851">        String sc = System.getProperty(&quot;zookeeper.globalOutstandingLimit&quot;);</span>
        int limit;
        try {
<span class="nc" id="L854">            limit = Integer.parseInt(sc);</span>
<span class="fc" id="L855">        } catch (Exception e) {</span>
<span class="fc" id="L856">            limit = 1000;</span>
<span class="nc" id="L857">        }</span>
<span class="fc" id="L858">        return limit;</span>
    }

    public void setServerCnxnFactory(ServerCnxnFactory factory) {
<span class="fc" id="L862">        serverCnxnFactory = factory;</span>
<span class="fc" id="L863">    }</span>

    public ServerCnxnFactory getServerCnxnFactory() {
<span class="nc" id="L866">        return serverCnxnFactory;</span>
    }

    public ServerCnxnFactory getSecureServerCnxnFactory() {
<span class="nc" id="L870">        return secureServerCnxnFactory;</span>
    }

    public void setSecureServerCnxnFactory(ServerCnxnFactory factory) {
<span class="nc" id="L874">        secureServerCnxnFactory = factory;</span>
<span class="nc" id="L875">    }</span>

    /**
     * return the last proceesed id from the
     * datatree
     */
    public long getLastProcessedZxid() {
<span class="fc" id="L882">        return zkDb.getDataTreeLastProcessedZxid();</span>
    }

    /**
     * return the outstanding requests
     * in the queue, which havent been
     * processed yet
     */
    public long getOutstandingRequests() {
<span class="fc" id="L891">        return getInProcess();</span>
    }

    /**
     * return the total number of client connections that are alive
     * to this server
     */
    public int getNumAliveConnections() {
<span class="fc" id="L899">        int numAliveConnections = 0;</span>

<span class="pc bpc" id="L901" title="1 of 2 branches missed.">        if (serverCnxnFactory != null) {</span>
<span class="fc" id="L902">            numAliveConnections += serverCnxnFactory.getNumAliveConnections();</span>
        }

<span class="pc bpc" id="L905" title="1 of 2 branches missed.">        if (secureServerCnxnFactory != null) {</span>
<span class="nc" id="L906">            numAliveConnections += secureServerCnxnFactory.getNumAliveConnections();</span>
        }

<span class="fc" id="L909">        return numAliveConnections;</span>
    }

    /**
     * trunccate the log to get in sync with others
     * if in a quorum
     * @param zxid the zxid that it needs to get in sync
     * with others
     * @throws IOException
     */
    public void truncateLog(long zxid) throws IOException {
<span class="nc" id="L920">        this.zkDb.truncateLog(zxid);</span>
<span class="nc" id="L921">    }</span>

    public int getTickTime() {
<span class="nc" id="L924">        return tickTime;</span>
    }

    public void setTickTime(int tickTime) {
<span class="nc" id="L928">        LOG.info(&quot;tickTime set to &quot; + tickTime);</span>
<span class="nc" id="L929">        this.tickTime = tickTime;</span>
<span class="nc" id="L930">    }</span>

    public int getMinSessionTimeout() {
<span class="fc" id="L933">        return minSessionTimeout;</span>
    }

    public void setMinSessionTimeout(int min) {
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">        this.minSessionTimeout = min == -1 ? tickTime * 2 : min;</span>
<span class="fc" id="L938">        LOG.info(&quot;minSessionTimeout set to {}&quot;, this.minSessionTimeout);</span>
<span class="fc" id="L939">    }</span>

    public int getMaxSessionTimeout() {
<span class="fc" id="L942">        return maxSessionTimeout;</span>
    }

    public void setMaxSessionTimeout(int max) {
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">        this.maxSessionTimeout = max == -1 ? tickTime * 20 : max;</span>
<span class="fc" id="L947">        LOG.info(&quot;maxSessionTimeout set to {}&quot;, this.maxSessionTimeout);</span>
<span class="fc" id="L948">    }</span>

    public int getClientPort() {
<span class="pc bpc" id="L951" title="1 of 2 branches missed.">        return serverCnxnFactory != null ? serverCnxnFactory.getLocalPort() : -1;</span>
    }

    public int getSecureClientPort() {
<span class="nc bnc" id="L955" title="All 2 branches missed.">        return secureServerCnxnFactory != null ? secureServerCnxnFactory.getLocalPort() : -1;</span>
    }

    /** Maximum number of connections allowed from particular host (ip) */
    public int getMaxClientCnxnsPerHost() {
<span class="nc bnc" id="L960" title="All 2 branches missed.">        if (serverCnxnFactory != null) {</span>
<span class="nc" id="L961">            return serverCnxnFactory.getMaxClientCnxnsPerHost();</span>
        }
<span class="nc bnc" id="L963" title="All 2 branches missed.">        if (secureServerCnxnFactory != null) {</span>
<span class="nc" id="L964">            return secureServerCnxnFactory.getMaxClientCnxnsPerHost();</span>
        }
<span class="nc" id="L966">        return -1;</span>
    }

    public void setTxnLogFactory(FileTxnSnapLog txnLog) {
<span class="nc" id="L970">        this.txnLogFactory = txnLog;</span>
<span class="nc" id="L971">    }</span>

    public FileTxnSnapLog getTxnLogFactory() {
<span class="nc" id="L974">        return this.txnLogFactory;</span>
    }

    /**
     * Returns the elapsed sync of time of transaction log in milliseconds.
     */
    public long getTxnLogElapsedSyncTime() {
<span class="nc" id="L981">        return txnLogFactory.getTxnLogElapsedSyncTime();</span>
    }

    public String getState() {
<span class="fc" id="L985">        return &quot;standalone&quot;;</span>
    }

    public void dumpEphemerals(PrintWriter pwriter) {
<span class="nc" id="L989">        zkDb.dumpEphemerals(pwriter);</span>
<span class="nc" id="L990">    }</span>

    public Map&lt;Long, Set&lt;String&gt;&gt; getEphemerals() {
<span class="nc" id="L993">        return zkDb.getEphemerals();</span>
    }

    public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException {
<span class="fc" id="L997">        BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(incomingBuffer));</span>
<span class="fc" id="L998">        ConnectRequest connReq = new ConnectRequest();</span>
<span class="fc" id="L999">        connReq.deserialize(bia, &quot;connect&quot;);</span>
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1001">            LOG.debug(&quot;Session establishment request from client &quot;</span>
<span class="nc" id="L1002">                    + cnxn.getRemoteSocketAddress()</span>
                    + &quot; client's lastZxid is 0x&quot;
<span class="nc" id="L1004">                    + Long.toHexString(connReq.getLastZxidSeen()));</span>
        }
<span class="fc" id="L1006">        boolean readOnly = false;</span>
        try {
<span class="fc" id="L1008">            readOnly = bia.readBool(&quot;readOnly&quot;);</span>
<span class="fc" id="L1009">            cnxn.isOldClient = false;</span>
<span class="nc" id="L1010">        } catch (IOException e) {</span>
            // this is ok -- just a packet from an old client which
            // doesn't contain readOnly field
<span class="nc" id="L1013">            LOG.warn(&quot;Connection request from old client &quot;</span>
<span class="nc" id="L1014">                    + cnxn.getRemoteSocketAddress()</span>
                    + &quot;; will be dropped if server is in r-o mode&quot;);
<span class="fc" id="L1016">        }</span>
<span class="pc bpc" id="L1017" title="2 of 4 branches missed.">        if (!readOnly &amp;&amp; this instanceof ReadOnlyZooKeeperServer) {</span>
<span class="nc" id="L1018">            String msg = &quot;Refusing session request for not-read-only client &quot;</span>
<span class="nc" id="L1019">                + cnxn.getRemoteSocketAddress();</span>
<span class="nc" id="L1020">            LOG.info(msg);</span>
<span class="nc" id="L1021">            throw new CloseRequestException(msg);</span>
        }
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">        if (connReq.getLastZxidSeen() &gt; zkDb.dataTree.lastProcessedZxid) {</span>
<span class="nc" id="L1024">            String msg = &quot;Refusing session request for client &quot;</span>
<span class="nc" id="L1025">                + cnxn.getRemoteSocketAddress()</span>
                + &quot; as it has seen zxid 0x&quot;
<span class="nc" id="L1027">                + Long.toHexString(connReq.getLastZxidSeen())</span>
                + &quot; our last zxid is 0x&quot;
<span class="nc" id="L1029">                + Long.toHexString(getZKDatabase().getDataTreeLastProcessedZxid())</span>
                + &quot; client must try another server&quot;;

<span class="nc" id="L1032">            LOG.info(msg);</span>
<span class="nc" id="L1033">            throw new CloseRequestException(msg);</span>
        }
<span class="fc" id="L1035">        int sessionTimeout = connReq.getTimeOut();</span>
<span class="fc" id="L1036">        byte passwd[] = connReq.getPasswd();</span>
<span class="fc" id="L1037">        int minSessionTimeout = getMinSessionTimeout();</span>
<span class="pc bpc" id="L1038" title="1 of 2 branches missed.">        if (sessionTimeout &lt; minSessionTimeout) {</span>
<span class="nc" id="L1039">            sessionTimeout = minSessionTimeout;</span>
        }
<span class="fc" id="L1041">        int maxSessionTimeout = getMaxSessionTimeout();</span>
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">        if (sessionTimeout &gt; maxSessionTimeout) {</span>
<span class="nc" id="L1043">            sessionTimeout = maxSessionTimeout;</span>
        }
<span class="fc" id="L1045">        cnxn.setSessionTimeout(sessionTimeout);</span>
        // We don't want to receive any packets until we are sure that the
        // session is setup
<span class="fc" id="L1048">        cnxn.disableRecv();</span>
<span class="fc" id="L1049">        long sessionId = connReq.getSessionId();</span>
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">        if (sessionId == 0) {</span>
<span class="fc" id="L1051">            long id = createSession(cnxn, passwd, sessionTimeout);</span>
<span class="fc" id="L1052">            LOG.debug(&quot;Client attempting to establish new session:&quot; +</span>
                            &quot; session = 0x{}, zxid = 0x{}, timeout = {}, address = {}&quot;,
<span class="fc" id="L1054">                    Long.toHexString(id),</span>
<span class="fc" id="L1055">                    Long.toHexString(connReq.getLastZxidSeen()),</span>
<span class="fc" id="L1056">                    connReq.getTimeOut(),</span>
<span class="fc" id="L1057">                    cnxn.getRemoteSocketAddress());</span>
<span class="fc" id="L1058">        } else {</span>
<span class="nc" id="L1059">            long clientSessionId = connReq.getSessionId();</span>
<span class="nc" id="L1060">            LOG.debug(&quot;Client attempting to renew session:&quot; +</span>
                            &quot; session = 0x{}, zxid = 0x{}, timeout = {}, address = {}&quot;,
<span class="nc" id="L1062">                    Long.toHexString(clientSessionId),</span>
<span class="nc" id="L1063">                    Long.toHexString(connReq.getLastZxidSeen()),</span>
<span class="nc" id="L1064">                    connReq.getTimeOut(),</span>
<span class="nc" id="L1065">                    cnxn.getRemoteSocketAddress());</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">            if (serverCnxnFactory != null) {</span>
<span class="nc" id="L1067">                serverCnxnFactory.closeSession(sessionId);</span>
            }
<span class="nc bnc" id="L1069" title="All 2 branches missed.">            if (secureServerCnxnFactory != null) {</span>
<span class="nc" id="L1070">                secureServerCnxnFactory.closeSession(sessionId);</span>
            }
<span class="nc" id="L1072">            cnxn.setSessionId(sessionId);</span>
<span class="nc" id="L1073">            reopenSession(cnxn, sessionId, passwd, sessionTimeout);</span>
        }
<span class="fc" id="L1075">    }</span>

    public boolean shouldThrottle(long outStandingCount) {
<span class="nc bnc" id="L1078" title="All 2 branches missed.">        if (getGlobalOutstandingLimit() &lt; getInProcess()) {</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            return outStandingCount &gt; 0;</span>
        }
<span class="nc" id="L1081">        return false;</span>
    }

    public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException {
        // We have the request, now process and setup for next
<span class="fc" id="L1086">        InputStream bais = new ByteBufferInputStream(incomingBuffer);</span>
<span class="fc" id="L1087">        BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);</span>
<span class="fc" id="L1088">        RequestHeader h = new RequestHeader();</span>
<span class="fc" id="L1089">        h.deserialize(bia, &quot;header&quot;);</span>
        // Through the magic of byte buffers, txn will not be
        // pointing
        // to the start of the txn
<span class="fc" id="L1093">        incomingBuffer = incomingBuffer.slice();</span>
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">        if (h.getType() == OpCode.auth) {</span>
<span class="nc" id="L1095">            LOG.info(&quot;got auth packet &quot; + cnxn.getRemoteSocketAddress());</span>
<span class="nc" id="L1096">            AuthPacket authPacket = new AuthPacket();</span>
<span class="nc" id="L1097">            ByteBufferInputStream.byteBuffer2Record(incomingBuffer, authPacket);</span>
<span class="nc" id="L1098">            String scheme = authPacket.getScheme();</span>
<span class="nc" id="L1099">            AuthenticationProvider ap = ProviderRegistry.getProvider(scheme);</span>
<span class="nc" id="L1100">            Code authReturn = KeeperException.Code.AUTHFAILED;</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">            if(ap != null) {</span>
                try {
<span class="nc" id="L1103">                    authReturn = ap.handleAuthentication(cnxn, authPacket.getAuth());</span>
<span class="nc" id="L1104">                } catch(RuntimeException e) {</span>
<span class="nc" id="L1105">                    LOG.warn(&quot;Caught runtime exception from AuthenticationProvider: &quot; + scheme + &quot; due to &quot; + e);</span>
<span class="nc" id="L1106">                    authReturn = KeeperException.Code.AUTHFAILED;</span>
<span class="nc" id="L1107">                }</span>
            }
<span class="nc bnc" id="L1109" title="All 2 branches missed.">            if (authReturn == KeeperException.Code.OK) {</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1111">                    LOG.debug(&quot;Authentication succeeded for scheme: &quot; + scheme);</span>
                }
<span class="nc" id="L1113">                LOG.info(&quot;auth success &quot; + cnxn.getRemoteSocketAddress());</span>
<span class="nc" id="L1114">                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,</span>
<span class="nc" id="L1115">                        KeeperException.Code.OK.intValue());</span>
<span class="nc" id="L1116">                cnxn.sendResponse(rh, null, null);</span>
<span class="nc" id="L1117">            } else {</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                if (ap == null) {</span>
<span class="nc" id="L1119">                    LOG.warn(&quot;No authentication provider for scheme: &quot;</span>
                            + scheme + &quot; has &quot;
<span class="nc" id="L1121">                            + ProviderRegistry.listProviders());</span>
                } else {
<span class="nc" id="L1123">                    LOG.warn(&quot;Authentication failed for scheme: &quot; + scheme);</span>
                }
                // send a response...
<span class="nc" id="L1126">                ReplyHeader rh = new ReplyHeader(h.getXid(), 0,</span>
<span class="nc" id="L1127">                        KeeperException.Code.AUTHFAILED.intValue());</span>
<span class="nc" id="L1128">                cnxn.sendResponse(rh, null, null);</span>
                // ... and close connection
<span class="nc" id="L1130">                cnxn.sendBuffer(ServerCnxnFactory.closeConn);</span>
<span class="nc" id="L1131">                cnxn.disableRecv();</span>
            }
<span class="nc" id="L1133">            return;</span>
        } else {
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">            if (h.getType() == OpCode.sasl) {</span>
<span class="nc" id="L1136">                Record rsp = processSasl(incomingBuffer,cnxn);</span>
<span class="nc" id="L1137">                ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());</span>
<span class="nc" id="L1138">                cnxn.sendResponse(rh,rsp, &quot;response&quot;); // not sure about 3rd arg..what is it?</span>
<span class="nc" id="L1139">                return;</span>
            }
            else {
<span class="fc" id="L1142">                Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),</span>
<span class="fc" id="L1143">                  h.getType(), incomingBuffer, cnxn.getAuthInfo());</span>
<span class="fc" id="L1144">                si.setOwner(ServerCnxn.me);</span>
                // Always treat packet from the client as a possible
                // local request.
<span class="fc" id="L1147">                setLocalSessionFlag(si);</span>
<span class="fc" id="L1148">                submitRequest(si);</span>
            }
        }
<span class="fc" id="L1151">        cnxn.incrOutstandingRequests(h);</span>
<span class="fc" id="L1152">    }</span>

    private Record processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn) throws IOException {
<span class="nc" id="L1155">        LOG.debug(&quot;Responding to client SASL token.&quot;);</span>
<span class="nc" id="L1156">        GetSASLRequest clientTokenRecord = new GetSASLRequest();</span>
<span class="nc" id="L1157">        ByteBufferInputStream.byteBuffer2Record(incomingBuffer,clientTokenRecord);</span>
<span class="nc" id="L1158">        byte[] clientToken = clientTokenRecord.getToken();</span>
<span class="nc" id="L1159">        LOG.debug(&quot;Size of client SASL token: &quot; + clientToken.length);</span>
<span class="nc" id="L1160">        byte[] responseToken = null;</span>
        try {
<span class="nc" id="L1162">            ZooKeeperSaslServer saslServer  = cnxn.zooKeeperSaslServer;</span>
            try {
                // note that clientToken might be empty (clientToken.length == 0):
                // if using the DIGEST-MD5 mechanism, clientToken will be empty at the beginning of the
                // SASL negotiation process.
<span class="nc" id="L1167">                responseToken = saslServer.evaluateResponse(clientToken);</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">                if (saslServer.isComplete()) {</span>
<span class="nc" id="L1169">                    String authorizationID = saslServer.getAuthorizationID();</span>
<span class="nc" id="L1170">                    LOG.info(&quot;adding SASL authorization for authorizationID: &quot; + authorizationID);</span>
<span class="nc" id="L1171">                    cnxn.addAuthInfo(new Id(&quot;sasl&quot;,authorizationID));</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">                    if (System.getProperty(&quot;zookeeper.superUser&quot;) != null &amp;&amp; </span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                        authorizationID.equals(System.getProperty(&quot;zookeeper.superUser&quot;))) {</span>
<span class="nc" id="L1174">                        cnxn.addAuthInfo(new Id(&quot;super&quot;, &quot;&quot;));</span>
                    }
                }
            }
<span class="nc" id="L1178">            catch (SaslException e) {</span>
<span class="nc" id="L1179">                LOG.warn(&quot;Client failed to SASL authenticate: &quot; + e, e);</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">                if ((System.getProperty(&quot;zookeeper.allowSaslFailedClients&quot;) != null)</span>
                  &amp;&amp;
<span class="nc bnc" id="L1182" title="All 2 branches missed.">                  (System.getProperty(&quot;zookeeper.allowSaslFailedClients&quot;).equals(&quot;true&quot;))) {</span>
<span class="nc" id="L1183">                    LOG.warn(&quot;Maintaining client connection despite SASL authentication failure.&quot;);</span>
                } else {
<span class="nc" id="L1185">                    LOG.warn(&quot;Closing client connection due to SASL authentication failure.&quot;);</span>
<span class="nc" id="L1186">                    cnxn.close();</span>
                }
<span class="nc" id="L1188">            }</span>
        }
<span class="nc" id="L1190">        catch (NullPointerException e) {</span>
<span class="nc" id="L1191">            LOG.error(&quot;cnxn.saslServer is null: cnxn object did not initialize its saslServer properly.&quot;);</span>
<span class="nc" id="L1192">        }</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">        if (responseToken != null) {</span>
<span class="nc" id="L1194">            LOG.debug(&quot;Size of server SASL response: &quot; + responseToken.length);</span>
        }
        // wrap SASL response token to client inside a Response object.
<span class="nc" id="L1197">        return new SetSASLResponse(responseToken);</span>
    }

    // entry point for quorum/Learner.java
    public ProcessTxnResult processTxn(TxnHeader hdr, Record txn) {
<span class="nc" id="L1202">        return processTxn(null, hdr, txn);</span>
    }

    // entry point for FinalRequestProcessor.java
    public ProcessTxnResult processTxn(Request request) {
<span class="fc" id="L1207">        return processTxn(request, request.getHdr(), request.getTxn());</span>
    }

    private ProcessTxnResult processTxn(Request request, TxnHeader hdr,
                                        Record txn) {
        ProcessTxnResult rc;
<span class="pc bpc" id="L1213" title="1 of 2 branches missed.">        int opCode = request != null ? request.type : hdr.getType();</span>
<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">        long sessionId = request != null ? request.sessionId : hdr.getClientId();</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">        if (hdr != null) {</span>
<span class="fc" id="L1216">            rc = getZKDatabase().processTxn(hdr, txn);</span>
        } else {
<span class="fc" id="L1218">            rc = new ProcessTxnResult();</span>
        }
<span class="fc bfc" id="L1220" title="All 2 branches covered.">        if (opCode == OpCode.createSession) {</span>
<span class="pc bpc" id="L1221" title="2 of 4 branches missed.">            if (hdr != null &amp;&amp; txn instanceof CreateSessionTxn) {</span>
<span class="fc" id="L1222">                CreateSessionTxn cst = (CreateSessionTxn) txn;</span>
<span class="fc" id="L1223">                sessionTracker.addGlobalSession(sessionId, cst.getTimeOut());</span>
<span class="pc bnc" id="L1224" title="All 4 branches missed.">            } else if (request != null &amp;&amp; request.isLocalSession()) {</span>
<span class="nc" id="L1225">                request.request.rewind();</span>
<span class="nc" id="L1226">                int timeout = request.request.getInt();</span>
<span class="nc" id="L1227">                request.request.rewind();</span>
<span class="nc" id="L1228">                sessionTracker.addSession(request.sessionId, timeout);</span>
<span class="nc" id="L1229">            } else {</span>
<span class="nc" id="L1230">                LOG.warn(&quot;*****&gt;&gt;&gt;&gt;&gt; Got &quot;</span>
<span class="nc" id="L1231">                        + txn.getClass() + &quot; &quot;</span>
<span class="nc" id="L1232">                        + txn.toString());</span>
            }
<span class="fc bfc" id="L1234" title="All 2 branches covered.">        } else if (opCode == OpCode.closeSession) {</span>
<span class="fc" id="L1235">            sessionTracker.removeSession(sessionId);</span>
        }
<span class="fc" id="L1237">        return rc;</span>
    }

    public Map&lt;Long, Set&lt;Long&gt;&gt; getSessionExpiryMap() {
<span class="nc" id="L1241">        return sessionTracker.getSessionExpiryMap();</span>
    }

    /**
     * This method is used to register the ZooKeeperServerShutdownHandler to get
     * server's error or shutdown state change notifications.
     * {@link ZooKeeperServerShutdownHandler#handle(State)} will be called for
     * every server state changes {@link #setState(State)}.
     *
     * @param zkShutdownHandler shutdown handler
     */
    void registerServerShutdownHandler(ZooKeeperServerShutdownHandler zkShutdownHandler) {
<span class="nc" id="L1253">        this.zkShutdownHandler = zkShutdownHandler;</span>
<span class="nc" id="L1254">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>